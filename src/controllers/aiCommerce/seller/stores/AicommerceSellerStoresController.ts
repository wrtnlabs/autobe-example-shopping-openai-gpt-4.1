import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postaiCommerceSellerStores } from "../../../../providers/postaiCommerceSellerStores";
import { SellerAuth } from "../../../../decorators/SellerAuth";
import { SellerPayload } from "../../../../decorators/payload/SellerPayload";
import { patchaiCommerceSellerStores } from "../../../../providers/patchaiCommerceSellerStores";
import { getaiCommerceSellerStoresStoreId } from "../../../../providers/getaiCommerceSellerStoresStoreId";
import { putaiCommerceSellerStoresStoreId } from "../../../../providers/putaiCommerceSellerStoresStoreId";
import { deleteaiCommerceSellerStoresStoreId } from "../../../../providers/deleteaiCommerceSellerStoresStoreId";

import { IAiCommerceStores } from "../../../../api/structures/IAiCommerceStores";
import { IPageIAiCommerceStores } from "../../../../api/structures/IPageIAiCommerceStores";

@Controller("/aiCommerce/seller/stores")
export class AicommerceSellerStoresController {
  /**
   * Create a new store (ai_commerce_stores table) for an authenticated seller
   * or admin.
   *
   * This endpoint enables an authenticated seller (or admin) to register a new
   * store in the system. Store creation requires a valid seller_profile_id and
   * owner_user_id, and unique store_code. Business logic validates the
   * completeness of all fields, veracity of linked profiles, and the absence of
   * duplicates for critical identifiers.
   *
   * Upon successful creation, the endpoint returns the full store record with
   * all relational data, including identifiers, status, and the owner profile.
   * Security checks ensure only authorized sellers or platform admins can
   * invoke this operation. Any errors (validation, duplication, permission)
   * result in explicit business error codes. All creation events are strictly
   * logged for compliance purposes.
   *
   * @param connection
   * @param body Payload for creating a store, including core fields and
   *   business metadata as required by ai_commerce_stores.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @SellerAuth()
    seller: SellerPayload,
    @TypedBody()
    body: IAiCommerceStores.ICreate,
  ): Promise<IAiCommerceStores> {
    try {
      return await postaiCommerceSellerStores({
        seller,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a filtered, paginated list of stores
   * (ai_commerce_stores table).
   *
   * This API operation returns a paginated and searchable list of stores from
   * the ai_commerce_stores table. Advanced filtering can be performed on fields
   * such as store_name, store_code, approval_status, and owner_user_id,
   * supporting business workflows for sellers and platform administrators.
   *
   * Sellers are restricted to their own stores, while admins can query the
   * entire set. Buyers and visitors, if enabled, may only see public/active
   * stores, subject to business rules and approval_status. The response
   * includes pagination, summary data for each store (store ID, name, code,
   * status), and may contain additional analytics fields if available through
   * related tables.
   *
   * The listing supports sorting, search queries, and full-text indexing of
   * store names/codes. Business logic enforces role-based visibility and hides
   * stores that are closed or suspended for most roles. Extensive validation is
   * performed on query criteria and any errors are returned as
   * business-validation failures.
   *
   * @param connection
   * @param body Search, filter, and pagination parameters for store retrieval
   *   (fields from ai_commerce_stores, full-text search, etc).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SellerAuth()
    seller: SellerPayload,
    @TypedBody()
    body: IAiCommerceStores.IRequest,
  ): Promise<IPageIAiCommerceStores.ISummary> {
    try {
      return await patchaiCommerceSellerStores({
        seller,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve full store details (ai_commerce_stores table) for a given storeId.
   *
   * This API endpoint returns a detailed store record from the
   * ai_commerce_stores table, identified by storeId. The response contains all
   * defined fields, including store_name, store_code, store_metadata,
   * approval_status, closure_reason, and relational references such as
   * owner_user_id and seller_profile_id.
   *
   * Security checks ensure that sellers only access their own stores, while
   * admins have full visibility. Detailed store settings and analytics can be
   * included in the response through entity relationships, subject to business
   * rules and performance considerations.
   *
   * If the store does not exist or access is unauthorized, appropriate errors
   * are returned. This endpoint is used to drive business workflows for store
   * management, analytics, and audit trails. All access is logged for
   * compliance.
   *
   * @param connection
   * @param storeId The unique identifier of the store to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":storeId")
  public async at(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("storeId")
    storeId: string & tags.Format<"uuid">,
  ): Promise<IAiCommerceStores> {
    try {
      return await getaiCommerceSellerStoresStoreId({
        seller,
        storeId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a store (ai_commerce_stores table) identified by storeId for the
   * authenticated seller or admin.
   *
   * This endpoint allows a seller or admin to update the information of a
   * specific store, as identified by storeId. Permitted fields for editing
   * include store_name, store_metadata, approval_status, closure_reason, and
   * related configuration. The modification is allowed only for the store's
   * owner (seller) or a platform admin, and all field values are validated
   * according to the ai_commerce_stores Prisma schema.
   *
   * On successful update, the response contains the updated store record.
   * Unauthorized attempts, invalid data, or access violations return explicit
   * business error codes. This update is audit logged for platform compliance
   * and forensics.
   *
   * @param connection
   * @param storeId Unique identifier of the store to be updated (UUID).
   * @param body Payload of updatable store fields according to
   *   ai_commerce_stores schema.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":storeId")
  public async update(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("storeId")
    storeId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IAiCommerceStores.IUpdate,
  ): Promise<IAiCommerceStores> {
    try {
      return await putaiCommerceSellerStoresStoreId({
        seller,
        storeId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a store (ai_commerce_stores table) by storeId. Hard
   * delete only.
   *
   * This API deletes a store from the ai_commerce_stores table, permanently
   * removing the database record identified by storeId, as no soft delete field
   * is defined. Only the store owner (seller) or admin can invoke this
   * operation, governed by permissions and business rules.
   *
   * Prior to deletion, the platform validates dependencies to prevent breaking
   * referential integrity, such as linked products or analytics. Any violation
   * results in business-level error reporting. The delete operation itself is
   * strictly recorded in audit logs for platform compliance and legal review.
   *
   * If successful, the operation completes without a response body.
   * Unauthorized access, non-existent records, or dependency violations will
   * fail with appropriate errors.
   *
   * @param connection
   * @param storeId Unique identifier of the store to be deleted (UUID).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":storeId")
  public async erase(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("storeId")
    storeId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteaiCommerceSellerStoresStoreId({
        seller,
        storeId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
