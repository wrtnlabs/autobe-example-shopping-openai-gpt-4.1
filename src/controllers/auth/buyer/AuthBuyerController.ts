import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthBuyerJoin } from "../../../providers/postauthBuyerJoin";
import { postauthBuyerLogin } from "../../../providers/postauthBuyerLogin";
import { postauthBuyerRefresh } from "../../../providers/postauthBuyerRefresh";

import { IAiCommerceBuyer } from "../../../api/structures/IAiCommerceBuyer";
import { IBuyer } from "../../../api/structures/IBuyer";

@Controller("/auth/buyer")
export class AuthBuyerController {
  /**
   * Register a new buyer (ai_commerce_buyer table) and issue JWT tokens.
   *
   * This endpoint allows a new user to join as a buyer, creating a record in
   * the ai_commerce_buyer table. It sets up essential user fields (email,
   * hashed password, initial status) according to the schema's constraints.
   * Unique email enforcement prevents duplicate accounts, and the password is
   * never stored in plaintext. Upon completion, JWT tokens are issued to the
   * newly registered account for buyer-specific access to features like cart,
   * orders, reviews, and favorites.
   *
   * Account creation does not establish relationships with other entities until
   * the user completes further onboarding steps (e.g., profile, addresses).
   * Registered buyers may later be elevated to seller through separate flows.
   * All required information comes directly from the ai_commerce_buyer schema.
   *
   * After successful execution, the response contains authorized session tokens
   * per the defined response DTO, and initial linkage is established for all
   * future buyer data.
   *
   * Security: email uniqueness, password hashing, and basic field validation
   * are handled internally per schema constraints. Role elevation and
   * additional verification occur in separate business operations.
   *
   * @param connection
   * @param body Buyer registration information as required by ai_commerce_buyer
   *   table: email, password (plain, will be hashed), and any additional
   *   initial status if needed.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IBuyer.ICreate,
  ): Promise<IAiCommerceBuyer.IAuthorized> {
    try {
      return await postauthBuyerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate buyer by email and password (ai_commerce_buyer), return JWT
   * tokens.
   *
   * Login endpoint for buyers. Validates email and password per the
   * ai_commerce_buyer schema, checking for a non-deleted, active status
   * account. Password is compared using secure hash, and if successful, the
   * session management logic issues JWT access and refresh tokens using
   * IAiCommerceBuyer.IAuthorized DTO. Account status, failed attempts, and
   * error feedback are handled strictly by internal business rules, referencing
   * the password_hash and status fields in the database schema. Does not
   * support non-buyer login or social/external authentication.
   *
   * @param connection
   * @param body Buyer login parameters: email and password (plaintext, will be
   *   checked against stored hash in ai_commerce_buyer table, must match for
   *   successful login).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IBuyer.ILogin,
  ): Promise<IAiCommerceBuyer.IAuthorized> {
    try {
      return await postauthBuyerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh buyer session tokens using a valid refresh token
   * (ai_commerce_user_authentications).
   *
   * Refresh session JWT tokens for buyers. The submitted refresh token is
   * validated against the session records (ai_commerce_user_authentications)
   * for validity, non-expiry, and buyer_id linkage. Only sessions that are
   * active, not soft-deleted, and within defined expiration windows may be
   * refreshed. Upon validation, issues a new IAiCommerceBuyer.IAuthorized token
   * set, while old tokens may be revoked as per the internal session policy
   * (referencing session_expires_at and deleted_at fields). Standardized error
   * responses for invalid/expired tokens.
   *
   * @param connection
   * @param body Refresh token and session information (must correspond to
   *   existing, active record for the buyer in ai_commerce_user_authentications
   *   table).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IBuyer.IRefresh,
  ): Promise<IAiCommerceBuyer.IAuthorized> {
    try {
      return await postauthBuyerRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
