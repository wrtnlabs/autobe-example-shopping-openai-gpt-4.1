import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { post__auth_customer_join } from "../../../providers/post__auth_customer_join";
import { post__auth_customer_login } from "../../../providers/post__auth_customer_login";
import { post__auth_customer_refresh } from "../../../providers/post__auth_customer_refresh";

import { IShoppingMallAiBackendCustomer } from "../../../api/structures/IShoppingMallAiBackendCustomer";

@Controller("/auth/customer")
export class AuthCustomerController {
  /**
   * Register new customer in 'shopping_mall_ai_backend_customers', issuing
   * tokens.
   *
   * Customer registration endpoint for shopping mall service. It creates a new
   * member account, requiring email, phone number, secure password hash, legal
   * name, and (optional) nickname, mirroring the
   * 'shopping_mall_ai_backend_customers' schema. The flow issues JWT tokens,
   * sets 'is_active' and 'is_verified' states, and snapshots 'created_at' and
   * 'updated_at' for audit. Security policies enforce uniqueness of email and
   * phone, password hash integrity, and activity tracking (last_login_at null
   * at registration). New account is returned with authentication tokens for
   * API use. If duplicate, validation fails. The schema links this table to
   * customer withdrawal/session entities for lifecycle management. Error
   * scenarios include unique validation, identity verification failure, or
   * transaction rollback. Related operations: customer login, token refresh,
   * withdrawal. Only customers who complete onboarding will be 'is_active'.
   *
   * Field mapping:
   *
   * - Email, phone_number, password_hash, name from schema for onboarding
   * - Is_active true, is_verified as appropriate
   * - Last_login_at null on join, set on first login
   *
   * All core authn details are present in the schema. Do not create extra
   * fields.
   *
   * @param connection
   * @param body Customer registration for shopping mall service
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IShoppingMallAiBackendCustomer.IJoin,
  ): Promise<IShoppingMallAiBackendCustomer.IAuthorized> {
    try {
      return await post__auth_customer_join({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate customer ('shopping_mall_ai_backend_customers') and issue
   * tokens.
   *
   * Customer API login endpoint for shopping mall service. Authenticates by
   * validating provided email and password against the
   * 'shopping_mall_ai_backend_customers' table's 'email' and 'password_hash'.
   * Upon valid login, confirms that 'is_active' is true and 'deleted_at' is
   * null. If successful, updates 'last_login_at', issues new JWT access/refresh
   * tokens, and records session via
   * 'shopping_mall_ai_backend_customer_sessions'. Error handling: accounts not
   * found, password mismatch, disabled (is_active=false) or withdrawn
   * (deleted_at set), lockout handling after failed attempts. The login
   * endpoint is core to API auth flows, related to join (registration) and
   * refresh endpoints. All auth info in schema: check email, password_hash,
   * is_active; update last_login_at. No extra schema fields are needed or
   * permitted.
   *
   * @param connection
   * @param body API customer login parameters
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IShoppingMallAiBackendCustomer.ILogin,
  ): Promise<IShoppingMallAiBackendCustomer.IAuthorized> {
    try {
      return await post__auth_customer_login({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh customer authentication tokens using session refresh token
   * (member).
   *
   * Customer API token refresh process (shopping mall service) using the
   * existing refresh token. Validates the session's 'refresh_token' and
   * 'expires_at' against 'shopping_mall_ai_backend_customer_sessions'. If valid
   * and the account is still active/not withdrawn, issues new JWT tokens and
   * updates session records. Invalidates old tokens when appropriate. Returns
   * the authorized customer identity and tokens so APIs may continue without
   * re-login. Error scenarios handled: refresh token expired/terminated,
   * session not found, or user inactive/deleted. Closely related to login
   * endpoint. Every session event is recorded in the schema for
   * audit/compliance. No extra fields allowed. Crucial for securing extended
   * API access. This operation completes the authentication cycle for
   * member-level customer.
   *
   * @param connection
   * @param body API token refresh parameters (customer)
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IShoppingMallAiBackendCustomer.IRefresh,
  ): Promise<IShoppingMallAiBackendCustomer.IAuthorized> {
    try {
      return await post__auth_customer_refresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
