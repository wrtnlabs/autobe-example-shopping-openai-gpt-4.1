import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthSellerJoin } from "../../../providers/postauthSellerJoin";
import { postauthSellerLogin } from "../../../providers/postauthSellerLogin";
import { postauthSellerRefresh } from "../../../providers/postauthSellerRefresh";

import { IAiCommerceSeller } from "../../../api/structures/IAiCommerceSeller";

@Controller("/auth/seller")
export class AuthSellerController {
  /**
   * Register a new seller account (ai_commerce_seller table) and issue initial
   * tokens.
   *
   * This endpoint handles the registration of a new seller account for the
   * aiCommerce platform. Sellers are created as an elevated role, linked to a
   * buyer profile via the buyer_id field. The onboarding process begins by
   * collecting information such as email and password (stored as password_hash
   * for security), marking the seller's status as under_review. The operation
   * is strictly tied to the ai_commerce_seller and ai_commerce_buyer tables,
   * making use of core authentication fields documented by the schema.
   *
   * The account is set to under_review, and registration metadata such as
   * created_at is preserved for audit/tracing. Account approval and escalation
   * are handled separately via onboarding tables and admin processes. The
   * response body type follows authenticated convention, issuing
   * IAiCommerceSeller.IAuthorized, which includes JWT tokens for the session.
   *
   * Security includes validation of unique email, secure password storage, and
   * marking created accounts as pending approval. This registration does not
   * auto-approve; manual or automated compliance review is required thereafter.
   * The join operation is essential for enabling the seller onboarding
   * lifecycle, and error handling is aligned with schema constraints and
   * business guidelines.
   *
   * Related operations for login and refresh use the same authentication data
   * model. No soft delete is performed at registration. This is the only
   * allowed public endpoint for creating a new seller role; member and admin
   * roles do not use this path.
   *
   * @param connection
   * @param body Seller registration information (email, password, optional
   *   onboarding/kyc fields).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IAiCommerceSeller.IJoin,
  ): Promise<IAiCommerceSeller.IAuthorized> {
    try {
      return await postauthSellerJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate seller, issuing new JWT tokens (ai_commerce_seller,
   * ai_commerce_buyer).
   *
   * Authenticated login endpoint for sellers. Validates email and password
   * credentials against the ai_commerce_buyer (username/email) and
   * ai_commerce_seller (buyer_id linkage, status). Password is hashed and
   * compared to the stored password_hash field per schema, and only active
   * sellers are granted access.
   *
   * Security: Suspended/terminated sellers (status field) are denied login, and
   * audit logs should be triggered per ai_commerce_audit_logs_user. On
   * successful authentication, signed tokens are issued in the
   * IAiCommerceSeller.IAuthorized structure.
   *
   * Role specificity: This login endpoint only authenticates sellers and is not
   * available for buyers or admins. Error cases (invalid credentials, wrong
   * status) are fully aligned with schema rules and fields.
   *
   * The endpoint is the main path for session-based authentication of sellers,
   * fit for web/mobile SDKs, and requires no pre-execution of a join endpoint
   * if the account already exists.
   *
   * Error handling: Invalid email/password or account status (not active)
   * returns a clear error with no sensitive information.
   *
   * @param connection
   * @param body Seller login credentials (email, password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IAiCommerceSeller.ILogin,
  ): Promise<IAiCommerceSeller.IAuthorized> {
    try {
      return await postauthSellerLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for valid seller session (ai_commerce_seller,
   * ai_commerce_buyer).
   *
   * Token refresh endpoint for sellers. This operation accepts a valid refresh
   * token tied to an active seller account (ai_commerce_seller, via buyer_id
   * linkage). Upon validating token authenticity and session (referencing
   * ai_commerce_user_authentications, ai_commerce_buyer, and ai_commerce_seller
   * tables), new JWT access/refresh tokens are issued as
   * IAiCommerceSeller.IAuthorized. No account approval/escalation is performed
   * by this route.
   *
   * Security and status constraints: If a seller account is suspended or
   * deleted (per status field in ai_commerce_seller), token refresh is denied.
   * Audit logs for session/token refresh (ai_commerce_audit_logs_user) are
   * triggered as per backend compliance expectations. No request body fields
   * are neededâ€”the token is extracted from the HTTP headers.
   *
   * This operation is required for maintaining long-lived sessions and mobile
   * SDK flows for seller accounts. Related endpoints (login, join) are
   * prerequisite depending on acquisition flow, but are not called by this
   * endpoint.
   *
   * @param connection
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(): Promise<IAiCommerceSeller.IAuthorized> {
    try {
      return await postauthSellerRefresh();
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
