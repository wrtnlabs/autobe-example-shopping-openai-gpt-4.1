import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallSellerProductsProductIdVariants } from "../../../../../providers/postShoppingMallSellerProductsProductIdVariants";
import { SellerAuth } from "../../../../../decorators/SellerAuth";
import { SellerPayload } from "../../../../../decorators/payload/SellerPayload";
import { patchShoppingMallSellerProductsProductIdVariants } from "../../../../../providers/patchShoppingMallSellerProductsProductIdVariants";
import { getShoppingMallSellerProductsProductIdVariantsVariantId } from "../../../../../providers/getShoppingMallSellerProductsProductIdVariantsVariantId";
import { putShoppingMallSellerProductsProductIdVariantsVariantId } from "../../../../../providers/putShoppingMallSellerProductsProductIdVariantsVariantId";
import { deleteShoppingMallSellerProductsProductIdVariantsVariantId } from "../../../../../providers/deleteShoppingMallSellerProductsProductIdVariantsVariantId";

import { IShoppingMallProductVariant } from "../../../../../api/structures/IShoppingMallProductVariant";
import { IPageIShoppingMallProductVariant } from "../../../../../api/structures/IPageIShoppingMallProductVariant";

@Controller("/shoppingMall/seller/products/:productId/variants")
export class ShoppingmallSellerProductsVariantsController {
  /**
   * Create a product variant (SKU) under an existing product in
   * shopping_mall_product_variants.
   *
   * Creates a product variant (SKU) as a child resource of a specific product.
   * Required fields include sku_code (unique), option_values_hash
   * (system-generated or client-calculated), price, stock_quantity, and weight.
   * This endpoint is only available to authenticated sellers who own the parent
   * product or to admins with global privileges. On success, a new variant is
   * added; on business rule violation (e.g., duplicate SKU code, illegal option
   * combination), a detailed validation error is returned.
   *
   * Security and permissions are enforced to restrict this operation to the
   * product's owner/seller or platform admins. All input values are sanitized,
   * and the combination of option values is checked for uniqueness and
   * consistency. Referential foreign keys (productId) are validated against the
   * shopping_mall_products table.
   *
   * Error handling includes clear feedback for SKU collisions, input constraint
   * violations (e.g., negative stock, invalid price), and business logic errors
   * (e.g., parent product is deleted or paused). Upon successful creation, the
   * response includes the full new variant entity as defined in the
   * ShoppingMallProductVariant schema.
   *
   * @param connection
   * @param productId Parent product's unique identifier (UUID) for which to
   *   create the variant.
   * @param body Product variant creation details (SKU, option values hash,
   *   price, stock, etc.). Follows IShoppingMallProductVariant.ICreate type.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductVariant.ICreate,
  ): Promise<IShoppingMallProductVariant> {
    try {
      return await postShoppingMallSellerProductsProductIdVariants({
        seller,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and fetch a paginated list of product variants for a given product.
   *
   * The operation retrieves a filtered, paginated list of all variants
   * belonging to a specific parent product. The filtering/search criteria are
   * submitted in the request body (e.g., SKU code, stock, price filtering) and
   * the result is a page of variant summaries for administrative, seller, or
   * catalog use. Results can be sorted by attributes like created_at, price, or
   * stock_quantity.
   *
   * The operation uses the shopping_mall_product_variants Prisma schema table,
   * with strict referential validation: only variants for the provided
   * productId are queryable. It enforces that only authorized sellers (owners
   * of the product) or platform admins can access the data for that product.
   * Requests without proper credentials or product ownership return
   * authorization errors.
   *
   * Pagination metadata (total count, next/prev page, etc.) is included in the
   * response, as are only fields present in the .ISummary DTO and defined in
   * the underlying schema.
   *
   * @param connection
   * @param productId Unique identifier for the parent product whose variants
   *   are being listed.
   * @param body Search, filter, and pagination criteria for product variants.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductVariant.IRequest,
  ): Promise<IPageIShoppingMallProductVariant.ISummary> {
    try {
      return await patchShoppingMallSellerProductsProductIdVariants({
        seller,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detail for a specific variant of a product from the
   * shopping_mall_product_variants table.
   *
   * This operation allows authorized sellers or admins to look up a single
   * variant under a specific product, ensuring precise identification and
   * security. It references the shopping_mall_product_variants Prisma schema
   * table, confirming both the variantId and its association with productId
   * before fetching the variant details. The response includes fields such as
   * SKU code, price, stock_quantity, and the determined set of option values.
   *
   * Authorization ensures that only the seller who owns the product or a
   * platform admin can view variant details. Detailed error messaging is
   * returned for absent or mismatched product/variant identifiers, or when
   * permission is denied. The endpoint does not expose any business-internal or
   * unrelated product variant data.
   *
   * Related operations include listing variants, updating variant data, or
   * managing inventory/stock directly tied to variant entries. Every variant
   * entity returned is compliant with the attributes as defined by the schema.
   *
   * @param connection
   * @param productId Unique identifier for the parent product.
   * @param variantId Unique identifier for the product variant being retrieved.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":variantId")
  public async at(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("variantId")
    variantId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallProductVariant> {
    try {
      return await getShoppingMallSellerProductsProductIdVariantsVariantId({
        seller,
        productId,
        variantId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a product variant (SKU) for a specific product in
   * shopping_mall_product_variants.
   *
   * Updates a SKU/variant for an existing product. Only accessible to the
   * product's owning seller or admins. Updates may affect SKU code, price,
   * stock, bar code, or option values, with full validation against
   * product-level constraints and invariant checks such as uniqueness.
   *
   * This operation references the corresponding product and enforces
   * authorization based on seller ownership or admin role. Attempting to update
   * a SKU with a duplicate code or invalid option values will result in a
   * validation error. Foreign key checks, data type validations, and all
   * business logic defined in the shopping_mall_product_variants schema are
   * strictly enforced. Partial (PUT-style) or full updates should be supported
   * depending on DTO implementation.
   *
   * On success, the updated variant entity is returned. Errors include not
   * found, unauthorized, invalid input, collision, or business rule violations.
   * All update events are recorded for audit/history.
   *
   * @param connection
   * @param productId Identifier of the parent product
   * @param variantId Unique identifier of the variant to update (UUID)
   * @param body Product variant update data according to
   *   IShoppingMallProductVariant.IUpdate DTO.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":variantId")
  public async update(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("variantId")
    variantId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductVariant.IUpdate,
  ): Promise<IShoppingMallProductVariant> {
    try {
      return await putShoppingMallSellerProductsProductIdVariantsVariantId({
        seller,
        productId,
        variantId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft delete (logical removal) of a product variant (SKU) via deleted_at in
   * shopping_mall_product_variants.
   *
   * Deletes (soft-removes) a product variant (SKU) for a specific product,
   * marking it as deleted by setting deleted_at instead of physically removing
   * the record. Only the product owner (seller) or admin can perform this
   * operation. The operation ensures that SKUs linked to past or current order
   * items, or required by product inventory audits, are never physically
   * removed for compliance reasons.
   *
   * This operation is strictly checked for business rule and permission
   * compliance. Audit trails are generated for all deletions (soft). If the
   * variant does not exist, does not belong to the seller, or is already
   * deleted, appropriate error responses are returned. The parent productId is
   * used to scope the deletion.
   *
   * The response confirms deletion (soft delete, setting deleted_at) without
   * returning the deleted entity, ensuring regulatory compliance and
   * traceability.
   *
   * @param connection
   * @param productId Parent product's unique identifier (UUID) for scoping the
   *   variant
   * @param variantId Identifier of the product variant to delete (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":variantId")
  public async erase(
    @SellerAuth()
    seller: SellerPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("variantId")
    variantId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallSellerProductsProductIdVariantsVariantId({
        seller,
        productId,
        variantId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
