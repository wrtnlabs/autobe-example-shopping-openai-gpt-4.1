import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerMileagesMileageIdTransactions } from "../../../../../providers/postShoppingMallCustomerMileagesMileageIdTransactions";
import { CustomerAuth } from "../../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerMileagesMileageIdTransactions } from "../../../../../providers/patchShoppingMallCustomerMileagesMileageIdTransactions";
import { getShoppingMallCustomerMileagesMileageIdTransactionsTransactionId } from "../../../../../providers/getShoppingMallCustomerMileagesMileageIdTransactionsTransactionId";

import { IShoppingMallMileageTransaction } from "../../../../../api/structures/IShoppingMallMileageTransaction";
import { IPageIShoppingMallMileageTransaction } from "../../../../../api/structures/IPageIShoppingMallMileageTransaction";

@Controller("/shoppingMall/customer/mileages/:mileageId/transactions")
export class ShoppingmallCustomerMileagesTransactionsController {
  /**
   * Create a new mileage transaction for a given mileage account
   * (shopping_mall_mileages).
   *
   * Create a new transaction for an existing mileage account
   * (shopping_mall_mileages) belonging to a customer. This API writes a row in
   * shopping_mall_mileage_transactions and is used when users accrue, spend,
   * receive bonuses, or have miles expire. The API validates sufficient balance
   * for spending/expiration, enforces constraints for transaction type (e.g.,
   * no accrual for frozen accounts), and records the business reason (campaign,
   * purchase, refund, manual, etc.). The action is fully auditable, with a new
   * transaction created for every mutation, never overwriting previous
   * transactions. If the operation is successful, updated mileage and a
   * reference to the transaction are returned. The API enforces role-based
   * permissions: only the account owner or an admin may create a transaction,
   * and audit logs are generated for compliance. Edge cases, such as attempts
   * to spend more than the available balance, are rejected with descriptive
   * errors. Related APIs include PUT for transaction update and DELETE for
   * transaction cancellation/reversal. All values respect regulatory and
   * promotional rules linked to the account type.
   *
   * @param connection
   * @param mileageId The unique identifier of the target mileage account for
   *   which the transaction is being created.
   * @param body Payload describing the type, amount, business context, and
   *   reference IDs for the new mileage transaction. Follows the
   *   IShoppingMallMileageTransaction.ICreate DTO specification.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallMileageTransaction.ICreate,
  ): Promise<IShoppingMallMileageTransaction> {
    try {
      return await postShoppingMallCustomerMileagesMileageIdTransactions({
        customer,
        mileageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and filter all transactions for a specific mileage (loyalty/point)
   * account using shopping_mall_mileage_transactions table.
   *
   * Retrieve the full or filtered transaction history for a given mileage
   * account (UUID), as recorded in the shopping_mall_mileage_transactions
   * table. This includes accrual, redemption, expiry, adjustments, and
   * donation/bonus transactions, all tied to the mileage account as per the
   * schema.
   *
   * The operation supports complex filtering (e.g., transaction type, status,
   * date ranges), sorting (by date or amount), and standard pagination
   * (page/size parameters) to allow users or administrators to browse both
   * recent and historic transactions. Security and authorization ensure only
   * account owners or authorized admins may view the data, which may contain
   * sensitive financial or loyalty information.
   *
   * Business logic in this operation enforces strict visibility: customers can
   * only see their own mileage transactions, while admins may access broader
   * histories for support, audit, or compliance. Transactions are immutable and
   * provide evidence-grade history for audit trails, dispute resolution, or
   * bonus calculation. All responses comply with data privacy and retention
   * rules.
   *
   * @param connection
   * @param mileageId UUID of the mileage account for which transactions are
   *   listed.
   * @param body Filtering, pagination, and sorting criteria for listing mileage
   *   transactions.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallMileageTransaction.IRequest,
  ): Promise<IPageIShoppingMallMileageTransaction> {
    try {
      return await patchShoppingMallCustomerMileagesMileageIdTransactions({
        customer,
        mileageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed information for a single mileage transaction record from
   * shopping_mall_mileage_transactions table.
   *
   * Get the complete details of a single mileage (loyalty/point) transaction
   * for a specific mileage account, using both the account UUID and transaction
   * UUID. The operation pulls from the shopping_mall_mileage_transactions table
   * and ensures that access is restricted to only account owners or authorized
   * administrators.
   *
   * Business rules strictly enforce that a user cannot access transactions
   * outside their own account, while administrators can retrieve any
   * transaction for support/audit. Standard validation is applied to confirm
   * both IDs are valid and related. This endpoint is useful for customers
   * reviewing their point activity or for support/finance resolving disputes.
   *
   * Information returned includes the full transaction record: transaction type
   * (accrual, spend, adjustment, etc.), amount, status, timestamps, business
   * reason, evidence_reference, and any related order. All access is logged for
   * privacy and compliance.
   *
   * @param connection
   * @param mileageId UUID of the parent mileage account.
   * @param transactionId UUID of the specific transaction to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":transactionId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallMileageTransaction> {
    try {
      return await getShoppingMallCustomerMileagesMileageIdTransactionsTransactionId(
        {
          customer,
          mileageId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
