import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerFavoriteInquiries } from "../../../../providers/postShoppingMallCustomerFavoriteInquiries";
import { CustomerAuth } from "../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerFavoriteInquiries } from "../../../../providers/patchShoppingMallCustomerFavoriteInquiries";
import { getShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId } from "../../../../providers/getShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId";
import { putShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId } from "../../../../providers/putShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId";
import { deleteShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId } from "../../../../providers/deleteShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId";

import { IShoppingMallFavoriteInquiry } from "../../../../api/structures/IShoppingMallFavoriteInquiry";
import { IPageIShoppingMallFavoriteInquiry } from "../../../../api/structures/IPageIShoppingMallFavoriteInquiry";

@Controller("/shoppingMall/customer/favoriteInquiries")
export class ShoppingmallCustomerFavoriteinquiriesController {
  /**
   * Mark a product inquiry as a favorite for the user and store its snapshot.
   *
   * This operation allows users to favorite a specific product inquiry, linking
   * it to their favorites list with a preserved, immutable snapshot for audit
   * and evidence purposes. The user provides the inquiry to favorite,
   * notification preference, and any optional organizational label. The system
   * verifies entity validity, ownership/visibility rules (e.g., cannot favorite
   * another user's private inquiry), and prevents duplicate favorites for the
   * same inquiry by the same user.
   *
   * Upon successful creation, a shopping_mall_favorite_inquiries record is
   * written, referencing the immutable snapshot in
   * shopping_mall_favorite_snapshots. Notification settings and user-supplied
   * labels/tags are included. Re-favoriting after delete triggers a new
   * snapshot and favorite record.
   *
   * Business rules include respecting soft deletion (inquiries/favorites),
   * audit trail enforcement, and strict permission checks: only the owner of
   * the favorite can create or manage these records. Admins may perform
   * override operations for audit via separate admin API if needed.
   *
   * @param connection
   * @param body Data required to mark a product inquiry as a favorite (inquiry
   *   reference, notification settings, optional label).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.ICreate,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await postShoppingMallCustomerFavoriteInquiries({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a paginated list of favorite product inquiries for the
   * user.
   *
   * This operation enables a user to search and retrieve a list of their
   * favorited product inquiries within the shopping mall platform. The request
   * supports advanced search filters, including inquiry/product reference,
   * notification preference, tagging/label, and date ranges, allowing flexible
   * organization of favorites for personalization and notification management.
   *
   * It references the shopping_mall_favorite_inquiries entity, which links the
   * user (customer) to inquiry and immutable snapshot
   * (shopping_mall_favorite_snapshots), ensuring all evidence is preserved for
   * compliance and audit. The response structure includes essential details for
   * display, batch management (e.g., organize/remove), and notification
   * triggers.
   *
   * Security is enforced so only the authenticated user can access their own
   * favorite inquiries. Admins performing audit queries must use separate admin
   * endpoints according to business policy. The endpoint supports pagination,
   * configurable page size, and sorting by created date or custom batch label,
   * ensuring optimal UX and efficient querying for large favorite lists.
   *
   * @param connection
   * @param body Search filters, pagination, sorting, and batch labeling
   *   parameters for favorite inquiry listing.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.IRequest,
  ): Promise<IPageIShoppingMallFavoriteInquiry> {
    try {
      return await patchShoppingMallCustomerFavoriteInquiries({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve the details of a specific favorite product inquiry by ID for the
   * user.
   *
   * This operation fetches detailed information for a single favorite inquiry
   * record, identified by favoriteInquiryId, scoped to the current
   * authenticated customer. It provides the associated inquiry, the snapshot
   * captured during favoriting, product references, notification status, and
   * any custom labels/tags added by the user.
   *
   * The endpoint strictly enforces user-level access: users can only view their
   * own favorite inquiries. Attempting to access another user's favorite
   * inquiry will result in a security error. Error handling includes not found
   * (404) for invalid IDs or deleted/nonexistent favorites, and forbidden (403)
   * for cross-user access Attempts.
   *
   * Data returned is derived from shopping_mall_favorite_inquiries and its
   * linked inquiry and product snapshot in shopping_mall_favorite_snapshots,
   * preserving compliance and personalization logic.
   *
   * @param connection
   * @param favoriteInquiryId Unique identifier of the favorite inquiry to
   *   retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":favoriteInquiryId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await getShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId({
        customer,
        favoriteInquiryId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update notification or label settings for a specific favorite inquiry by
   * ID.
   *
   * This operation enables users to modify notification preferences and
   * batch-organizational information (e.g., label/tag) for one of their
   * favorite inquiries. Access is granted only if the favoriteInquiryId belongs
   * to the current authenticated user; cross-user modification is strictly
   * forbidden and enforced with 403 errors.
   *
   * The endpoint touches only metadata (notification_enabled, batch_label),
   * never altering the linked snapshot or underlying inquiry. Error handling
   * includes validation on favoriteInquiryId (must exist and not be deleted),
   * and only allows update if the favorite is active and owned by the
   * requesting user. All changes are logged for audit and compliance.
   *
   * Data modified is persisted in shopping_mall_favorite_inquiries, following
   * business logic and compliance requirements. System generates appropriate
   * audit trail for every change per evidence-grade requirements.
   *
   * @param connection
   * @param favoriteInquiryId Unique identifier for the favorite inquiry to
   *   update.
   * @param body Fields to update for the favorite inquiry (notification or
   *   label/organization info).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":favoriteInquiryId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallFavoriteInquiry.IUpdate,
  ): Promise<IShoppingMallFavoriteInquiry> {
    try {
      return await putShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId({
        customer,
        favoriteInquiryId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft delete a favorited inquiry by ID in shopping_mall_favorite_inquiries
   * (Favorites module).
   *
   * This endpoint enables a customer to unfavorite a previously favorited
   * product inquiry. Instead of physically deleting the favorite record, it
   * performs a soft deletion by setting the deleted_at timestamp, preserving
   * the full snapshot history of the associated inquiry for audit, compliance,
   * and potential future dispute resolution.
   *
   * Role-based security is enforced: customers can remove their own favorite
   * inquiries, while platform administrators can remove any for regulatory or
   * support purposes. The endpoint does not require a request body.
   *
   * Business logic will ensure that upon unfavoriting, any active notifications
   * linked to this favorite are unsubscribed. The deletion is audit-logged, and
   * the action can be viewed in the user's favorite inquiry management
   * interface.
   *
   * Error handling includes: 404 for nonexistent or already deleted
   * favoriteInquiryId, 403 if requesting actor lacks proper ownership/access,
   * and audit trail creation for successful and failed attempts.
   *
   * @param connection
   * @param favoriteInquiryId ID of the favorited inquiry to be removed
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":favoriteInquiryId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteInquiryId")
    favoriteInquiryId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallCustomerFavoriteInquiriesFavoriteInquiryId(
        {
          customer,
          favoriteInquiryId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
