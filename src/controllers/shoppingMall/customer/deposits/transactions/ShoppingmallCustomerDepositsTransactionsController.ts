import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerDepositsDepositIdTransactions } from "../../../../../providers/postShoppingMallCustomerDepositsDepositIdTransactions";
import { CustomerAuth } from "../../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerDepositsDepositIdTransactions } from "../../../../../providers/patchShoppingMallCustomerDepositsDepositIdTransactions";
import { getShoppingMallCustomerDepositsDepositIdTransactionsTransactionId } from "../../../../../providers/getShoppingMallCustomerDepositsDepositIdTransactionsTransactionId";
import { putShoppingMallCustomerDepositsDepositIdTransactionsTransactionId } from "../../../../../providers/putShoppingMallCustomerDepositsDepositIdTransactionsTransactionId";

import { IShoppingMallDepositTransaction } from "../../../../../api/structures/IShoppingMallDepositTransaction";
import { IPageIShoppingMallDepositTransaction } from "../../../../../api/structures/IPageIShoppingMallDepositTransaction";

@Controller("/shoppingMall/customer/deposits/:depositId/transactions")
export class ShoppingmallCustomerDepositsTransactionsController {
  /**
   * Create/deposit a new transaction record for a digital wallet
   * (IShoppingMallDepositTransaction).
   *
   * Create a new transaction for a specific user's digital deposit account. The
   * request payload determines the transaction type (income, outcome, refund,
   * admin_adjustment, etc.), amount, business status, and any linked references
   * (such as orders or audit events). Upon creation, the operation enforces
   * business rule validation—including non-negative balances, valid status
   * transitions, and fraud/risk heuristics—and updates the target deposit's
   * balance accordingly.
   *
   * All creation events are appended to the deposit's audit log and may trigger
   * compliance or risk scoring. This operation supports customer-initiated
   * activity (manual top-up, refund, spending) as well as admin-initiated
   * adjustments (freezing, deductions, fraud response). Strong access control
   * ensures only the deposit owner (for personal use) or authorized admins (for
   * adjustments/mitigation) can create new records. Upon success, the fully
   * detailed transaction DTO is returned, including the updated status and
   * linkage metadata.
   *
   * @param connection
   * @param depositId ID of the target deposit account the new transaction will
   *   be applied to.
   * @param body Complete information required to create a new deposit
   *   transaction—type, amount, status, references, evidence, and reason.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.ICreate,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await postShoppingMallCustomerDepositsDepositIdTransactions({
        customer,
        depositId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List/filter all transactions in a specific deposit account
   * (IShoppingMallDepositTransaction).
   *
   * Retrieve all transactions belonging to a specific user's digital deposit
   * account, as referenced by the depositId path parameter. The operation
   * supports complex querying options—such as searching by transaction type,
   * business status, order reference, or time window—to provide comprehensive
   * visibility over deposit activity. This multi-role endpoint requires
   * authentication as the customer owner or an administrator with audit
   * permissions.
   *
   * Returned results can be filtered and paginated to handle large account
   * histories efficiently. All records returned are compliant with the
   * regulatory requirement for evidentiary reporting. Responses exclude
   * logically deleted transactions by default, but the schema supports soft
   * deletion for compliance/audit purposes. This operation directly references
   * 'shopping_mall_deposit_transactions' and returns paged data using the
   * appropriate DTO.
   *
   * Security and role validation are critical—customers may access only their
   * own deposit account transactions, while administrators can access all.
   * Rate-limiting and access logging should be applied due to the sensitivity
   * of financial data.
   *
   * @param connection
   * @param depositId ID of the target deposit account for which transactions
   *   will be listed.
   * @param body Filter and pagination parameters for the deposit account
   *   transaction query. May include type, business_status, order reference,
   *   date range, or amount range.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.IRequest,
  ): Promise<IPageIShoppingMallDepositTransaction> {
    try {
      return await patchShoppingMallCustomerDepositsDepositIdTransactions({
        customer,
        depositId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a specific deposit transaction by transactionId
   * (IShoppingMallDepositTransaction).
   *
   * Retrieve full information for a specific digital deposit transaction, using
   * both the depositId and transactionId as identifiers. This operation returns
   * all relevant metadata; such as transaction type, order or evidence linkage,
   * business status, amount, reversal history, and audit reference. This is
   * essential for supporting customer queries, handling financial disputes,
   * enabling refund workflows, and investigating suspected fraud or risk
   * cases.
   *
   * The operation strictly enforces access control: only the deposit account
   * owner or system administrators may access individual transaction details
   * for privacy and security reasons. Every access is logged for an audit
   * trail. Data is returned as a fully detailed DTO, with all soft deletion or
   * reversal metadata included as required.
   *
   * @param connection
   * @param depositId ID of the parent deposit account (for cross-verification
   *   and access control).
   * @param transactionId Unique identifier for the deposit transaction to
   *   retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":transactionId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await getShoppingMallCustomerDepositsDepositIdTransactionsTransactionId(
        {
          customer,
          depositId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific transaction for a deposit account
   * (IShoppingMallDepositTransaction).
   *
   * Modify a specific transaction within a digital deposit account, as
   * referenced by depositId and transactionId. Permitted updates include status
   * advancement, fraud/risk flagging, reversal/adjustment actions, and
   * administrative explanations. Strict validation enforces eligible
   * transitions, ensuring core financial invariants are respected (e.g., no
   * negative post-factum balances, evidentiary snapshots on reversal). All
   * updates generate audit events detailing before/after state, actor, and
   * reason for change.
   *
   * While admins can perform more extensive updates (status, fraud marking,
   * correction), users are limited to allowed fields per business rules and
   * only for their own account transactions. Every operation is logged for
   * regulatory/audit compliance, and errors on improper updates are surfaced
   * with actionable messages. Responses return the fully revised transaction
   * DTO upon success.
   *
   * @param connection
   * @param depositId ID of the deposit account parent. Required for access
   *   control and context.
   * @param transactionId ID of the transaction to update.
   * @param body Fields to update for the specified deposit transaction—e.g.,
   *   business_status, reversal info, fraud markers, etc.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":transactionId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.IUpdate,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await putShoppingMallCustomerDepositsDepositIdTransactionsTransactionId(
        {
          customer,
          depositId,
          transactionId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
