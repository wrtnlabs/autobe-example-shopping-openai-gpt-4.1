import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerDonations } from "../../../../providers/postShoppingMallCustomerDonations";
import { CustomerAuth } from "../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerDonations } from "../../../../providers/patchShoppingMallCustomerDonations";
import { getShoppingMallCustomerDonationsDonationId } from "../../../../providers/getShoppingMallCustomerDonationsDonationId";
import { deleteShoppingMallCustomerDonationsDonationId } from "../../../../providers/deleteShoppingMallCustomerDonationsDonationId";

import { IShoppingMallDonation } from "../../../../api/structures/IShoppingMallDonation";
import { IPageIShoppingMallDonation } from "../../../../api/structures/IPageIShoppingMallDonation";

@Controller("/shoppingMall/customer/donations")
export class ShoppingmallCustomerDonationsController {
  /**
   * Create a new donation (deposit or mileage) to a specified campaign,
   * enforcing validation and audit trail.
   *
   * This operation enables a customer to initiate a new donation using either
   * their deposit balance or mileage points towards a specified campaign. Upon
   * receiving a valid request, the system will validate the donor’s current
   * balance, ensure donation limits or campaign constraints are respected, and
   * record all relevant metadata in the shopping_mall_donations table. Donation
   * creation includes specifying the donation source (deposit or mileage),
   * source account, donation target campaign code, and the intended donation
   * amount.
   *
   * Security and compliance checks are enforced. Only authenticated customers
   * may use this endpoint, and they may only donate from balances belonging to
   * their own account. Business logic validates availability of funds, campaign
   * eligibility, anti-fraud, and that the target campaign code is active if
   * business policies require. On success, the donation is recorded and can be
   * traced for dashboard, historical, or investigative purposes. Errors include
   * insufficient balance, invalid campaign, or fraud detection triggers.
   * Administrative operations for reviewing or analyzing donations are provided
   * separately.
   *
   * @param connection
   * @param body Donation details: source (deposit or mileage), source account,
   *   target campaign, and amount.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallDonation.ICreate,
  ): Promise<IShoppingMallDonation> {
    try {
      return await postShoppingMallCustomerDonations({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a paginated, filtered list of donation records.
   *
   * Retrieve a filtered, paginated list of donation records from the
   * shopping_mall_donations table. This operation allows both users and
   * administrators to view donation transactions based on various criteria,
   * including customer identity, donation source type (deposit or mileage),
   * campaign code, and status. Pagination parameters ensure efficient
   * navigation through potentially large result sets. Administrators can view
   * system-wide or filtered analytics; customers can view their personal
   * donation history. Search parameters may include time range, amount range,
   * campaign, and transaction status. The operation ensures sensitive
   * information is properly masked for non-admin users, and permission checks
   * prevent cross-user data access. The response contains a paginated summary
   * of donation transactions and relevant statistics.
   *
   * @param connection
   * @param body Search and pagination parameters for donation filtering,
   *   defined by IShoppingMallDonation.IRequest. Supports filtering by
   *   customer, campaign code, amount, date range, and status.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallDonation.IRequest,
  ): Promise<IPageIShoppingMallDonation.ISummary> {
    try {
      return await patchShoppingMallCustomerDonations({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get details of a specific donation by its UUID from the
   * shopping_mall_donations table.
   *
   * This operation retrieves a detailed donation record for a given donation
   * identified by its unique UUID in the shopping_mall_donations table. The
   * donation record includes the donating customer, source type (deposit or
   * mileage), related campaign/event code, transferred amount, donation status
   * (pending, confirmed, failed, refunded, etc.), and full timestamp/audit
   * metadata.
   *
   * The endpoint is designed for auditability—enabling compliant review of
   * donation evidence, transparency for analytics, and support for legal
   * inquiries. Only authorized users may access donation records. Customers may
   * request their own information; administrators can access records for
   * compliance, fraud tracking, or dispute resolution.
   *
   * Validation enforces that donationId matches an extant record and that
   * access controls are respected. Errors may occur if the donation is missing,
   * deleted, or if the caller lacks permission. Related endpoints include
   * donation creation, update, and logical deletion.
   *
   * @param connection
   * @param donationId The unique identifier (UUID) of the donation to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":donationId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("donationId")
    donationId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallDonation> {
    try {
      return await getShoppingMallCustomerDonationsDonationId({
        customer,
        donationId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically delete (soft remove) a donation by its UUID, retaining data for
   * evidence and compliance.
   *
   * This operation performs logical deletion (soft delete) of the specified
   * donation, referenced by donationId. Rather than removing the record from
   * the database, it sets the deleted_at timestamp to guarantee regulatory
   * evidence retention, auditability, and rollback capabilities. The deletion
   * is only permitted if the donation is not in a finalized or protected state
   * (e.g., after refund/settlement for certain jurisdictions per business
   * logic), and enforces authorization so only the owner or an admin may remove
   * the record.
   *
   * This operation complies with data governance requirements,
   * snapshot/evidence retention policies, and ensures consistency with the
   * system’s commitment to non-destructive removal. Attempting to delete a
   * protected, non-existent, or unauthorized donation results in a clear error,
   * with all actions logged for compliance. Use corresponding endpoints for
   * read/recovery as needed.
   *
   * @param connection
   * @param donationId The UUID of the donation to logically delete (soft
   *   remove).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":donationId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("donationId")
    donationId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallCustomerDonationsDonationId({
        customer,
        donationId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
