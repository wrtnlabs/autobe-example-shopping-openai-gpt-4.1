import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallCustomerFavoriteProducts } from "../../../../providers/postShoppingMallCustomerFavoriteProducts";
import { CustomerAuth } from "../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../decorators/payload/CustomerPayload";
import { patchShoppingMallCustomerFavoriteProducts } from "../../../../providers/patchShoppingMallCustomerFavoriteProducts";
import { getShoppingMallCustomerFavoriteProductsFavoriteProductId } from "../../../../providers/getShoppingMallCustomerFavoriteProductsFavoriteProductId";
import { putShoppingMallCustomerFavoriteProductsFavoriteProductId } from "../../../../providers/putShoppingMallCustomerFavoriteProductsFavoriteProductId";
import { deleteShoppingMallCustomerFavoriteProductsFavoriteProductId } from "../../../../providers/deleteShoppingMallCustomerFavoriteProductsFavoriteProductId";

import { IShoppingMallFavoriteProduct } from "../../../../api/structures/IShoppingMallFavoriteProduct";
import { IPageIShoppingMallFavoriteProduct } from "../../../../api/structures/IPageIShoppingMallFavoriteProduct";

@Controller("/shoppingMall/customer/favoriteProducts")
export class ShoppingmallCustomerFavoriteproductsController {
  /**
   * Create a new favorite product entry for the authenticated customer
   * (shopping_mall_favorite_products).
   *
   * Customers use this endpoint to mark a product as a favorite. Favoriting a
   * product not only records the customer-product association but also snaps a
   * historical record of the product's business state at the time of
   * favoriting, supporting downstream AI-driven personalization and audit
   * requirements.
   *
   * Permission checks ensure only authenticated customers can perform this
   * action on their own behalf. Attempting to favorite a product that is
   * already favorited returns a constrained error; attempts to favorite
   * non-existent or deleted products also fail with explicit validation errors.
   * The business logic validates the presence of the product and available
   * snapshot. Creation triggers personalized notification enablers if requested
   * by the user. All records preserve compliance with evidence retention rules
   * and are never physically deleted.
   *
   * Any operation error (constraint violations, missing fields, unauthorized)
   * returns well-formed error codes and reason messages in the response.
   *
   * This API is tightly linked to shopping_mall_favorite_products (the main
   * favorite record), shopping_mall_products (target entity), and
   * shopping_mall_customers (acting user identity) in the schema. The request
   * and response DTOs are versioned with the service prefix for future
   * extensibility.
   *
   * @param connection
   * @param body Details for the favorite product, including product and
   *   snapshot identifiers, notification preference, and batch organization
   *   label.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallFavoriteProduct.ICreate,
  ): Promise<IShoppingMallFavoriteProduct> {
    try {
      return await postShoppingMallCustomerFavoriteProducts({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search, filter, and paginate a customer's favorited products
   * (shopping_mall_favorite_products table).
   *
   * This endpoint enables an authenticated customer to retrieve a paginated,
   * searchable, and sortable list of all products they have favorited. Results
   * may be filtered by organizational batch_label, notification_enabled status,
   * or creation/update timestamps. Each record includes the linked product
   * entity and the snapshot preserved at the moment of favoriting for audit and
   * evidence. This supports personalized list management, notification setting
   * review, and batch organizing actions.
   *
   * Security requires customer authentication; only the requesting user's
   * favorites are accessible unless an admin queries for support/audit
   * purposes. The endpoint supports pagination controls (page, limit), sorting
   * (by created date, name, favorite status), and advanced search for favorites
   * featuring localized or full product text. Error handling includes
   * permission denials for non-authenticated access and validation for
   * out-of-range pagination. This operation is fully auditable, supporting
   * rollback and compliance requests, and integrates with notification
   * preferences for downstream alerting.
   *
   * Paired operations include creating and deleting a favorite (POST/DELETE
   * /favoriteProducts/{favoriteProductId}), batch updates, and exporting
   * favorites for personalization or evidence export.
   *
   * @param connection
   * @param body Search and pagination filters for favorite products batch
   *   operations and organization.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallFavoriteProduct.IRequest,
  ): Promise<IPageIShoppingMallFavoriteProduct> {
    try {
      return await patchShoppingMallCustomerFavoriteProducts({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a detailed favorited product by ID
   * (shopping_mall_favorite_products table).
   *
   * This endpoint retrieves detailed information about a single product
   * favorited by a user, identified by favoriteProductId. The result includes
   * the full favorite record, all meta fields (such as notification_enabled and
   * batch_label), links to the preserved product snapshot, and the original
   * product entity, if present. Security is enforced so that only the
   * favoriting user may access their own favorite records; admin access is
   * granted for support or compliance audit. The result supports review for
   * personalization, notification settings, batch labels, and export or
   * evidence operations.
   *
   * Attempts to retrieve a favorite that does not exist, is deleted, or is not
   * owned by the user will return an error according to platform business
   * rules. The operation also integrates with downstream personalization,
   * notification, and snapshot export logic, and is part of the broader
   * user-facing favorites management suite.
   *
   * @param connection
   * @param favoriteProductId Unique identifier of the favorited product entry
   *   to retrieve
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":favoriteProductId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteProductId")
    favoriteProductId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallFavoriteProduct> {
    try {
      return await getShoppingMallCustomerFavoriteProductsFavoriteProductId({
        customer,
        favoriteProductId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update properties (such as notification preference or label) of a favorite
   * product for the current customer (shopping_mall_favorite_products).
   *
   * Authenticated customers may use this endpoint to update details of an
   * existing favorite product instance, such as enabling/disabling
   * notifications or adjusting the batch/organizational label assigned to the
   * favorite. The operation enforces ownership verification—the specified
   * favorite must exist and belong to the requesting user.
   *
   * Updates are limited to mutable fields like label/tags or notification
   * triggers; the association between the user and the product remains fixed.
   * All successful updates are timestamped for audit, with changes reflected in
   * future personalization and notification workflows. Attempting to update a
   * favorite not owned by the user, or one that does not exist or has been
   * deleted, leads to error responses with explicit reason codes.
   *
   * Linked schema entities for this operation are
   * shopping_mall_favorite_products, shopping_mall_customers, and
   * shopping_mall_products (via snapshot/favorite association). Security and
   * compliance constraints are strictly enforced.
   *
   * @param connection
   * @param favoriteProductId Unique identifier of the favorite product record
   *   to update.
   * @param body Fields to update in the favorite product, such as notification
   *   status or batch label.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":favoriteProductId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteProductId")
    favoriteProductId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallFavoriteProduct.IUpdate,
  ): Promise<IShoppingMallFavoriteProduct> {
    try {
      return await putShoppingMallCustomerFavoriteProductsFavoriteProductId({
        customer,
        favoriteProductId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft delete (mark as removed) a favorite product belonging to the current
   * customer (shopping_mall_favorite_products).
   *
   * Customers may use this endpoint to remove a product from their favorites.
   * The API enforces that customers can only delete their own favorite records,
   * not those of others. The deletion is soft—setting a deleted_at timestamp
   * and preserving the record for evidence retention, personalization audit,
   * and possible future recovery scenarios.
   *
   * Attempts to remove a favorite that does not exist, is already deleted, or
   * does not belong to the authenticated user will result in validation or
   * permission errors with explicit reason codes. All operations generate audit
   * records, ensuring compliance with legal and business requirements. There is
   * no response body; success is confirmed by standard HTTP status codes.
   *
   * Linked schema entities include shopping_mall_favorite_products (main
   * favorite record), shopping_mall_customers (user context), and
   * audit/snapshot tables for evidence chain.
   *
   * @param connection
   * @param favoriteProductId Unique identifier of the favorite product record
   *   to delete.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":favoriteProductId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteProductId")
    favoriteProductId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallCustomerFavoriteProductsFavoriteProductId({
        customer,
        favoriteProductId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
