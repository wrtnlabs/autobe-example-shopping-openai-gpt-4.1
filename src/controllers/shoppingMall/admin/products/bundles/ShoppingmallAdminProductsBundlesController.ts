import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminProductsProductIdBundles } from "../../../../../providers/postShoppingMallAdminProductsProductIdBundles";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminProductsProductIdBundles } from "../../../../../providers/patchShoppingMallAdminProductsProductIdBundles";
import { putShoppingMallAdminProductsProductIdBundlesBundleId } from "../../../../../providers/putShoppingMallAdminProductsProductIdBundlesBundleId";
import { deleteShoppingMallAdminProductsProductIdBundlesBundleId } from "../../../../../providers/deleteShoppingMallAdminProductsProductIdBundlesBundleId";

import { IShoppingMallProductBundle } from "../../../../../api/structures/IShoppingMallProductBundle";
import { IPageIShoppingMallProductBundle } from "../../../../../api/structures/IPageIShoppingMallProductBundle";

@Controller("/shoppingMall/admin/products/:productId/bundles")
export class ShoppingmallAdminProductsBundlesController {
  /**
   * Create a new product bundle for a given product
   * (shopping_mall_product_bundles table).
   *
   * This API operation allows authenticated sellers (or admins) to register a
   * new bundle under an existing product. It operates on the
   * shopping_mall_product_bundles table, creating a new record and linking it
   * to the specified product by productId.
   *
   * The request body must supply all mandatory fields such as bundle name, type
   * (fixed/optional), description (optionally), and the initial position/order
   * for display. It also enables definition of constituent bundle items, which
   * are subsequently managed via related endpoints.
   *
   * Role-based permission enforcement ensures only sellers with ownership of
   * the product, or administrators, are authorized to create bundles. Input
   * validation checks for duplicate bundle names for the same product, ensures
   * required fields are present, and that the parent product is in a valid
   * status for editing (e.g., not deleted or discontinued).
   *
   * On successful creation, the response returns the newly created bundle
   * object in full detail, as per the shopping_mall_product_bundles schema.
   * Related operations include updating bundles, removing bundles, and
   * adjusting bundle item composition.
   *
   * @param connection
   * @param productId ID of the product to which the new bundle will be attached
   *   (UUID, shopping_mall_products.id).
   * @param body Bundle creation schema including name, type, description,
   *   position, and initial composition information.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductBundle.ICreate,
  ): Promise<IShoppingMallProductBundle> {
    try {
      return await postShoppingMallAdminProductsProductIdBundles({
        admin,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve product bundles for a given product using advanced
   * query/pagination.
   *
   * Lists bundles associated with a single product, using productId as primary
   * filter. Supports filtering on bundle_type, name, status, and allows sorting
   * by display order or other attributes. Pagination options provide efficient
   * navigation of large bundle sets. Useful for both sellers (to manage
   * bundles) and admins (to audit or review product configurations).
   *
   * Only accessible to the owning seller or administrators. The operation
   * enforces permissions and validates that only bundles for the specified
   * product are returned. Errors include unauthorized access, product not
   * found, or invalid query parameters. The response includes only the bundles
   * relevant to the given productId, provided in paginated format for UI
   * efficiency.
   *
   * @param connection
   * @param productId Parent product identifier to filter bundles for
   * @param body Bundle listing/filter/search and pagination options as
   *   IShoppingMallProductBundle.IRequest DTO.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductBundle.IRequest,
  ): Promise<IPageIShoppingMallProductBundle> {
    try {
      return await patchShoppingMallAdminProductsProductIdBundles({
        admin,
        productId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update details/metadata for a given product's bundle
   * (shopping_mall_product_bundles table).
   *
   * This API operation modifies an existing bundle associated with a product,
   * identified by the productId and bundleId path parameters. It modifies the
   * corresponding row in the shopping_mall_product_bundles table, updating
   * fields like name, type, description, or bundle position as provided in the
   * request body.
   *
   * Only sellers who own the product or platform admins are authorized to
   * update bundles. Edit permissions are restricted based on business logic,
   * such as bundle status, the product's lifecycle state, and uniqueness
   * constraints for the bundle name within the product. If an attempt is made
   * to update a bundle under a discontinued or deleted product, or with
   * conflicting business rules, the update is rejected with a clear error
   * message.
   *
   * On successful update, the full product bundle information is returned in
   * the response, reflecting all changes. The operation works closely with
   * product bundle creation and deletion endpoints for managing the full bundle
   * lifecycle.
   *
   * @param connection
   * @param productId ID of the product to which the bundle belongs (UUID,
   *   shopping_mall_products.id).
   * @param bundleId Unique identifier of the product bundle (UUID,
   *   shopping_mall_product_bundles.id).
   * @param body Bundle update schema including updatable fields such as name,
   *   type, description, position, or composition.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":bundleId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("bundleId")
    bundleId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallProductBundle.IUpdate,
  ): Promise<IShoppingMallProductBundle> {
    try {
      return await putShoppingMallAdminProductsProductIdBundlesBundleId({
        admin,
        productId,
        bundleId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete (logically remove) a product bundle under a product
   * (shopping_mall_product_bundles table).
   *
   * This API operation performs a logical deletion (soft delete) of the
   * specified product bundle under a product. Leveraging the deleted_at
   * timestamp on the shopping_mall_product_bundles table, the operation marks
   * the bundle as deleted, maintaining full auditability for compliance and
   * recovery.
   *
   * Only the owning seller or administrative users are authorized to perform
   * this action. Business logic guarantees that a bundle may only be deleted
   * when the parent product is in a permissible state and the user has
   * appropriate permissions. Attempting to delete a bundle under a product not
   * owned by the user, or already marked as deleted/discontinued, results in a
   * business logic error.
   *
   * No response body is returned on success, but audit logs and bundle history
   * support compliance and rollback needs. This operation is closely connected
   * to bundle update and create endpoints, providing full lifecycle control
   * over product bundles.
   *
   * @param connection
   * @param productId ID of the product to which the bundle belongs (UUID,
   *   shopping_mall_products.id).
   * @param bundleId Unique identifier of the product bundle (UUID,
   *   shopping_mall_product_bundles.id).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":bundleId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("productId")
    productId: string & tags.Format<"uuid">,
    @TypedParam("bundleId")
    bundleId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminProductsProductIdBundlesBundleId({
        admin,
        productId,
        bundleId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
