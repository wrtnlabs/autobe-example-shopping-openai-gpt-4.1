import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminDepositsDepositIdTransactions } from "../../../../../providers/postShoppingMallAdminDepositsDepositIdTransactions";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminDepositsDepositIdTransactions } from "../../../../../providers/patchShoppingMallAdminDepositsDepositIdTransactions";
import { getShoppingMallAdminDepositsDepositIdTransactionsTransactionId } from "../../../../../providers/getShoppingMallAdminDepositsDepositIdTransactionsTransactionId";
import { putShoppingMallAdminDepositsDepositIdTransactionsTransactionId } from "../../../../../providers/putShoppingMallAdminDepositsDepositIdTransactionsTransactionId";
import { deleteShoppingMallAdminDepositsDepositIdTransactionsTransactionId } from "../../../../../providers/deleteShoppingMallAdminDepositsDepositIdTransactionsTransactionId";

import { IShoppingMallDepositTransaction } from "../../../../../api/structures/IShoppingMallDepositTransaction";
import { IPageIShoppingMallDepositTransaction } from "../../../../../api/structures/IPageIShoppingMallDepositTransaction";

@Controller("/shoppingMall/admin/deposits/:depositId/transactions")
export class ShoppingmallAdminDepositsTransactionsController {
  /**
   * Create/deposit a new transaction record for a digital wallet
   * (IShoppingMallDepositTransaction).
   *
   * Create a new transaction for a specific user's digital deposit account. The
   * request payload determines the transaction type (income, outcome, refund,
   * admin_adjustment, etc.), amount, business status, and any linked references
   * (such as orders or audit events). Upon creation, the operation enforces
   * business rule validation—including non-negative balances, valid status
   * transitions, and fraud/risk heuristics—and updates the target deposit's
   * balance accordingly.
   *
   * All creation events are appended to the deposit's audit log and may trigger
   * compliance or risk scoring. This operation supports customer-initiated
   * activity (manual top-up, refund, spending) as well as admin-initiated
   * adjustments (freezing, deductions, fraud response). Strong access control
   * ensures only the deposit owner (for personal use) or authorized admins (for
   * adjustments/mitigation) can create new records. Upon success, the fully
   * detailed transaction DTO is returned, including the updated status and
   * linkage metadata.
   *
   * @param connection
   * @param depositId ID of the target deposit account the new transaction will
   *   be applied to.
   * @param body Complete information required to create a new deposit
   *   transaction—type, amount, status, references, evidence, and reason.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.ICreate,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await postShoppingMallAdminDepositsDepositIdTransactions({
        admin,
        depositId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List/filter all transactions in a specific deposit account
   * (IShoppingMallDepositTransaction).
   *
   * Retrieve all transactions belonging to a specific user's digital deposit
   * account, as referenced by the depositId path parameter. The operation
   * supports complex querying options—such as searching by transaction type,
   * business status, order reference, or time window—to provide comprehensive
   * visibility over deposit activity. This multi-role endpoint requires
   * authentication as the customer owner or an administrator with audit
   * permissions.
   *
   * Returned results can be filtered and paginated to handle large account
   * histories efficiently. All records returned are compliant with the
   * regulatory requirement for evidentiary reporting. Responses exclude
   * logically deleted transactions by default, but the schema supports soft
   * deletion for compliance/audit purposes. This operation directly references
   * 'shopping_mall_deposit_transactions' and returns paged data using the
   * appropriate DTO.
   *
   * Security and role validation are critical—customers may access only their
   * own deposit account transactions, while administrators can access all.
   * Rate-limiting and access logging should be applied due to the sensitivity
   * of financial data.
   *
   * @param connection
   * @param depositId ID of the target deposit account for which transactions
   *   will be listed.
   * @param body Filter and pagination parameters for the deposit account
   *   transaction query. May include type, business_status, order reference,
   *   date range, or amount range.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.IRequest,
  ): Promise<IPageIShoppingMallDepositTransaction> {
    try {
      return await patchShoppingMallAdminDepositsDepositIdTransactions({
        admin,
        depositId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a specific deposit transaction by transactionId
   * (IShoppingMallDepositTransaction).
   *
   * Retrieve full information for a specific digital deposit transaction, using
   * both the depositId and transactionId as identifiers. This operation returns
   * all relevant metadata; such as transaction type, order or evidence linkage,
   * business status, amount, reversal history, and audit reference. This is
   * essential for supporting customer queries, handling financial disputes,
   * enabling refund workflows, and investigating suspected fraud or risk
   * cases.
   *
   * The operation strictly enforces access control: only the deposit account
   * owner or system administrators may access individual transaction details
   * for privacy and security reasons. Every access is logged for an audit
   * trail. Data is returned as a fully detailed DTO, with all soft deletion or
   * reversal metadata included as required.
   *
   * @param connection
   * @param depositId ID of the parent deposit account (for cross-verification
   *   and access control).
   * @param transactionId Unique identifier for the deposit transaction to
   *   retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":transactionId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await getShoppingMallAdminDepositsDepositIdTransactionsTransactionId(
        {
          admin,
          depositId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific transaction for a deposit account
   * (IShoppingMallDepositTransaction).
   *
   * Modify a specific transaction within a digital deposit account, as
   * referenced by depositId and transactionId. Permitted updates include status
   * advancement, fraud/risk flagging, reversal/adjustment actions, and
   * administrative explanations. Strict validation enforces eligible
   * transitions, ensuring core financial invariants are respected (e.g., no
   * negative post-factum balances, evidentiary snapshots on reversal). All
   * updates generate audit events detailing before/after state, actor, and
   * reason for change.
   *
   * While admins can perform more extensive updates (status, fraud marking,
   * correction), users are limited to allowed fields per business rules and
   * only for their own account transactions. Every operation is logged for
   * regulatory/audit compliance, and errors on improper updates are surfaced
   * with actionable messages. Responses return the fully revised transaction
   * DTO upon success.
   *
   * @param connection
   * @param depositId ID of the deposit account parent. Required for access
   *   control and context.
   * @param transactionId ID of the transaction to update.
   * @param body Fields to update for the specified deposit transaction—e.g.,
   *   business_status, reversal info, fraud markers, etc.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":transactionId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallDepositTransaction.IUpdate,
  ): Promise<IShoppingMallDepositTransaction> {
    try {
      return await putShoppingMallAdminDepositsDepositIdTransactionsTransactionId(
        {
          admin,
          depositId,
          transactionId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically deletes (soft-delete) a specific deposit transaction for evidence
   * and compliance purposes.
   *
   * Delete (logically/soft) a specific deposit transaction entry for a given
   * deposit within the shopping mall's digital coin/balance system. The API
   * targets the shopping_mall_deposit_transactions entity as defined in the
   * Prisma model, storing transaction events for all deposit operations
   * including income, outcome, refunds, and administrative adjustments. The
   * operation sets the 'deleted_at' field for the targeted row, indicating it
   * has been logically deleted rather than physically erased, in accordance
   * with regulatory and audit requirements.
   *
   * Permissions for this endpoint are tightly controlled: typically, only admin
   * users or trusted compliance staff may perform logical deletion, and an
   * audit log must be written (not shown in API response). Authorization checks
   * ensure system integrity and prevent inappropriate tampering with financial
   * history. All related evidence, balance reconciliation, and business-side
   * reversals must be implemented in service/business logic, not this endpoint
   * directly.
   *
   * Related endpoints may include transaction creation (POST), viewing
   * single/multiple transactions (GET/PATCH), and evidence snapshot retrieval
   * for compliance/audit resolution. On error (e.g., record not found,
   * insufficient permission), the API returns a clear error message and never
   * returns or exposes deleted transaction details.
   *
   * This operation is part of the full deposit/fraud/audit management suite. It
   * requires both depositId and transactionId as path parameters, enforced as
   * UUIDs matching the underlying schema. Attempting to erase a transaction for
   * a mismatched deposit or already-deleted record results in error.
   *
   * @param connection
   * @param depositId Unique identifier for the deposit record containing the
   *   transaction; must be a valid UUID as per shopping_mall_deposits.id.
   * @param transactionId Unique identifier for the deposit transaction to be
   *   logically deleted; must match shopping_mall_deposit_transactions.id.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":transactionId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("depositId")
    depositId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminDepositsDepositIdTransactionsTransactionId(
        {
          admin,
          depositId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
