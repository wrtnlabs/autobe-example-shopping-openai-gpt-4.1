import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchShoppingMallAdminCustomersCustomerIdIdentities } from "../../../../../providers/patchShoppingMallAdminCustomersCustomerIdIdentities";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { getShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId } from "../../../../../providers/getShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId";
import { putShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId } from "../../../../../providers/putShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId";
import { deleteShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId } from "../../../../../providers/deleteShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId";

import { IPageIShoppingMallCustomerIdentity } from "../../../../../api/structures/IPageIShoppingMallCustomerIdentity";
import { IShoppingMallCustomerIdentity } from "../../../../../api/structures/IShoppingMallCustomerIdentity";

@Controller("/shoppingMall/admin/customers/:customerId/identities")
export class ShoppingmallAdminCustomersIdentitiesController {
  /**
   * Search and retrieve all identity verification records (KYC) linked to a
   * customer.
   *
   * This operation allows querying all identity verification entries tied to a
   * specific customer within the shopping mall platform. It directly interfaces
   * with the shopping_mall_customer_identities table, letting authorized users
   * perform advanced searches on identity records such as government ID,
   * passport, or driver's license information. The search allows filtering by
   * identity type, status, verification date, and issuer, supporting
   * regulatory, support, and audit functions.
   *
   * Access to this endpoint must be restricted to authorized roles (such as
   * admins and potentially the customer themselves for their own records) due
   * to the presence of sensitive PII. Business logic must enforce the
   * customerId path parameter strictly matches the referenced customer, with
   * validation on privacy and access rights. Search results are paginated by
   * default for scalability.
   *
   * Error scenarios include invalid customer ID (404), unauthorized access
   * (403), input validation errors (400), and rate limitation (429). Only
   * non-deleted identities are returned unless specifically requested for
   * audit/compliance scenarios.
   *
   * The request body supports advanced search and pagination parameters
   * aligning with expected fields such as identity_type, status, and
   * verification dates. The response includes summaries of matching identity
   * records.
   *
   * This endpoint is related to identity detail retrieval (GET
   * /customers/{customerId}/identities/{identityId}) and update (PUT), forming
   * the read portion of customer KYC workflows.
   *
   * @param connection
   * @param customerId Unique identifier for the customer whose identities are
   *   being queried.
   * @param body Search and pagination criteria for customer identity records.
   *   Supports fields such as identity_type, status, issuer, and verification
   *   date ranges.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCustomerIdentity.IRequest,
  ): Promise<IPageIShoppingMallCustomerIdentity.ISummary> {
    try {
      return await patchShoppingMallAdminCustomersCustomerIdIdentities({
        admin,
        customerId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get detailed information for a specific customer identity verification
   * record.
   *
   * This operation fetches the complete details for a single identity
   * verification (KYC) record for a customer. It is used by administrators or
   * compliance officers to view sensitive personal information submitted for
   * identity validation including document type, status, issue date, issuer,
   * and verification status. The endpoint references
   * shopping_mall_customer_identities, cross-validating customerId and
   * identityId to ensure correct linkage and data access.
   *
   * Security is paramount: only authorized roles (admins, the customer for
   * their own identities) may access this data, and all accesses must be logged
   * for audit. Attempting to access a non-existent or mismatched record results
   * in 404 or 403 errors. Sensitive fields must be masked or redacted as per
   * business and legal requirements depending on the role making the request.
   *
   * This endpoint is typically used in conjunction with list/search and update
   * (PUT) operations. It does not expose underlying audit/snapshot tables, but
   * may reference them if legally required for dispute or compliance.
   *
   * Other error conditions include invalid parameters (400), unauthorized
   * access (403), and unexpected system errors (500).
   *
   * @param connection
   * @param customerId Unique identifier of the customer whose identity record
   *   is being retrieved.
   * @param identityId Unique identifier of the identity verification record
   *   being retrieved.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":identityId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("identityId")
    identityId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallCustomerIdentity> {
    try {
      return await getShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId({
        admin,
        customerId,
        identityId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific customer identity verification record (KYC info).
   *
   * This operation enables authorized administrators to update a particular
   * customer identity verification (KYC) record. It interacts with the
   * shopping_mall_customer_identities table to modify fields such as identity
   * type, status, issue/verification date, issuer, or associated meta when
   * required for business/support/compliance corrections. Both customerId and
   * identityId parameters are required and strictly validated; the system
   * ensures only administrators (or the customer for limited self-service, if
   * permitted) can perform sensitive updates.
   *
   * The request body must provide a full or partial update adhering to
   * validation rules (e.g., valid status values, ISO date formats). Business
   * rules may enforce status transitions (e.g., pending→verified) and trigger
   * audit snapshots for compliance. All updates are logged with before/after
   * state to meet regulatory requirements.
   *
   * If either customer or identity record does not exist, a 404 error is
   * returned; permission violations return 403, and validation errors produce
   * 400 responses. Unauthorized fields or transitions are blocked by business
   * logic.
   *
   * @param connection
   * @param customerId Unique identifier of the customer.
   * @param identityId Unique identifier of the identity verification record to
   *   update.
   * @param body Update data for the customer identity record, such as status or
   *   verification details.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":identityId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("identityId")
    identityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallCustomerIdentity.IUpdate,
  ): Promise<IShoppingMallCustomerIdentity> {
    try {
      return await putShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId({
        admin,
        customerId,
        identityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a customer identity verification record.
   *
   * This operation performs a logical (soft) delete on a customer's identity
   * verification record. It sets the deleted_at field for the specified record
   * in shopping_mall_customer_identities, preventing further use but retaining
   * the record for audit, rollback, and legal evidence. The operation validates
   * both customerId and identityId path parameters, ensuring that only
   * authorized administrative roles can perform deletion.
   *
   * Soft-deleted records are excluded from normal queries but may be referenced
   * for regulatory compliance, dispute resolution, or explicit audit export.
   * The system logs the delete event including actor, timestamp, and business
   * context for evidence preservation. Attempting to delete a non-existent or
   * already deleted record results in 404 errors; unauthorized attempts return
   * 403.
   *
   * There is no response body for this operation—confirmation is via status
   * code and audit log entry. Other error scenarios include validation errors
   * (400), permission failure (403), and system errors (500).
   *
   * @param connection
   * @param customerId Unique identifier of the customer.
   * @param identityId Unique identifier of the identity verification record to
   *   delete.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":identityId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("customerId")
    customerId: string & tags.Format<"uuid">,
    @TypedParam("identityId")
    identityId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminCustomersCustomerIdIdentitiesIdentityId(
        {
          admin,
          customerId,
          identityId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
