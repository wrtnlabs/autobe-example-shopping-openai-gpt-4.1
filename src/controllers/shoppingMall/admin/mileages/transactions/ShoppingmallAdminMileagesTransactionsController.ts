import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminMileagesMileageIdTransactions } from "../../../../../providers/postShoppingMallAdminMileagesMileageIdTransactions";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminMileagesMileageIdTransactions } from "../../../../../providers/patchShoppingMallAdminMileagesMileageIdTransactions";
import { getShoppingMallAdminMileagesMileageIdTransactionsTransactionId } from "../../../../../providers/getShoppingMallAdminMileagesMileageIdTransactionsTransactionId";
import { putShoppingMallAdminMileagesMileageIdTransactionsTransactionId } from "../../../../../providers/putShoppingMallAdminMileagesMileageIdTransactionsTransactionId";
import { deleteShoppingMallAdminMileagesMileageIdTransactionsTransactionId } from "../../../../../providers/deleteShoppingMallAdminMileagesMileageIdTransactionsTransactionId";

import { IShoppingMallMileageTransaction } from "../../../../../api/structures/IShoppingMallMileageTransaction";
import { IPageIShoppingMallMileageTransaction } from "../../../../../api/structures/IPageIShoppingMallMileageTransaction";

@Controller("/shoppingMall/admin/mileages/:mileageId/transactions")
export class ShoppingmallAdminMileagesTransactionsController {
  /**
   * Create a new mileage transaction for a given mileage account
   * (shopping_mall_mileages).
   *
   * Create a new transaction for an existing mileage account
   * (shopping_mall_mileages) belonging to a customer. This API writes a row in
   * shopping_mall_mileage_transactions and is used when users accrue, spend,
   * receive bonuses, or have miles expire. The API validates sufficient balance
   * for spending/expiration, enforces constraints for transaction type (e.g.,
   * no accrual for frozen accounts), and records the business reason (campaign,
   * purchase, refund, manual, etc.). The action is fully auditable, with a new
   * transaction created for every mutation, never overwriting previous
   * transactions. If the operation is successful, updated mileage and a
   * reference to the transaction are returned. The API enforces role-based
   * permissions: only the account owner or an admin may create a transaction,
   * and audit logs are generated for compliance. Edge cases, such as attempts
   * to spend more than the available balance, are rejected with descriptive
   * errors. Related APIs include PUT for transaction update and DELETE for
   * transaction cancellation/reversal. All values respect regulatory and
   * promotional rules linked to the account type.
   *
   * @param connection
   * @param mileageId The unique identifier of the target mileage account for
   *   which the transaction is being created.
   * @param body Payload describing the type, amount, business context, and
   *   reference IDs for the new mileage transaction. Follows the
   *   IShoppingMallMileageTransaction.ICreate DTO specification.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallMileageTransaction.ICreate,
  ): Promise<IShoppingMallMileageTransaction> {
    try {
      return await postShoppingMallAdminMileagesMileageIdTransactions({
        admin,
        mileageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and filter all transactions for a specific mileage (loyalty/point)
   * account using shopping_mall_mileage_transactions table.
   *
   * Retrieve the full or filtered transaction history for a given mileage
   * account (UUID), as recorded in the shopping_mall_mileage_transactions
   * table. This includes accrual, redemption, expiry, adjustments, and
   * donation/bonus transactions, all tied to the mileage account as per the
   * schema.
   *
   * The operation supports complex filtering (e.g., transaction type, status,
   * date ranges), sorting (by date or amount), and standard pagination
   * (page/size parameters) to allow users or administrators to browse both
   * recent and historic transactions. Security and authorization ensure only
   * account owners or authorized admins may view the data, which may contain
   * sensitive financial or loyalty information.
   *
   * Business logic in this operation enforces strict visibility: customers can
   * only see their own mileage transactions, while admins may access broader
   * histories for support, audit, or compliance. Transactions are immutable and
   * provide evidence-grade history for audit trails, dispute resolution, or
   * bonus calculation. All responses comply with data privacy and retention
   * rules.
   *
   * @param connection
   * @param mileageId UUID of the mileage account for which transactions are
   *   listed.
   * @param body Filtering, pagination, and sorting criteria for listing mileage
   *   transactions.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallMileageTransaction.IRequest,
  ): Promise<IPageIShoppingMallMileageTransaction> {
    try {
      return await patchShoppingMallAdminMileagesMileageIdTransactions({
        admin,
        mileageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed information for a single mileage transaction record from
   * shopping_mall_mileage_transactions table.
   *
   * Get the complete details of a single mileage (loyalty/point) transaction
   * for a specific mileage account, using both the account UUID and transaction
   * UUID. The operation pulls from the shopping_mall_mileage_transactions table
   * and ensures that access is restricted to only account owners or authorized
   * administrators.
   *
   * Business rules strictly enforce that a user cannot access transactions
   * outside their own account, while administrators can retrieve any
   * transaction for support/audit. Standard validation is applied to confirm
   * both IDs are valid and related. This endpoint is useful for customers
   * reviewing their point activity or for support/finance resolving disputes.
   *
   * Information returned includes the full transaction record: transaction type
   * (accrual, spend, adjustment, etc.), amount, status, timestamps, business
   * reason, evidence_reference, and any related order. All access is logged for
   * privacy and compliance.
   *
   * @param connection
   * @param mileageId UUID of the parent mileage account.
   * @param transactionId UUID of the specific transaction to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":transactionId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallMileageTransaction> {
    try {
      return await getShoppingMallAdminMileagesMileageIdTransactionsTransactionId(
        {
          admin,
          mileageId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing mileage transaction record by transactionId.
   *
   * Update an existing transaction for a user's mileage account
   * (shopping_mall_mileages and shopping_mall_mileage_transactions). This API
   * is typically used for administrative or error-correction purposes—updating
   * status, reason, or evidence—but does not allow changing core event amounts
   * or types after finalization. Validations prevent update of finalized or
   * expired transactions. When a transaction is updated, a snapshot of the
   * previous state is kept for compliance, traceability, and rollback. The
   * operation provides descriptive error messages if the transaction is locked
   * or if fields are immutable. Success returns the updated transaction. The
   * action is permitted for admins or, in certain cases, for the customer by
   * business policy.
   *
   * @param connection
   * @param mileageId The unique identifier of the mileage account to which the
   *   transaction belongs.
   * @param transactionId The unique identifier of the transaction to update.
   * @param body Update payload for the mileage transaction. Follows
   *   IShoppingMallMileageTransaction.IUpdate structure; only mutable fields
   *   may be updated.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":transactionId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallMileageTransaction.IUpdate,
  ): Promise<IShoppingMallMileageTransaction> {
    try {
      return await putShoppingMallAdminMileagesMileageIdTransactionsTransactionId(
        {
          admin,
          mileageId,
          transactionId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically delete (soft delete or reverse) a mileage transaction by its
   * transactionId for a mileage account.
   *
   * Erase (soft delete or reverse) a mileage transaction for a specified
   * mileage account. This operation marks the transaction as deleted using the
   * deleted_at column, without removing data from the database, to meet audit
   * and compliance requirements. The operation is accessible only to
   * administrators or elevated permission roles. Customers may only request
   * deletion, which triggers an admin review. Attempts to erase finalized or
   * non-existent transactions will result in a detailed error. Audit logs of
   * reversal or deletion are created, and regulatory holds are checked when
   * applicable. No response body is returned on success.
   *
   * @param connection
   * @param mileageId The unique identifier of the mileage account containing
   *   the transaction.
   * @param transactionId The unique identifier of the transaction to be erased
   *   (soft deleted/reversed).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":transactionId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("mileageId")
    mileageId: string & tags.Format<"uuid">,
    @TypedParam("transactionId")
    transactionId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminMileagesMileageIdTransactionsTransactionId(
        {
          admin,
          mileageId,
          transactionId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
