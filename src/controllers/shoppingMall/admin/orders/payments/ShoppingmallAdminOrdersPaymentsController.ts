import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminOrdersOrderIdPayments } from "../../../../../providers/postShoppingMallAdminOrdersOrderIdPayments";
import { AdminAuth } from "../../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminOrdersOrderIdPayments } from "../../../../../providers/patchShoppingMallAdminOrdersOrderIdPayments";
import { getShoppingMallAdminOrdersOrderIdPaymentsPaymentId } from "../../../../../providers/getShoppingMallAdminOrdersOrderIdPaymentsPaymentId";
import { putShoppingMallAdminOrdersOrderIdPaymentsPaymentId } from "../../../../../providers/putShoppingMallAdminOrdersOrderIdPaymentsPaymentId";
import { deleteShoppingMallAdminOrdersOrderIdPaymentsPaymentId } from "../../../../../providers/deleteShoppingMallAdminOrdersOrderIdPaymentsPaymentId";

import { IShoppingMallPayment } from "../../../../../api/structures/IShoppingMallPayment";
import { IPageIShoppingMallPayment } from "../../../../../api/structures/IPageIShoppingMallPayment";

@Controller("/shoppingMall/admin/orders/:orderId/payments")
export class ShoppingmallAdminOrdersPaymentsController {
  /**
   * Create a new payment for an order (shopping_mall_payments) with full
   * business rule validation.
   *
   * This endpoint allows authorized users to initiate a new payment against an
   * order, specifying all required details such as payment type, amount,
   * customer identity, and optional external references. The system performs
   * validation on payment rules: matching allowed payment methods, checking
   * maximum/minimum values, and ensuring no redundant or conflicting payments
   * for the order.
   *
   * Upon success, creates a payment record in shopping_mall_payments, links it
   * to the order, and returns the created payment with full business context.
   * Async and external (e.g., virtual account) payments must be correctly
   * flagged and all evidence chains preserved. Audit and PCI compliance apply
   * to the request and response bodies.
   *
   * Security and permission checks ensure this operation can only be performed
   * by authorized roles (e.g., customer placing the order, system admin,
   * possibly seller in limited contexts).
   *
   * In the event of validation or business rule failure, returns a clear,
   * actionable 400 or 422 error with specific reason and remediation options.
   *
   * @param connection
   * @param orderId UUID of the order for which payment is being initiated.
   * @param body Payment creation details: type, amount, customer, settlement
   *   data, etc.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("orderId")
    orderId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallPayment.ICreate,
  ): Promise<IShoppingMallPayment> {
    try {
      return await postShoppingMallAdminOrdersOrderIdPayments({
        admin,
        orderId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and search all payment records associated with a specific order
   * (shopping_mall_payments) with pagination and filtering.
   *
   * Allows authorized users to retrieve a paginated, filtered list of all
   * payments linked to a specific order. Query can include filters for payment
   * status, type, date ranges, or other payment-specific attributes as defined
   * in the request body DTO.
   *
   * Supports business operations such as viewing all payment attempts,
   * reconciling refunds, and tracking multi-method settlements for complex
   * order flows. Pagination parameters control result size and sorting,
   * adhering to standard patterns for performance and usability.
   *
   * DB integration: Uses shopping_mall_payments filtered by the given orderId,
   * with possible joins to orders and customers for additional context. Only
   * users with access to the order (customer, related seller, or admin) can use
   * this endpoint. Permission and data masking apply for privacy compliance.
   *
   * The response structure includes a list of payment summaries, paginated, and
   * metadata for total count, pages, etc. All returned records are mapped and
   * masked according to user permissions.
   *
   * @param connection
   * @param orderId UUID of the target order to fetch payments for.
   * @param body Search and filter criteria for payments, including date range,
   *   status, payment type, and pagination parameters.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("orderId")
    orderId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallPayment.IRequest,
  ): Promise<IPageIShoppingMallPayment.ISummary> {
    try {
      return await patchShoppingMallAdminOrdersOrderIdPayments({
        admin,
        orderId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detail of a single payment under a specific order
   * (shopping_mall_payments).
   *
   * Fetches a single payment instance linked to a given order, returning full
   * details for reconciliation, business audit, or customer service inquiries.
   * Enforces both orderId and paymentId as mandatory UUID parameters, verifying
   * that the payment belongs to the specified order and is accessible by the
   * requesting user.
   *
   * Typical use cases include analytics of split payments, audit of refunds or
   * failed attempts, and programmatic lookup for order history screens. Only
   * users affiliated to the order (such as admins, the ordering customer, or
   * responsible seller) may access this endpoint; permission checks must be
   * strictly enforced.
   *
   * Response includes all available details of the payment (amount, status,
   * type, settlement references, timestamps, failure/cancellation info where
   * relevant), as held in the shopping_mall_payments table and related
   * entities.
   *
   * @param connection
   * @param orderId UUID of the referenced order for context and permission
   *   checks.
   * @param paymentId UUID of the payment record to fetch; must belong to the
   *   given order.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":paymentId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("orderId")
    orderId: string & tags.Format<"uuid">,
    @TypedParam("paymentId")
    paymentId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallPayment> {
    try {
      return await getShoppingMallAdminOrdersOrderIdPaymentsPaymentId({
        admin,
        orderId,
        paymentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific payment record under an order (shopping_mall_payments).
   *
   * This operation is used to update all mutable fields of a specific payment
   * (referenced by paymentId) belonging to an order (referenced by orderId) in
   * the shopping mall backend. The 'shopping_mall_payments' entity supports
   * business flows such as confirming payments, marking them as refunded or
   * cancelled, updating payment type, or altering reference fields for
   * asynchronous/external settlements.
   *
   * Updates are restricted to valid status transitions, and permission checks
   * must ensure only authorized roles (admin, finance) can perform these
   * modifications. All operations are logged for auditability, and a payment
   * snapshot may be created after the update for compliance. The system will
   * reject updates that attempt to modify immutable fields or transition the
   * payment to illegal states (e.g., marking already settled payments as
   * pending).
   *
   * The underlying schema ensures payment records have strong referential
   * binding to orders and customers. Related endpoints allow for payment state
   * transitions, snapshot retrievals, and audit trail inspection. Clients must
   * provide a well-formed update body according to payment business rules and
   * data type constraints.
   *
   * Related operations include retrieving specific payments (GET), listing all
   * payments for an order, or creating payment snapshots to preserve history.
   * Errors may occur if referenced orderId/paymentId are not found, or if
   * business rule validation fails.
   *
   * @param connection
   * @param orderId Unique identifier of the order containing the payment to
   *   update.
   * @param paymentId Unique identifier of the payment to be updated.
   * @param body Properties to update for the specified payment record. Only
   *   mutable fields are accepted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":paymentId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("orderId")
    orderId: string & tags.Format<"uuid">,
    @TypedParam("paymentId")
    paymentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallPayment.IUpdate,
  ): Promise<IShoppingMallPayment> {
    try {
      return await putShoppingMallAdminOrdersOrderIdPaymentsPaymentId({
        admin,
        orderId,
        paymentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete a specific payment in an order (sets deleted_at on
   * shopping_mall_payments).
   *
   * This endpoint soft-deletes a specific payment record (by paymentId)
   * associated with a given order (by orderId) in the shopping mall backend.
   * Payment records are never physically destroyed; instead, the 'deleted_at'
   * timestamp is set for regulatory compliance and audit trail preservation.
   * Only users with administrative permissions may access this operation, and
   * all actions are fully auditable.
   *
   * Business rules ensure that only payments that are not fully reconciled or
   * settled may be logically deleted; otherwise, an error is returned. The
   * system maintains references to related audit/snapshot records and updates
   * payment status upon soft deletion. This operation is critical for
   * compliance environments where financial records cannot be hard deleted.
   *
   * If either the payment or the order is not found, or if the payment is
   * locked from deletion due to settlement or ongoing dispute, the request
   * fails and an error describing the problem is provided.
   *
   * @param connection
   * @param orderId Unique identifier of the order containing the payment to
   *   delete.
   * @param paymentId Unique identifier of the payment to be soft-deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":paymentId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("orderId")
    orderId: string & tags.Format<"uuid">,
    @TypedParam("paymentId")
    paymentId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminOrdersOrderIdPaymentsPaymentId({
        admin,
        orderId,
        paymentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
