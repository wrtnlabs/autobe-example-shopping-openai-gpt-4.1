import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postShoppingMallAdminAttachments } from "../../../../providers/postShoppingMallAdminAttachments";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { patchShoppingMallAdminAttachments } from "../../../../providers/patchShoppingMallAdminAttachments";
import { getShoppingMallAdminAttachmentsAttachmentId } from "../../../../providers/getShoppingMallAdminAttachmentsAttachmentId";
import { putShoppingMallAdminAttachmentsAttachmentId } from "../../../../providers/putShoppingMallAdminAttachmentsAttachmentId";
import { deleteShoppingMallAdminAttachmentsAttachmentId } from "../../../../providers/deleteShoppingMallAdminAttachmentsAttachmentId";

import { IShoppingMallAttachment } from "../../../../api/structures/IShoppingMallAttachment";
import { IPageIShoppingMallAttachment } from "../../../../api/structures/IPageIShoppingMallAttachment";

@Controller("/shoppingMall/admin/attachments")
export class ShoppingmallAdminAttachmentsController {
  /**
   * Upload/create a new file attachment with metadata and version in
   * shopping_mall_attachments/shopping_mall_attachment_versions.
   *
   * Permits uploading a new file attachment to the platform. The request must
   * include a file reference (URI or temporary storage pointer after frontend
   * upload), business context fields (intended module/entity, expected
   * permission scope), and optional description tags. Uploaded files are
   * validated by type, size, and policy before being stored and indexed on the
   * backend. Upon success, metadata is created for the primary attachment
   * entity as well as the initial version in the version table.
   *
   * File uploads by users are permission checked: only authenticated actors
   * (customers, sellers, admins) may initiate uploads. Business logic applies
   * quota enforcement and extension/format validation, and performs
   * malware/virus scans and any compliance-related pre-processing. The
   * operation may generate public or restricted URLs based on permission_scope.
   * Errors include file invalidation (415), exceeded quota (429), or permission
   * failure (403). The response includes the full attachment metadata and
   * permitted download URLs for future use.
   *
   * @param connection
   * @param body Attachment creation/upload data including file reference,
   *   intended purpose, extension, and permissions.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAttachment.ICreate,
  ): Promise<IShoppingMallAttachment> {
    try {
      return await postShoppingMallAdminAttachments({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate shopping mall file attachments (attachment list).
   *
   * Fetches a paginated list of file attachments, allowing advanced filtering,
   * search, and sorting across the entire attachment store. Attachment records
   * include key metadata fields such as filename, extension, mime type, upload
   * context, business logical source, permission scope, and time metadata.
   *
   * Admins and authorized file managers use this operation to audit and oversee
   * file usage, storage, and distribution platform-wide. The operation supports
   * filtering by filename, mime type, extension, user role, logical source,
   * created_at window, and deletion status. Pagination parameters (page, size)
   * and sorting (by created_at, name, size) are standard, complying with audit
   * and compliance requirements for file management and evidence collection.
   *
   * Security and privacy considerations ensure only authorized roles can view
   * or manage restricted/private files. Business logic enforces resource quota
   * and access visibility rules. Error handling covers search syntax,
   * permission failures (403), and system-level limits (429, 500). Results are
   * paginated and ordered as requested.
   *
   * @param connection
   * @param body Attachment file search, filtering, and pagination instructions.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAttachment.IRequest,
  ): Promise<IPageIShoppingMallAttachment> {
    try {
      return await patchShoppingMallAdminAttachments({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve metadata and file info for a specific attachment by attachmentId
   * (shopping_mall_attachments).
   *
   * Fetches the current, latest metadata for a specific file attachment
   * identified by attachmentId. Metadata includes filename, extension, MIME
   * type, size, current CDN/server URL, permission scope, version management
   * links, hash for integrity, logical business source, description, and
   * time/ownership fields. The response can include a list or link to file
   * versions if versioning is enabled on the file.
   *
   * Callers use this to display, audit, or access downloadable resources within
   * the platform securely. Download permissions are enforced using the
   * permission_scope on the attachment, ensuring only qualified users, admins,
   * or entity owners can retrieve file links. Errors include 404 for invalid or
   * deleted files, 403 for unauthorized attempts, and audit trails for all
   * retrievals. Business logic may log access by actor ID and context for
   * compliance.
   *
   * @param connection
   * @param attachmentId ID of the file attachment to retrieve
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":attachmentId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("attachmentId")
    attachmentId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAttachment> {
    try {
      return await getShoppingMallAdminAttachmentsAttachmentId({
        admin,
        attachmentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a specific attachment's metadata in shopping_mall_attachments table.
   *
   * This API operation updates metadata of an existing file attachment. The
   * endpoint modifies fields like filename, file extension, MIME type,
   * permission scope, logical source, or display description for the attachment
   * specified by attachmentId. All changes are validated for compliance with
   * business logic, permission scopes, and auditability requirements.
   *
   * Security is enforced so that only authorized users (the original uploader
   * or admins with proper privileges) can modify attachment records. All
   * changes are snapshotted, and a full audit log is maintained for regulatory
   * and security purposes. The underlying business entity remains unchanged;
   * this endpoint does not upload or replace file content. Only metadata
   * properties are editable. Attempting to update immutable properties or
   * manipulate file content via this endpoint will result in an error.
   *
   * This endpoint directly affects only the shopping_mall_attachments table,
   * ensuring strict validation of all mutable fields in the schema's
   * specification comments. Any errors in user permissions, attachment not
   * found, or invalid metadata will be reported with actionable error messages.
   * This API works in concert with the attachment versioning endpoint for full
   * file lifecycle management.
   *
   * @param connection
   * @param attachmentId Unique identifier of the attachment record to update
   * @param body The new metadata to apply to the attachment. Modifiable fields
   *   include filename, file extension, MIME type, permission scope, logical
   *   source, and description. File content cannot be updated from this
   *   endpoint.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":attachmentId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("attachmentId")
    attachmentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAttachment.IUpdate,
  ): Promise<IShoppingMallAttachment> {
    try {
      return await putShoppingMallAdminAttachmentsAttachmentId({
        admin,
        attachmentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically delete (soft delete) a specific attachment record in
   * shopping_mall_attachments table.
   *
   * This API operation performs a logical (soft) deletion of a file attachment
   * entity. The endpoint sets the deleted_at timestamp of the targeted record,
   * disabling any further access, download, or linkage for standard users.
   * Compliance and audit users retain read-only access for legal/dispute review
   * purposes.
   *
   * Only users with admin privileges or explicit attachment management
   * permission may invoke this endpoint. All deletions are non-destructive and
   * fully audited, as required by platform compliance standards (GDPR, audit
   * trails, evidence retention). Attempting to delete an already-deleted or
   * non-existent attachment results in a descriptive error message. This
   * operation covers only metadata-level deletion and does not erase physical
   * file storageâ€”physical deletion is managed by separate retention processes
   * at the system level.
   *
   * The endpoint ensures full compliance with the soft-delete pattern described
   * in the schema comments and does not perform a hard delete under any
   * circumstances. Associated attachment versions and business links remain,
   * but are inaccessible through standard business operations.
   *
   * @param connection
   * @param attachmentId Unique identifier of the attachment record to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":attachmentId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("attachmentId")
    attachmentId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteShoppingMallAdminAttachmentsAttachmentId({
        admin,
        attachmentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
