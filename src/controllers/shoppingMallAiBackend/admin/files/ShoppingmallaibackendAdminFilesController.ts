import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { post__shoppingMallAiBackend_admin_files } from "../../../../providers/post__shoppingMallAiBackend_admin_files";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { patch__shoppingMallAiBackend_admin_files } from "../../../../providers/patch__shoppingMallAiBackend_admin_files";
import { get__shoppingMallAiBackend_admin_files_$fileId } from "../../../../providers/get__shoppingMallAiBackend_admin_files_$fileId";
import { put__shoppingMallAiBackend_admin_files_$fileId } from "../../../../providers/put__shoppingMallAiBackend_admin_files_$fileId";
import { delete__shoppingMallAiBackend_admin_files_$fileId } from "../../../../providers/delete__shoppingMallAiBackend_admin_files_$fileId";

import { IShoppingMallAiBackendFile } from "../../../../api/structures/IShoppingMallAiBackendFile";
import { IPageIShoppingMallAiBackendFile } from "../../../../api/structures/IPageIShoppingMallAiBackendFile";

@Controller("/shoppingMallAiBackend/admin/files")
export class ShoppingmallaibackendAdminFilesController {
  /**
   * Register a new file metadata entry in shopping_mall_ai_backend_files.
   *
   * Register a new file metadata record in the shopping mall backend, capturing
   * essential details about the uploaded resource. This does not handle binary
   * data; instead, the file is expected to be uploaded separately (such as to
   * S3, Blob, or CDN) and the storage URI referenced here. Recorded fields
   * include the original filename, content type, unique storage URI, total file
   * size in bytes, uploader’s UUID, and upload timestamp.
   *
   * All writes to this endpoint require strict permissions due to security,
   * privacy, and governance concerns (e.g., evidence files, legal documents).
   * The created record enables subsequent access, auditing, or business
   * notification.
   *
   * On success, the created record is returned. Attempts to register duplicate
   * file URIs or forbidden metadata will result in business errors, following
   * unique constraints.
   *
   * @param connection
   * @param body New file metadata to register (not file content itself, but
   *   reference to storage and metadata)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAiBackendFile.ICreate,
  ): Promise<IShoppingMallAiBackendFile> {
    try {
      return await post__shoppingMallAiBackend_admin_files({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate file metadata records on
   * shopping_mall_ai_backend_files.
   *
   * Retrieve a paginated and filtered list of uploaded file metadata from
   * across the platform. This operation allows administrators to search files
   * based on file type, uploader, unique storage URI, file name patterns, or
   * upload date ranges. The search results are used for compliance reviews,
   * evidence management, and platform-wide content governance.
   *
   * Only admin users may use this endpoint due to sensitivity of file access
   * and potential privacy concerns. The operation respects logical deletion
   * (deleted_at); by default, it only returns active files unless filters for
   * deleted items are included. Bulk export or legal production workflows may
   * require this API.
   *
   * Results include file URI, original filename, uploader, content type, file
   * size, and upload timestamp for each record, supporting traceability and
   * operational maintenance.
   *
   * @param connection
   * @param body Complex criteria for searching or paginating file metadata
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IShoppingMallAiBackendFile.IRequest,
  ): Promise<IPageIShoppingMallAiBackendFile.ISummary> {
    try {
      return await patch__shoppingMallAiBackend_admin_files({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get file metadata by fileId from shopping_mall_ai_backend_files.
   *
   * Fetch the metadata of an individual file, such as is required for evidence,
   * admin review, legal production, or managing file content in enterprise
   * systems. This operation allows retrieval of the file’s unique storage URI,
   * original filename, mime type, file size in bytes, who uploaded it, and the
   * upload datetime. If the file is logically deleted, metadata including the
   * deleted_at timestamp is also returned.
   *
   * This endpoint helps power administrative dashboards, secure resource
   * fetches, and audit queries. Only admins may access this information,
   * protecting sensitive or private files. Attempts to access a non-existent
   * file or without permission return appropriate errors.
   *
   * @param connection
   * @param fileId Unique identifier of the file to fetch metadata for
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":fileId")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("fileId")
    fileId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAiBackendFile> {
    try {
      return await get__shoppingMallAiBackend_admin_files_$fileId({
        admin,
        fileId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update file metadata for a file in shopping_mall_ai_backend_files by
   * fileId.
   *
   * Update the file metadata record for a specific fileId. This operation
   * covers modifications to fields such as the file name, mime type, storage
   * URI, or even uploader metadata, but not the file content itself. Used when
   * a file’s metadata needs correction (such as if migrated to a new CDN or new
   * content-type is detected).
   *
   * The endpoint mandates strict administrative access as incorrect file
   * metadata could impact business evidence, system resources, or violate
   * security policy. All such changes should be auditable. Attempts to update a
   * non-existent file or forbidden fields return business or permission
   * errors.
   *
   * @param connection
   * @param fileId Unique identifier of file to update
   * @param body File metadata updates (does not change file content, only
   *   metadata)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":fileId")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("fileId")
    fileId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAiBackendFile.IUpdate,
  ): Promise<IShoppingMallAiBackendFile> {
    try {
      return await put__shoppingMallAiBackend_admin_files_$fileId({
        admin,
        fileId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft delete a file metadata entry by fileId in
   * shopping_mall_ai_backend_files.
   *
   * Mark a file metadata record as deleted by setting its deleted_at timestamp,
   * effectively hiding it from standard platform queries but retaining the
   * audit trail. This is a soft delete. Such logical deletion preserves file
   * history for business evidence and compliance cases. Only admin users can
   * invoke this action, and any actual file content removal is outside the
   * scope.
   *
   * If the file does not exist or is already deleted, a suitable business error
   * is returned. All operations must be auditable for compliance. The operation
   * follows the Prisma model’s typical logical deletion pattern using the
   * deleted_at nullable DateTime field.
   *
   * @param connection
   * @param fileId Unique identifier of the file to logically delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":fileId")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("fileId")
    fileId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await delete__shoppingMallAiBackend_admin_files_$fileId({
        admin,
        fileId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
