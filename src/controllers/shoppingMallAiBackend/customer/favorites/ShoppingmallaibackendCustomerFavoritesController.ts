import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { post__shoppingMallAiBackend_customer_favorites } from "../../../../providers/post__shoppingMallAiBackend_customer_favorites";
import { CustomerAuth } from "../../../../decorators/CustomerAuth";
import { CustomerPayload } from "../../../../decorators/payload/CustomerPayload";
import { patch__shoppingMallAiBackend_customer_favorites } from "../../../../providers/patch__shoppingMallAiBackend_customer_favorites";
import { get__shoppingMallAiBackend_customer_favorites_$favoriteId } from "../../../../providers/get__shoppingMallAiBackend_customer_favorites_$favoriteId";
import { put__shoppingMallAiBackend_customer_favorites_$favoriteId } from "../../../../providers/put__shoppingMallAiBackend_customer_favorites_$favoriteId";
import { delete__shoppingMallAiBackend_customer_favorites_$favoriteId } from "../../../../providers/delete__shoppingMallAiBackend_customer_favorites_$favoriteId";

import { IShoppingMallAiBackendFavorite } from "../../../../api/structures/IShoppingMallAiBackendFavorite";
import { IPageIShoppingMallAiBackendFavorite } from "../../../../api/structures/IPageIShoppingMallAiBackendFavorite";

@Controller("/shoppingMallAiBackend/customer/favorites")
export class ShoppingmallaibackendCustomerFavoritesController {
  /**
   * Create a new favorite for a specific target (product, address, inquiry).
   *
   * Creates a new favorite for the user, specifying the target type (product,
   * address, inquiry, etc.) and the unique ID of the target. Optionally, the
   * favorite can be placed into a user-created folder for grouped management.
   * Unique constraints are enforced to prevent users from favoriting the same
   * item multiple times.
   *
   * On successful creation, the endpoint returns all favorite details,
   * including audit evidence information, type, snapshot identifiers, and
   * timestamps. Any attempt to favorite an already-favorited target returns a
   * duplication error consistent with business policies.
   *
   * @param connection
   * @param body Favorite creation data: target type (product, address,
   *   inquiry), target ID, and optional folder.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallAiBackendFavorite.ICreate,
  ): Promise<IShoppingMallAiBackendFavorite> {
    try {
      return await post__shoppingMallAiBackend_customer_favorites({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and list paginated favorites for the authenticated user.
   *
   * Retrieves the authenticated user's favorites in a paginated result,
   * supporting search/filtering by target type, folder, or keywords. Only
   * non-deleted (active) favorites are shown. Advanced search allows users to
   * filter favorites by type (product, address, inquiry), folder, text, or date
   * range. Pagination and sorting options permit scalable browser navigation.
   *
   * Security checks ensure users can only view their own favorites and not
   * those of other users. Provides a summary view of each favorite, with audit
   * timestamps as per evidence policies.
   *
   * @param connection
   * @param body Filtering and pagination options for favorite retrieval: type,
   *   folder, search text, date range, pagination controls.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedBody()
    body: IShoppingMallAiBackendFavorite.IRequest,
  ): Promise<IPageIShoppingMallAiBackendFavorite.ISummary> {
    try {
      return await patch__shoppingMallAiBackend_customer_favorites({
        customer,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve details about a single favorite by ID for the owner.
   *
   * Gets full detail about a single favorite belonging to the user, enforcing
   * access to only non-deleted items owned by the requesting party. The
   * favorite includes fields like target type (product, address, inquiry),
   * snapshot metadata for audit, optional folder association, and full evidence
   * timestamps.
   *
   * The operation supports use cases like displaying item details in a user's
   * favorites page or preparing notification logic for favorite changes. If the
   * item doesn't exist or is deleted (or the user doesn't own it), appropriate
   * error or forbidden responses are returned.
   *
   * @param connection
   * @param favoriteId Unique identifier of the favorite to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":favoriteId")
  public async at(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteId")
    favoriteId: string & tags.Format<"uuid">,
  ): Promise<IShoppingMallAiBackendFavorite> {
    try {
      return await get__shoppingMallAiBackend_customer_favorites_$favoriteId({
        customer,
        favoriteId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing favorite's metadata or folder assignment.
   *
   * Update a favorite belonging to the requesting user. Supports changes to
   * organization folder, snapshot title, or other updatable metadata as allowed
   * in business requirements. Strict ownership and active status checks mean
   * only user-owned, non-deleted favorites can be modified. Change traces are
   * preserved for evidence and audit as required by platform policy.
   *
   * If the favorite does not exist or has been soft-deleted, a not found error
   * is returned. If updates violate uniqueness or business logic, an
   * appropriate error code is issued. The success response returns the updated
   * favorite entity with new timestamps and field values.
   *
   * @param connection
   * @param favoriteId Unique identifier of the favorite to update.
   * @param body Fields to update (e.g., folder ID, snapshot title).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":favoriteId")
  public async update(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteId")
    favoriteId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IShoppingMallAiBackendFavorite.IUpdate,
  ): Promise<IShoppingMallAiBackendFavorite> {
    try {
      return await put__shoppingMallAiBackend_customer_favorites_$favoriteId({
        customer,
        favoriteId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically deletes a favorite item with soft-delete using the deleted_at
   * field.
   *
   * Deletes a favorite record by its unique identifier. This operation marks
   * the favorite as deleted by setting its deleted_at field, rather than
   * permanently removing the row, in accordance with compliance and logical
   * deletion requirements for personal data. It ensures auditability and allows
   * admins to investigate deleted favorites as needed. Customers may only erase
   * favorites they own, while admins have system-level permissions. If the
   * favorite is already deleted, this call is idempotent and returns success.
   * Related child mappings (e.g., favorite_products, favorite_addresses,
   * favorite_inquiries) are handled by cascade logic in the database.
   *
   * @param connection
   * @param favoriteId Globally unique identifier of the favorite to be deleted.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":favoriteId")
  public async erase(
    @CustomerAuth()
    customer: CustomerPayload,
    @TypedParam("favoriteId")
    favoriteId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await delete__shoppingMallAiBackend_customer_favorites_$favoriteId(
        {
          customer,
          favoriteId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
