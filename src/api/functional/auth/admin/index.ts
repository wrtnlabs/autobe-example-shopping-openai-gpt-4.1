import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendAdmin } from "../../../structures/IShoppingMallAiBackendAdmin";

/**
 * Register a new admin account (shopping_mall_ai_backend_admins table) and
 * issue initial authorization tokens.
 *
 * This API endpoint allows creation of a new admin account by registering
 * required fields from the shopping_mall_ai_backend_admins table. The operation
 * gathers username, password_hash (securely hashed by the backend), real name,
 * email (unique and validated), and optional phone_number, establishing a new
 * system operator for global platform management.
 *
 * Upon registration, the system enforces all unique constraints (username,
 * email) and business validation rules relevant to regulatory requirements,
 * platform audit trail, and administrator onboarding. Success results in
 * creation of an eligible admin account with 'is_active' state set according to
 * policy (default active unless compliance/approval is required).
 *
 * If registration is successful, the backend issues a pair of access and
 * refresh JWT tokens, mapped to the session and audit trail. Token issuance
 * details are captured for compliance, security traceability and for
 * grant/revoke flows in future privilege escalations.
 *
 * This join operation is restricted to onboarding a new admin via API (not
 * interactive UI). Credentials are never exposed in cleartext; non-compliant
 * attempts result in validation or business errors. Admin registration is
 * subject to further review and enablement by super-admins where applicable.
 *
 * The operation is complementary to the login and refresh endpoints, which
 * handle subsequent credential validation and token renewal for API-centric
 * management. All operations defer credential hashing and security best
 * practices to backend subsystems for regulatory compliance and auditability.
 *
 * @param props.connection
 * @param props.body Registration data for new admin account, including
 *   username, hashed password, name, email, is_active, and optionally
 *   phone_number.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration data for new admin account, including username, hashed
     * password, name, email, is_active, and optionally phone_number.
     */
    body: IShoppingMallAiBackendAdmin.ICreate;
  };
  export type Body = IShoppingMallAiBackendAdmin.ICreate;
  export type Response = IShoppingMallAiBackendAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): IShoppingMallAiBackendAdmin.IAuthorized =>
    typia.random<IShoppingMallAiBackendAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin using username/password and issue authorization tokens
 * (shopping_mall_ai_backend_admins table).
 *
 * This API endpoint implements credential-based login for admin users by
 * accepting username and password. It references the
 * shopping_mall_ai_backend_admins schema, where username uniquely identifies
 * each admin and password_hash stores a securely hashed credential.
 *
 * The operation validates the provided credentials, confirms that the admin
 * account is active (is_active=true), not deleted (deleted_at is null), and if
 * authentication is successful, updates last_login_at for activity monitoring
 * and audit. It then generates and returns new access and refresh JWT tokens
 * with session metadata.
 *
 * Failed login attempts for suspended, deactivated, or non-existent accounts
 * are denied with appropriate business error codes, maintaining compliance and
 * evidence. All credential handling adheres to backend storage and transmission
 * security, never exposing hashes or plain text. The authentication supports
 * standard business login workflows, including error handling for duplicates,
 * concurrent sessions, and lockout policies as defined in business rules.
 *
 * This operation is to be used in tandem with join (registration) and refresh
 * endpoints, forming the core of the admin authentication system for secure API
 * management. It is tightly coupled with the administrator lifecycle and
 * evidence preservation policies as dictated by compliance needs.
 *
 * @param props.connection
 * @param props.body Admin login credentials (username, password). Password is
 *   securely validated against stored password_hash.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Admin login credentials (username, password). Password is securely
     * validated against stored password_hash.
     */
    body: IShoppingMallAiBackendAdmin.ILogin;
  };
  export type Body = IShoppingMallAiBackendAdmin.ILogin;
  export type Response = IShoppingMallAiBackendAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): IShoppingMallAiBackendAdmin.IAuthorized =>
    typia.random<IShoppingMallAiBackendAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Renew admin authentication tokens using a valid refresh token
 * (shopping_mall_ai_backend_admins table).
 *
 * This API endpoint implements authentication token renewal for admin users. It
 * is based on secure validation of a refresh token, which maps to an active
 * session and admin account in shopping_mall_ai_backend_admins. Upon
 * validation, the endpoint invalidates the used refresh token, issues new
 * access and refresh tokens, and updates audit/session state for evidence.
 *
 * The operation ensures all admin and session requirements: the admin must be
 * active (is_active=true), not deleted (deleted_at null), and the refresh token
 * must correspond to an active, unexpired session. Any failures—invalid/expired
 * tokens, deactivated account—result in access denial with business error codes
 * for compliance and traceability.
 *
 * Token renewal is managed in full accordance with JWT lifecycle, session
 * security, and backend audit policies. This operation is a critical component
 * of secure API-based admin management, enabling ongoing authenticated
 * interaction without resubmitting credentials for each session.
 *
 * This endpoint should be used in conjunction with the join (admin
 * registration) and login endpoints to provide a complete admin authentication
 * flow, and aligns with evidence preservation, role management, and regulatory
 * compliance requirements for privileged operations.
 *
 * @param props.connection
 * @param props.body Refresh token for session renewal. Must map to an eligible
 *   admin and an active session.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token for session renewal. Must map to an eligible admin and
     * an active session.
     */
    body: IShoppingMallAiBackendAdmin.IRefresh;
  };
  export type Body = IShoppingMallAiBackendAdmin.IRefresh;
  export type Response = IShoppingMallAiBackendAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): IShoppingMallAiBackendAdmin.IAuthorized =>
    typia.random<IShoppingMallAiBackendAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
