import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../structures/IShoppingMallCustomer";

/**
 * Register a new customer account (shopping_mall_customers table).
 *
 * This API operation enables the creation of a new customer account on the
 * shopping mall platform, referencing the shopping_mall_customers table as its
 * core. The customer's email (required and unique per channel), name, and
 * optional phone number are collected, with password_hash present only if a
 * password strategy is used, as observed in the schema.
 *
 * Upon invocation, the operation validates the uniqueness of the email within
 * the target channel and hashes any provided password before persisting as
 * password_hash. The kyc_status and status columns are initialized with channel
 * policy defaults ('active', 'pending', etc). It does not presume more than
 * these verified schema fields.
 *
 * Customer registration is implemented as a public endpoint, ensuring any user
 * can sign up as a new member provided the email is not already registered in
 * that channel. The implementation stores creation and update timestamps with
 * current UTC values. Soft deletion is supported post-registration by the
 * deleted_at field.
 *
 * On success, this operation issues a JWT access token and a refresh token to
 * the newly created customer, following the IShoppingMallCustomer.IAuthorized
 * structure (see DTO policy). The returned payload contains only fields
 * guaranteed by the current schema and omits any business logic outside the
 * registration transaction.
 *
 * This registration endpoint is related to the login and refresh endpoints.
 * Users will typically register here (join), then subsequently use the login
 * endpoint for authentication, and the refresh endpoint to renew tokens. Each
 * endpoint is documented to reference only shopping_mall_customers schema
 * columns observed.
 *
 * @param props.connection
 * @param props.body Information required to join/register as a new customer.
 *   Only fields defined in shopping_mall_customers schema are accepted.
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/join
 * @accessor api.functional.auth.customer.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Information required to join/register as a new customer. Only fields
     * defined in shopping_mall_customers schema are accepted.
     */
    body: IShoppingMallCustomer.IJoin;
  };
  export type Body = IShoppingMallCustomer.IJoin;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/join";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate (login) customer and issue JWT tokens (shopping_mall_customers
 * table).
 *
 * This API operation authenticates a customer using their registered email and
 * password, referencing the shopping_mall_customers table. It accepts provided
 * credentials, locates the customer by channel and email, and compares the
 * submitted password after hashing against the stored password_hash field.
 *
 * The login procedure checks that the customer’s status is not set to states
 * like 'suspended', 'withdrawn', or soft-deleted, as determined by the status
 * and deleted_at fields in the schema. Authentication is denied if status or
 * deletion policy fails. The kyc_status is not used for authentication gating
 * per schema analysis but could be referenced by business logic externally.
 *
 * After successful validation, the operation issues new JWT access and refresh
 * tokens for the session. Unsuccessful login attempts (invalid credentials,
 * status, or deleted_at present) are rejected with appropriate error handling.
 *
 * This login endpoint aligns with the join and refresh endpoints. Customers may
 * register via join, authenticate via login, and maintain sessions via refresh.
 * All password and sensitive data is handled according to best practices, only
 * accepting what schema fields support.
 *
 * The endpoint issues response bodies conforming to
 * IShoppingMallCustomer.IAuthorized, which holds token(s) and customer identity
 * payload based strictly on the schema. No fields outside those defined by the
 * schema are returned or assumed.
 *
 * @param props.connection
 * @param props.body User login credentials (email and password); only
 *   parameters defined in shopping_mall_customers schema are allowed.
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/login
 * @accessor api.functional.auth.customer.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * User login credentials (email and password); only parameters defined
     * in shopping_mall_customers schema are allowed.
     */
    body: IShoppingMallCustomer.ILogin;
  };
  export type Body = IShoppingMallCustomer.ILogin;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/login";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for customer session (shopping_mall_customers table).
 *
 * This API operation enables customers to refresh their authentication session,
 * using the shopping_mall_customers table for user identity validation. It
 * receives a refresh token, validates it for authenticity and expiration, then
 * verifies that the associated customer is in a valid state (status is not
 * suspended/withdrawn and deleted_at is null).
 *
 * Upon successful validation, it issues a new access token and optionally a new
 * refresh token. The endpoint is crucial for maintaining persistent sessions
 * without forcing users to re-enter credentials upon access token expiry. If
 * the refresh token is invalid or the customer’s status/deletion policy is
 * violated per the schema, the operation returns an error and denies the token
 * refresh.
 *
 * Token refresh does not transfer or modify any customer profile data but
 * provides authorized session state as output, always following the
 * IShoppingMallCustomer.IAuthorized DTO structure, directly referencing fields
 * in the schema.
 *
 * This endpoint is always linked with join (registration) and login (initial
 * authentication) endpoints. Each step uses distinct authorizationType markers,
 * and they collectively provide a secure JWT-based auth flow for the customer
 * role. All logic aligns strictly with the shopping_mall_customers table and
 * does not include operations unsupported by its schema.
 *
 * @param props.connection
 * @param props.body JWT refresh token for session renewal; follows project
 *   convention. Only schema-supported fields allowed.
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/refresh
 * @accessor api.functional.auth.customer.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * JWT refresh token for session renewal; follows project convention.
     * Only schema-supported fields allowed.
     */
    body: IShoppingMallCustomer.IRefresh;
  };
  export type Body = IShoppingMallCustomer.IRefresh;
  export type Response = IShoppingMallCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/refresh";
  export const random = (): IShoppingMallCustomer.IAuthorized =>
    typia.random<IShoppingMallCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
