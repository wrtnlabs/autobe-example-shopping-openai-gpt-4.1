import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCustomer } from "../../../structures/IShoppingMallAiBackendCustomer";

/**
 * Register new customer in 'shopping_mall_ai_backend_customers', issuing
 * tokens.
 *
 * Customer registration endpoint for shopping mall service. It creates a new
 * member account, requiring email, phone number, secure password hash, legal
 * name, and (optional) nickname, mirroring the
 * 'shopping_mall_ai_backend_customers' schema. The flow issues JWT tokens, sets
 * 'is_active' and 'is_verified' states, and snapshots 'created_at' and
 * 'updated_at' for audit. Security policies enforce uniqueness of email and
 * phone, password hash integrity, and activity tracking (last_login_at null at
 * registration). New account is returned with authentication tokens for API
 * use. If duplicate, validation fails. The schema links this table to customer
 * withdrawal/session entities for lifecycle management. Error scenarios include
 * unique validation, identity verification failure, or transaction rollback.
 * Related operations: customer login, token refresh, withdrawal. Only customers
 * who complete onboarding will be 'is_active'.
 *
 * Field mapping:
 *
 * - Email, phone_number, password_hash, name from schema for onboarding
 * - Is_active true, is_verified as appropriate
 * - Last_login_at null on join, set on first login
 *
 * All core authn details are present in the schema. Do not create extra fields.
 *
 * @param props.connection
 * @param props.body Customer registration for shopping mall service
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Customer registration for shopping mall service */
    body: IShoppingMallAiBackendCustomer.IJoin;
  };
  export type Body = IShoppingMallAiBackendCustomer.IJoin;
  export type Response = IShoppingMallAiBackendCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/join";
  export const random = (): IShoppingMallAiBackendCustomer.IAuthorized =>
    typia.random<IShoppingMallAiBackendCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate customer ('shopping_mall_ai_backend_customers') and issue
 * tokens.
 *
 * Customer API login endpoint for shopping mall service. Authenticates by
 * validating provided email and password against the
 * 'shopping_mall_ai_backend_customers' table's 'email' and 'password_hash'.
 * Upon valid login, confirms that 'is_active' is true and 'deleted_at' is null.
 * If successful, updates 'last_login_at', issues new JWT access/refresh tokens,
 * and records session via 'shopping_mall_ai_backend_customer_sessions'. Error
 * handling: accounts not found, password mismatch, disabled (is_active=false)
 * or withdrawn (deleted_at set), lockout handling after failed attempts. The
 * login endpoint is core to API auth flows, related to join (registration) and
 * refresh endpoints. All auth info in schema: check email, password_hash,
 * is_active; update last_login_at. No extra schema fields are needed or
 * permitted.
 *
 * @param props.connection
 * @param props.body API customer login parameters
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** API customer login parameters */
    body: IShoppingMallAiBackendCustomer.ILogin;
  };
  export type Body = IShoppingMallAiBackendCustomer.ILogin;
  export type Response = IShoppingMallAiBackendCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/login";
  export const random = (): IShoppingMallAiBackendCustomer.IAuthorized =>
    typia.random<IShoppingMallAiBackendCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh customer authentication tokens using session refresh token (member).
 *
 * Customer API token refresh process (shopping mall service) using the existing
 * refresh token. Validates the session's 'refresh_token' and 'expires_at'
 * against 'shopping_mall_ai_backend_customer_sessions'. If valid and the
 * account is still active/not withdrawn, issues new JWT tokens and updates
 * session records. Invalidates old tokens when appropriate. Returns the
 * authorized customer identity and tokens so APIs may continue without
 * re-login. Error scenarios handled: refresh token expired/terminated, session
 * not found, or user inactive/deleted. Closely related to login endpoint. Every
 * session event is recorded in the schema for audit/compliance. No extra fields
 * allowed. Crucial for securing extended API access. This operation completes
 * the authentication cycle for member-level customer.
 *
 * @param props.connection
 * @param props.body API token refresh parameters (customer)
 * @setHeader token.access Authorization
 *
 * @path /auth/customer/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** API token refresh parameters (customer) */
    body: IShoppingMallAiBackendCustomer.IRefresh;
  };
  export type Body = IShoppingMallAiBackendCustomer.IRefresh;
  export type Response = IShoppingMallAiBackendCustomer.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/customer/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/customer/refresh";
  export const random = (): IShoppingMallAiBackendCustomer.IAuthorized =>
    typia.random<IShoppingMallAiBackendCustomer.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
