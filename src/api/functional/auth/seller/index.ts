import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendSeller } from "../../../structures/IShoppingMallAiBackendSeller";

/**
 * Register a new seller and issue JWT tokens
 * (shopping_mall_ai_backend_sellers).
 *
 * This operation enables a new seller to register and obtain authenticated API
 * access to the system. It is based on the 'shopping_mall_ai_backend_sellers'
 * table. Upon registration, the seller record includes an email (for platform
 * identity), a business_registration_number (for compliance and uniqueness),
 * and personal or business name information. Creation of a seller account
 * immediately results in issuance of JWT tokens for API authentication and
 * business logic workflow. The seller can begin listing products and fulfilling
 * orders after successful registration. Security is enforced through unique
 * email and business registration number per seller. Integration into business
 * onboarding flows, dashboard creation, and audit event logging is supported.
 * This operation is essential for onboarding new merchants.
 *
 * @param props.connection
 * @param props.body Information required to register a new seller business
 *   account.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Information required to register a new seller business account. */
    body: IShoppingMallAiBackendSeller.ICreate;
  };
  export type Body = IShoppingMallAiBackendSeller.ICreate;
  export type Response = IShoppingMallAiBackendSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/join";
  export const random = (): IShoppingMallAiBackendSeller.IAuthorized =>
    typia.random<IShoppingMallAiBackendSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login as an existing seller and receive tokens
 * (shopping_mall_ai_backend_sellers).
 *
 * This authentication endpoint allows an existing seller to log in using their
 * business email and password. The information is checked against the
 * 'shopping_mall_ai_backend_sellers' table with password_hash, is_active, and
 * is_verified status for account eligibility. If authentication is successful
 * and the account is active and verified, the seller receives JWT access and
 * refresh tokens, enabling API-based business operations such as order
 * management, fulfillment, and analytics dashboard access. This operation
 * supports business session management, allows only credential-based logins (no
 * external/OAuth options), and is integral to secure, auditable platform
 * operations. Failed login attempts are logged for security compliance. Related
 * APIs: /auth/seller/join (registration) and /auth/seller/refresh (token
 * renewal).
 *
 * @param props.connection
 * @param props.body Seller's email and password used for login authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Seller's email and password used for login authentication. */
    body: IShoppingMallAiBackendSeller.ILogin;
  };
  export type Body = IShoppingMallAiBackendSeller.ILogin;
  export type Response = IShoppingMallAiBackendSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/login";
  export const random = (): IShoppingMallAiBackendSeller.IAuthorized =>
    typia.random<IShoppingMallAiBackendSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Renew JWT tokens for an active seller session
 * (shopping_mall_ai_backend_sellers).
 *
 * This operation allows an authenticated seller to renew their session tokens
 * using a valid refresh token. Session renewal is only available for sellers
 * whose accounts are active in the 'shopping_mall_ai_backend_sellers' database
 * table. Upon successful validation, the system issues new JWT access and
 * refresh tokens for continued API operations. This endpoint updates the
 * last_login_at field for the seller, maintaining accurate audit and activity
 * tracking. Clients should invoke this operation before token expiry to ensure
 * uninterrupted access to protected API resources. Related endpoints:
 * /auth/seller/login, /auth/seller/join.
 *
 * @param props.connection
 * @param props.body Refresh token to request new session tokens for seller.
 * @setHeader token.access Authorization
 *
 * @path /auth/seller/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token to request new session tokens for seller. */
    body: IShoppingMallAiBackendSeller.IRefresh;
  };
  export type Body = IShoppingMallAiBackendSeller.IRefresh;
  export type Response = IShoppingMallAiBackendSeller.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/seller/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/seller/refresh";
  export const random = (): IShoppingMallAiBackendSeller.IAuthorized =>
    typia.random<IShoppingMallAiBackendSeller.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
