import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceVisitorJoin } from "../../../structures/IAiCommerceVisitorJoin";
import { IAiCommerceVisitor } from "../../../structures/IAiCommerceVisitor";
import { IAiCommerceVisitorRefresh } from "../../../structures/IAiCommerceVisitorRefresh";

/**
 * Register a new member from guest (visitor)—creates ai_commerce_buyer with
 * unique email/password, hands off visitor device for session bridging, and
 * issues buyer JWT. Enforces unique email and password strength.
 *
 * This endpoint enables a guest (visitor) to create a member account on the
 * platform, represented by a new row in ai_commerce_buyer. It requires the
 * guest to provide a unique email, a secure password, and agree to applicable
 * privacy and onboarding terms. If the guest was tracked as an
 * ai_commerce_visitor (browser session/device), the endpoint may bridge that
 * context for future analytics and persistent identity.
 *
 * Upon successful registration, the system issues a temporary authentication
 * token valid as a buyer (member), permitting follow-up onboarding and
 * immediate login. The endpoint enforces uniqueness of email, password strength
 * (minimum length, complexity, etc.), and captures consent for terms and
 * privacy per jurisdictional requirements. If a duplicate email is found or the
 * password does not meet security requirements, returns explicit but secure
 * error codes. If privacy or business consent is not provided, the registration
 * is rejected with compliance reasons.
 *
 * Related flows: Successful completion allows the member to proceed to login
 * and refresh endpoints. Pre-execution of this join is REQUIRED before those
 * flows.
 *
 * Does NOT permit registration for currently-authenticated users, to avoid
 * session confusion or duplicate accounts. All registration and consent events
 * are logged in the audit log (ai_commerce_audit_logs_user).
 *
 * Error handling covers all validation (unique, password, consent), security
 * edge cases, and bridges any known guest (ai_commerce_visitor) context for
 * session merging.
 *
 * @param props.connection
 * @param props.body Guest registration info—requires email address and
 *   password, with explicit consent for terms and privacy. May include
 *   device/session info for analytics bridge. See ai_commerce_buyer for
 *   fields.
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/join
 * @accessor api.functional.auth.visitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Guest registration info—requires email address and password, with
     * explicit consent for terms and privacy. May include device/session
     * info for analytics bridge. See ai_commerce_buyer for fields.
     */
    body: IAiCommerceVisitorJoin.ICreate;
  };
  export type Body = IAiCommerceVisitorJoin.ICreate;
  export type Response = IAiCommerceVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/join";
  export const random = (): IAiCommerceVisitor.IAuthorized =>
    typia.random<IAiCommerceVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a visitor (guest) session—validates refresh token, issues renewed
 * access/refresh tokens for ai_commerce_visitor session. Expires if guest
 * upgrades or session is invalid.
 *
 * This endpoint allows visitors/guests (ai_commerce_visitor) with a valid
 * refresh token to renew temporary access tokens for onboarding or persistent
 * guest/anonymous flows. It checks that the provided refresh token is active,
 * not expired, and associated with the correct guest identity. If the guest
 * session is still eligible, it issues new access/refresh tokens, possibly
 * updating any onboarding context or expiring tokens.
 *
 * Security logic fully validates token authenticity, session timestamp, and
 * ties tokens to guest visitor records as needed. If the session is expired or
 * the visitor has registered/upgraded (i.e., is now a buyer), refresh is denied
 * and the user is prompted to register or login. Severe errors (invalid token,
 * privilege misuse, guest escalation) result in secure errors without exposure
 * of session data.
 *
 * All refresh flows, successful or not, are logged in the compliance/audit
 * trail (ai_commerce_audit_logs_user) for legal and monitoring purposes.
 *
 * This endpoint does not issue tokens for registered users/admins, and is
 * strictly protected against privilege escalation. Related endpoints: join
 * (guest registration).
 *
 * @param props.connection
 * @param props.body Session refresh payload—must include valid refresh token
 *   and visitor id found in ai_commerce_visitor. See session payload
 *   structure.
 * @setHeader token.access Authorization
 *
 * @path /auth/visitor/refresh
 * @accessor api.functional.auth.visitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Session refresh payload—must include valid refresh token and visitor
     * id found in ai_commerce_visitor. See session payload structure.
     */
    body: IAiCommerceVisitorRefresh.ICreate;
  };
  export type Body = IAiCommerceVisitorRefresh.ICreate;
  export type Response = IAiCommerceVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/visitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/visitor/refresh";
  export const random = (): IAiCommerceVisitor.IAuthorized =>
    typia.random<IAiCommerceVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
