import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceSellerProfiles } from "../../../../structures/IAiCommerceSellerProfiles";

/**
 * Create a new seller profile (ai_commerce_seller_profiles table) for a
 * verified seller user.
 *
 * This endpoint creates a new seller profile for an authenticated seller. The
 * seller profile is crucial for establishing a seller's business presence on
 * the platform, including branding, regulatory disclosures, and approval
 * workflow management.
 *
 * Security is enforced so that only authenticated users who have passed
 * onboarding and are escalated to seller status (see ai_commerce_seller) can
 * use this API. The profile contains fields like display_name,
 * profile_metadata, approval_status (defaulted to 'pending' or as per business
 * rules), and optionally suspension_reason.
 *
 * The underlying entity, ai_commerce_seller_profiles, uses user_id (tied to
 * ai_commerce_user_authentications) as a unique reference. Business rules
 * ensure that only one active profile exists per seller and that re-creation
 * after suspension/termination follows compliance workflows.
 *
 * Upon successful creation, the detailed profile is returned. Attempting to
 * create a duplicate seller profile or providing incomplete/invalid business
 * information will result in a validation error. Full creation is audit logged
 * for compliance and future review.
 *
 * @param props.connection
 * @param props.body Seller profile creation payload, including display_name,
 *   metadata, and initial approval status.
 * @path /aiCommerce/seller/sellerProfiles
 * @accessor api.functional.aiCommerce.seller.sellerProfiles.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Seller profile creation payload, including display_name, metadata,
     * and initial approval status.
     */
    body: IAiCommerceSellerProfiles.ICreate;
  };
  export type Body = IAiCommerceSellerProfiles.ICreate;
  export type Response = IAiCommerceSellerProfiles;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/seller/sellerProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/seller/sellerProfiles";
  export const random = (): IAiCommerceSellerProfiles =>
    typia.random<IAiCommerceSellerProfiles>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing seller profile (ai_commerce_seller_profiles table) for the
 * specified sellerProfileId.
 *
 * This API endpoint allows a seller (or platform admin) to update their profile
 * information, such as display_name, profile_metadata, approval_status, and
 * suspension_reason if needed. All field changes are subject to validation
 * according to the database schema constraints, ensuring required fields and
 * uniqueness are preserved.
 *
 * Security and permission checks require that the requesting user be the
 * profile owner (seller) or an admin operator, with actions fully audit logged.
 * Business rules may enforce further restrictions based on approval status or
 * suspension state.
 *
 * On success, the full updated seller profile is returned. If the profile is
 * not found, or if the user is unauthorized or submits invalid data, the system
 * returns appropriate business or validation errors. The update is strictly
 * recorded for audit and compliance purposes.
 *
 * @param props.connection
 * @param props.sellerProfileId Unique identifier for the seller profile being
 *   updated.
 * @param props.body Payload of fields to update in the seller profile,
 *   according to the DB schema.
 * @path /aiCommerce/seller/sellerProfiles/:sellerProfileId
 * @accessor api.functional.aiCommerce.seller.sellerProfiles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the seller profile being updated. */
    sellerProfileId: string & tags.Format<"uuid">;

    /**
     * Payload of fields to update in the seller profile, according to the
     * DB schema.
     */
    body: IAiCommerceSellerProfiles.IUpdate;
  };
  export type Body = IAiCommerceSellerProfiles.IUpdate;
  export type Response = IAiCommerceSellerProfiles;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/seller/sellerProfiles/:sellerProfileId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/seller/sellerProfiles/${encodeURIComponent(props.sellerProfileId ?? "null")}`;
  export const random = (): IAiCommerceSellerProfiles =>
    typia.random<IAiCommerceSellerProfiles>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerProfileId")(() =>
        typia.assert(props.sellerProfileId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete (hard remove) a seller profile for the specified
 * sellerProfileId.
 *
 * This API operation performs a hard deletion of a seller profile from the
 * ai_commerce_seller_profiles table, identified by sellerProfileId. No soft
 * delete exists for this entity, so deletion is irreversible and data is fully
 * removed from the database. This API can only be used by the owning seller or
 * an administrator following explicit business rules and audit protocols.
 *
 * Before deletion, the system checks for related dependencies to prevent
 * referential integrity violations (e.g., linked stores, analytics).
 * Authorization enforcement is strict and every delete operation is audit
 * logged for regulatory and legal compliance.
 *
 * If the profile exists and is deletable, the operation completes without
 * returning a body. Errors are raised if the profile is not found, the user is
 * unauthorized, or dependent references prevent deletion. This endpoint is not
 * used for soft-deletion scenarios.
 *
 * @param props.connection
 * @param props.sellerProfileId Unique identifier for the seller profile to
 *   delete (UUID).
 * @path /aiCommerce/seller/sellerProfiles/:sellerProfileId
 * @accessor api.functional.aiCommerce.seller.sellerProfiles.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the seller profile to delete (UUID). */
    sellerProfileId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/seller/sellerProfiles/:sellerProfileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/seller/sellerProfiles/${encodeURIComponent(props.sellerProfileId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerProfileId")(() =>
        typia.assert(props.sellerProfileId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
