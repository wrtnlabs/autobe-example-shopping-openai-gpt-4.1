import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceProductContent } from "../../../../../structures/IAiCommerceProductContent";
import { IPageIAiCommerceProductContent } from "../../../../../structures/IPageIAiCommerceProductContent";

/**
 * Create a new structured content record for a given product in
 * ai_commerce_product_contents.
 *
 * Adds a new structured business content record to a product based on a POSTed
 * IAiCommerceProductContent.ICreate DTO. The request captures required fields
 * such as content_type, format, locale, content_body, and display_order.
 * Sellers can thus manage multiple languages, detail blocks, or technical
 * instructions under a product.
 *
 * Admin/seller privileges are required for this action, and business logic
 * checks for duplicate content types/locale per product. The operation ensures
 * that the product is active and not locked. On success, returns the newly
 * created entity for immediate UI rendering. Validation/enforcement of unique
 * constraints and field lengths must follow the schema. Error scenarios cover
 * access denied, failed validation, or immutable product state.
 *
 * @param props.connection
 * @param props.productId ID of the product to which content will be added
 * @param props.body New content record data for the target product
 * @path /aiCommerce/seller/products/:productId/contents
 * @accessor api.functional.aiCommerce.seller.products.contents.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** ID of the product to which content will be added */
    productId: string & tags.Format<"uuid">;

    /** New content record data for the target product */
    body: IAiCommerceProductContent.ICreate;
  };
  export type Body = IAiCommerceProductContent.ICreate;
  export type Response = IAiCommerceProductContent;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/seller/products/:productId/contents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/seller/products/${encodeURIComponent(props.productId ?? "null")}/contents`;
  export const random = (): IAiCommerceProductContent =>
    typia.random<IAiCommerceProductContent>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate content records for a product from
 * ai_commerce_product_contents.
 *
 * Retrieves a filtered and paginated list of product content records for a
 * specified product. The PATCH method with request body allows complex search
 * queries: filter by content_type, locale, text, or sort_order as per
 * IAiCommerceProductContent.IRequest DTO specification.
 *
 * Accessible to sellers and admins for their own products, this endpoint
 * supports listing descriptions, specs, and other structured content.
 * Pagination rules and search term filtering are applied, limiting result size
 * per business requirements and performance constraints. Security requires
 * seller ownership or admin rights, and logic validates product existence and
 * permissions.
 *
 * The response delivers a page object (IPageIAiCommerceProductContent) with
 * pagination metadata and summary content for display or editing UIs. Errors
 * for access denied or product not found are covered.
 *
 * @param props.connection
 * @param props.productId Target product's ID for searching content records
 * @param props.body Search criteria and pagination options for content record
 *   filtering
 * @path /aiCommerce/seller/products/:productId/contents
 * @accessor api.functional.aiCommerce.seller.products.contents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target product's ID for searching content records */
    productId: string & tags.Format<"uuid">;

    /** Search criteria and pagination options for content record filtering */
    body: IAiCommerceProductContent.IRequest;
  };
  export type Body = IAiCommerceProductContent.IRequest;
  export type Response = IPageIAiCommerceProductContent;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/seller/products/:productId/contents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/seller/products/${encodeURIComponent(props.productId ?? "null")}/contents`;
  export const random = (): IPageIAiCommerceProductContent =>
    typia.random<IPageIAiCommerceProductContent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific content record for a product from
 * ai_commerce_product_contents.
 *
 * Fetches a single structured business content entry for a product, which could
 * be a marketing description, instruction, or technical detail, as outlined in
 * the ai_commerce_product_contents table. Path parameters specify the parent
 * product and content record.
 *
 * Returns the complete entity with fields including id, product_id,
 * content_type, format, locale, content_body, and display_order. Security
 * requires seller ownership or admin privileges for modification; public access
 * is allowed for published content per business logic. Error handling covers
 * not found, access denied, or deleted records. No request body is required.
 *
 * @param props.connection
 * @param props.productId Parent product for the content record
 * @param props.contentId Unique ID for the content record
 * @path /aiCommerce/seller/products/:productId/contents/:contentId
 * @accessor api.functional.aiCommerce.seller.products.contents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Parent product for the content record */
    productId: string & tags.Format<"uuid">;

    /** Unique ID for the content record */
    contentId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceProductContent;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/seller/products/:productId/contents/:contentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/seller/products/${encodeURIComponent(props.productId ?? "null")}/contents/${encodeURIComponent(props.contentId ?? "null")}`;
  export const random = (): IAiCommerceProductContent =>
    typia.random<IAiCommerceProductContent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("contentId")(() => typia.assert(props.contentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific product content record in ai_commerce_product_contents.
 *
 * Permits a seller or admin to fully update an existing structured product
 * content record (such as a marketing description, usage instruction, or
 * technical spec). The IAiCommerceProductContent.IUpdate DTO request body
 * allows field-by-field replacement. Path parameters specify the product and
 * the target content.
 *
 * Business logic validates that the product/content pair exists and is
 * modifiable (not locked or published, if such restrictions exist). On success,
 * a refreshed entity is returned to the client. Permission checks enforce that
 * only the product owner or admin can update content. Validation covers
 * uniqueness, required fields, and correct localization. Errors include not
 * found, forbidden, or immutable state failures.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for the content record
 * @param props.contentId Target content record's unique identifier
 * @param props.body Field data for updating a product content record
 * @path /aiCommerce/seller/products/:productId/contents/:contentId
 * @accessor api.functional.aiCommerce.seller.products.contents.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the parent product for the content record */
    productId: string & tags.Format<"uuid">;

    /** Target content record's unique identifier */
    contentId: string & tags.Format<"uuid">;

    /** Field data for updating a product content record */
    body: IAiCommerceProductContent.IUpdate;
  };
  export type Body = IAiCommerceProductContent.IUpdate;
  export type Response = IAiCommerceProductContent;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/seller/products/:productId/contents/:contentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/seller/products/${encodeURIComponent(props.productId ?? "null")}/contents/${encodeURIComponent(props.contentId ?? "null")}`;
  export const random = (): IAiCommerceProductContent =>
    typia.random<IAiCommerceProductContent>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("contentId")(() => typia.assert(props.contentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a product content entity associated with a specific product in
 * ai_commerce_product_contents.
 *
 * The DELETE /products/{productId}/contents/{contentId} endpoint allows a
 * seller or admin to remove a single product content entity (such as a detailed
 * description, technical spec, or how-to guide) associated with the specified
 * product.
 *
 * Security is enforced based on product ownership; only the seller who owns the
 * product or an admin with global privileges can execute this operation.
 *
 * Upon invocation, the service identifies the target product and verifies the
 * contentId exists and is associated with the productId. The content record is
 * marked as deleted in the database (soft deletion performed by updating the
 * deleted_at timestamp rather than physical removal), maintaining a full audit
 * trail for compliance and recovery purposes.
 *
 * This operation logs a compliance record, capturing a snapshot of the content
 * before deletion for legal, regulatory, and dispute evidence. If the content
 * is referenced by downstream flows such as SEO or merchandising, associated
 * services are notified of the deletion event for real-time update
 * propagation.
 *
 * If the resource does not exist or is already deleted, the operation returns
 * an appropriate error. The endpoint does not accept a request body and does
 * not return any response body upon successful execution, returning a 204 No
 * Content status code. Any errors trigger clearly defined error responses
 * indicating missing resources or unauthorized action.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the target product whose content
 *   is to be deleted.
 * @param props.contentId Unique identifier of the product content entity to
 *   delete.
 * @path /aiCommerce/seller/products/:productId/contents/:contentId
 * @accessor api.functional.aiCommerce.seller.products.contents.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the target product whose content is to be
     * deleted.
     */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the product content entity to delete. */
    contentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/seller/products/:productId/contents/:contentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/seller/products/${encodeURIComponent(props.productId ?? "null")}/contents/${encodeURIComponent(props.contentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("contentId")(() => typia.assert(props.contentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
