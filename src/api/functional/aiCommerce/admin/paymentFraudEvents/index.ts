import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommercePaymentFraudEvent } from "../../../../structures/IAiCommercePaymentFraudEvent";
import { IPageIAiCommercePaymentFraudEvent } from "../../../../structures/IPageIAiCommercePaymentFraudEvent";

/**
 * Insert a new payment fraud audit event entry into
 * ai_commerce_payment_fraud_events.
 *
 * Allows compliance or security teams to log a new fraud event into the
 * platform audit trail, either due to externally detected fraud, review team
 * identification, or API-driven risk triggers. Accepted data includes the fraud
 * event code, entity type/ID, status, detailed description, and detection
 * timestamp. All required validations, business process triggers, and
 * timestamping must be strictly enforced.
 *
 * This is a privileged administrative operation. Public or regular user-facing
 * flows must never create fraud audit events. Entries are immutable once
 * created and form the source of truth for audit, compliance, and
 * compensation/recovery actions.
 *
 * @param props.connection
 * @param props.body Fraud event details for creation, including event code,
 *   entity type, IDs, description, status, and detection time.
 * @path /aiCommerce/admin/paymentFraudEvents
 * @accessor api.functional.aiCommerce.admin.paymentFraudEvents.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Fraud event details for creation, including event code, entity type,
     * IDs, description, status, and detection time.
     */
    body: IAiCommercePaymentFraudEvent.ICreate;
  };
  export type Body = IAiCommercePaymentFraudEvent.ICreate;
  export type Response = IAiCommercePaymentFraudEvent;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/paymentFraudEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentFraudEvents";
  export const random = (): IAiCommercePaymentFraudEvent =>
    typia.random<IAiCommercePaymentFraudEvent>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate payment fraud events from
 * ai_commerce_payment_fraud_events.
 *
 * This operation enables fraud investigators, compliance teams, and admin users
 * to retrieve a filtered, paginated list of detected fraud events associated
 * with payments, coupons, deposits, or mileage. Query parameters allow
 * filtering by fraud event code (e.g., MULTI_REDEMPTION, ABUSE), entity type
 * (payment, coupon, deposit, mileage, transaction), status (detected,
 * under_review, confirmed, dismissed), time range, and search by pattern in the
 * description field.
 *
 * The ai_commerce_payment_fraud_events table is append-only, with each entry
 * capturing critical forensic data for audit, reporting, legal proceedings, and
 * platform abuse monitoring.
 *
 * This API is intended for back-office staff with elevated privileges; client
 * access should be strictly authenticated and logged. Outputs are suitable for
 * compliance reporting, fraud dashboard integration, and operational analytics,
 * supporting business workflow and regulatory obligations.
 *
 * @param props.connection
 * @param props.body Advanced search, filter, and pagination criteria for
 *   finding fraud events.
 * @path /aiCommerce/admin/paymentFraudEvents
 * @accessor api.functional.aiCommerce.admin.paymentFraudEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Advanced search, filter, and pagination criteria for finding fraud
     * events.
     */
    body: IAiCommercePaymentFraudEvent.IRequest;
  };
  export type Body = IAiCommercePaymentFraudEvent.IRequest;
  export type Response = IPageIAiCommercePaymentFraudEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/paymentFraudEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentFraudEvents";
  export const random = (): IPageIAiCommercePaymentFraudEvent =>
    typia.random<IPageIAiCommercePaymentFraudEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a payment fraud event log record by its unique ID from
 * ai_commerce_payment_fraud_events.
 *
 * Returns a single payment fraud event record from the
 * ai_commerce_payment_fraud_events audit table, identified by
 * paymentFraudEventId. Used by back-office or admin users for deep dive
 * analysis, incident investigation, or compliance export requirements.
 *
 * The ai_commerce_payment_fraud_events entity is immutable (never manually
 * edited or deleted), and stores complete details of
 * rule-based/manual/AI-detected fraud, including event codes, entity type,
 * description, timestamps, and resolution state. This endpoint facilitates
 * high-trust workflows, such as regulatory filings, business analytics, or
 * legal evidence extraction.
 *
 * Strict role-based access control must be applied. The returned object
 * contains all event fields as defined in the schema.
 *
 * @param props.connection
 * @param props.paymentFraudEventId Unique identifier for the target payment
 *   fraud event audit record.
 * @path /aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId
 * @accessor api.functional.aiCommerce.admin.paymentFraudEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target payment fraud event audit record. */
    paymentFraudEventId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommercePaymentFraudEvent;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentFraudEvents/${encodeURIComponent(props.paymentFraudEventId ?? "null")}`;
  export const random = (): IAiCommercePaymentFraudEvent =>
    typia.random<IAiCommercePaymentFraudEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentFraudEventId")(() =>
        typia.assert(props.paymentFraudEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the status or business fields of a payment fraud event audit record.
 *
 * Updates an existing payment fraud event, such as marking an event as
 * confirmed, dismissed, resolved, or updating its resolution details. This
 * operation is strictly limited to back-office, security, or compliance
 * administrators for correcting audit records, closing out fraud
 * investigations, or supporting business/compliance reporting. It performs full
 * validation of the update and overwrites only permitted fields such as status,
 * reviewed_at, description, or resolution note.
 *
 * As ai_commerce_payment_fraud_events is an immutable audit log for most
 * workflows, manual update privileges should be stringently logged and
 * monitored in production. Regular user interfaces must never expose this
 * mutation.
 *
 * @param props.connection
 * @param props.paymentFraudEventId Unique ID of the payment fraud event to
 *   update.
 * @param props.body Fields to update in the fraud event record, such as status,
 *   review note, or event details.
 * @path /aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId
 * @accessor api.functional.aiCommerce.admin.paymentFraudEvents.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique ID of the payment fraud event to update. */
    paymentFraudEventId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the fraud event record, such as status, review
     * note, or event details.
     */
    body: IAiCommercePaymentFraudEvent.IUpdate;
  };
  export type Body = IAiCommercePaymentFraudEvent.IUpdate;
  export type Response = IAiCommercePaymentFraudEvent;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/paymentFraudEvents/${encodeURIComponent(props.paymentFraudEventId ?? "null")}`;
  export const random = (): IAiCommercePaymentFraudEvent =>
    typia.random<IAiCommercePaymentFraudEvent>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentFraudEventId")(() =>
        typia.assert(props.paymentFraudEventId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a payment fraud event audit record by its ID from
 * ai_commerce_payment_fraud_events.
 *
 * This endpoint executes a permanent, hard deletion of a payment fraud event
 * audit entry, identified by paymentFraudEventId. Deletion is restricted to
 * senior compliance/admin staff for rare cases where legal, privacy, or
 * evidence-compromising circumstances arise (i.e., GDPR right-to-be-forgotten,
 * proven false positive). The operation ensures proper logging and should be
 * auditable at every step.
 *
 * Under normal operational and compliance policy, audit log entries should not
 * be deleted. Forensic, reporting, and compensation/recovery logic rely on
 * complete audit trails. Non-admin or regular user actions must never expose
 * this operation.
 *
 * @param props.connection
 * @param props.paymentFraudEventId Unique ID of the payment fraud event record
 *   to be deleted.
 * @path /aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId
 * @accessor api.functional.aiCommerce.admin.paymentFraudEvents.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique ID of the payment fraud event record to be deleted. */
    paymentFraudEventId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/paymentFraudEvents/:paymentFraudEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentFraudEvents/${encodeURIComponent(props.paymentFraudEventId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentFraudEventId")(() =>
        typia.assert(props.paymentFraudEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
