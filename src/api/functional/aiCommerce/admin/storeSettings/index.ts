import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceStoreSetting } from "../../../../structures/IAiCommerceStoreSetting";
import { IPageIAiCommerceStoreSetting } from "../../../../structures/IPageIAiCommerceStoreSetting";

/**
 * Create a new store setting (ai_commerce_store_settings).
 *
 * Create a new store setting for a given store, specifying key configuration
 * details such as key, value, and metadata. Business rules enforce that each
 * setting key must be unique within its store and that all required fields
 * (store_id, key, value) are present and correctly formatted according to the
 * system configuration policy.
 *
 * Only users with admin role are allowed to create settings via this operation.
 * Upon success, an audit log entry is generated for compliance and forensic
 * traceability.
 *
 * Error scenarios include attempts to duplicate a key for a store, invalid
 * format submissions, and lack of permission. All setting creation events are
 * immutable and tracked as prescribed by business compliance requirements.
 *
 * @param props.connection
 * @param props.body Information for creation of store setting (must specify
 *   store_id, key, value, and any business-required metadata).
 * @path /aiCommerce/admin/storeSettings
 * @accessor api.functional.aiCommerce.admin.storeSettings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information for creation of store setting (must specify store_id,
     * key, value, and any business-required metadata).
     */
    body: IAiCommerceStoreSetting.ICreate;
  };
  export type Body = IAiCommerceStoreSetting.ICreate;
  export type Response = IAiCommerceStoreSetting;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/storeSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/storeSettings";
  export const random = (): IAiCommerceStoreSetting =>
    typia.random<IAiCommerceStoreSetting>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of store settings
 * (ai_commerce_store_settings).
 *
 * Retrieve a filtered and paginated list of store settings for the commerce
 * platform. This API supports admin-level oversight and seller-level
 * self-management, enabling advanced search, filtering by store, active status,
 * and configuration parameter values.
 *
 * Each returned result includes the unique setting ID, belonging store,
 * configuration key, value, status, and timestamps for creation and last
 * update. Sellers are limited to viewing their own stores' settings, while
 * admins can view all. Audit logging is enabled for all accesses via this
 * endpoint, in compliance with platform governance and evidentiary rules
 * referenced in the business requirements.
 *
 * Security is enforced through role-based access such that only authorized
 * admins or store owners can query this list. Performance is optimized through
 * indexed search on store_id, key, and active status. Errors (such as filter
 * collisions or unauthorized access) are clearly returned with actionable error
 * codes.
 *
 * @param props.connection
 * @param props.body Search filters, pagination, and sorting options for store
 *   settings list retrieval.
 * @path /aiCommerce/admin/storeSettings
 * @accessor api.functional.aiCommerce.admin.storeSettings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search filters, pagination, and sorting options for store settings
     * list retrieval.
     */
    body: IAiCommerceStoreSetting.IRequest;
  };
  export type Body = IAiCommerceStoreSetting.IRequest;
  export type Response = IPageIAiCommerceStoreSetting.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/storeSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/storeSettings";
  export const random = (): IPageIAiCommerceStoreSetting.ISummary =>
    typia.random<IPageIAiCommerceStoreSetting.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific store setting
 * (ai_commerce_store_settings).
 *
 * Retrieve full details for a single store setting by its unique identifier.
 * Includes all columns (id, store_id, key, value, created_at, updated_at,
 * deleted_at) and relation references (linked store if required).
 *
 * Permissions are strictly enforced so that sellers may only access settings
 * associated with their own stores, while admins have unrestricted access. The
 * API is intended for use in admin or store owner dashboards, configuration
 * debugging, or compliance reviews. Errors are returned for invalid IDs or
 * forbidden access according to platform compliance rules.
 *
 * All accesses are audit-logged for governance and traceability, supporting the
 * evidentiary protocols set forth in the business and compliance documents.
 *
 * @param props.connection
 * @param props.storeSettingId Unique identifier of the target store setting
 *   (UUID).
 * @path /aiCommerce/admin/storeSettings/:storeSettingId
 * @accessor api.functional.aiCommerce.admin.storeSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target store setting (UUID). */
    storeSettingId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceStoreSetting;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/storeSettings/:storeSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/storeSettings/${encodeURIComponent(props.storeSettingId ?? "null")}`;
  export const random = (): IAiCommerceStoreSetting =>
    typia.random<IAiCommerceStoreSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storeSettingId")(() => typia.assert(props.storeSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a store setting by ID (ai_commerce_store_settings).
 *
 * Update an existing store setting for any store, identified by its unique
 * storeSettingId. Supported fields for update include configuration key, value,
 * and supporting metadata. Each update is validated to ensure that the updated
 * key remains unique within its store and that all values conform to business
 * policy.
 *
 * The operation is strictly limited to admin users, with full auditability for
 * each change. Updates produce immutable audit trail entries in line with
 * governance requirements. Sellers may not use this operation as platform
 * configuration settings are admin-defined for integrity.
 *
 * Error handling includes forbidden attempts, invalid IDs, or format
 * violations. Successful updates synchronize configuration across related
 * subsystems per compliance mandates.
 *
 * @param props.connection
 * @param props.storeSettingId Unique identifier of the target store setting
 *   (UUID).
 * @param props.body Updated store setting data, such as key, value, or status.
 *   Must conform with unique constraints and configuration policies.
 * @path /aiCommerce/admin/storeSettings/:storeSettingId
 * @accessor api.functional.aiCommerce.admin.storeSettings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target store setting (UUID). */
    storeSettingId: string & tags.Format<"uuid">;

    /**
     * Updated store setting data, such as key, value, or status. Must
     * conform with unique constraints and configuration policies.
     */
    body: IAiCommerceStoreSetting.IUpdate;
  };
  export type Body = IAiCommerceStoreSetting.IUpdate;
  export type Response = IAiCommerceStoreSetting;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/storeSettings/:storeSettingId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/storeSettings/${encodeURIComponent(props.storeSettingId ?? "null")}`;
  export const random = (): IAiCommerceStoreSetting =>
    typia.random<IAiCommerceStoreSetting>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storeSettingId")(() => typia.assert(props.storeSettingId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) a store setting by ID (ai_commerce_store_settings).
 *
 * Permanently delete a store setting by its unique storeSettingId. This
 * operation completely removes the record from the database, as no soft delete
 * field is present.
 *
 * Admin role is required and all deletions are audit-logged. Business
 * safeguards ensure that the configuration is not in use or required for active
 * business flows before permitting deletion. Attempts to delete settings in use
 * or where access is forbidden will be rejected with informative error
 * messages, fulfilling data integrity standards and compliance requirements.
 *
 * Error handling includes invalid ID, permission denial, and attempts to delete
 * active/locked configuration. Successful deletions report confirmation and are
 * traceable via audit logs for legal/conformance reviews.
 *
 * @param props.connection
 * @param props.storeSettingId Unique identifier of the store setting to delete
 *   (UUID).
 * @path /aiCommerce/admin/storeSettings/:storeSettingId
 * @accessor api.functional.aiCommerce.admin.storeSettings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the store setting to delete (UUID). */
    storeSettingId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/storeSettings/:storeSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/storeSettings/${encodeURIComponent(props.storeSettingId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storeSettingId")(() => typia.assert(props.storeSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
