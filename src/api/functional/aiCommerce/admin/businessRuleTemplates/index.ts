import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceBusinessRuleTemplates } from "../../../../structures/IAiCommerceBusinessRuleTemplates";
import { IAiCommerceBusinessRuleTemplate } from "../../../../structures/IAiCommerceBusinessRuleTemplate";
import { IPageIAiCommerceBusinessRuleTemplate } from "../../../../structures/IPageIAiCommerceBusinessRuleTemplate";

/**
 * Create a new business rule template (ai_commerce_business_rule_templates).
 *
 * Create a new business rule template by specifying the required code, name,
 * version, rules/configuration data, business status, and timestamps. Business
 * rule templates can be attached to channels, sections, or categories, and are
 * versioned for audit and compliance. Only administrators are authorized to
 * create new rule templates, and each template code must be unique per version.
 * This operation collects all necessary properties (code, name, version,
 * template_data, business_status, created_at, updated_at) as defined in the
 * ai_commerce_business_rule_templates schema.
 *
 * Security is enforced such that only users with the admin role are permitted
 * to call this endpoint. Upon creation, the template becomes available for
 * linking to channel/section/category configurations.
 *
 * Validation rules include uniqueness of code/version and non-null config
 * fields. Errors occur for missing required fields or conflicts in code/version
 * pairs.
 *
 * @param props.connection
 * @param props.body Business rule template creation payload. Required: code,
 *   name, version, template_data, business_status, created_at, updated_at.
 * @path /aiCommerce/admin/businessRuleTemplates
 * @accessor api.functional.aiCommerce.admin.businessRuleTemplates.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Business rule template creation payload. Required: code, name,
     * version, template_data, business_status, created_at, updated_at.
     */
    body: IAiCommerceBusinessRuleTemplates.ICreate;
  };
  export type Body = IAiCommerceBusinessRuleTemplates.ICreate;
  export type Response = IAiCommerceBusinessRuleTemplates;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/businessRuleTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/businessRuleTemplates";
  export const random = (): IAiCommerceBusinessRuleTemplates =>
    typia.random<IAiCommerceBusinessRuleTemplates>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve business rule templates (paginated) from
 * ai_commerce_business_rule_templates.
 *
 * Retrieves a paginated, filterable, and sortable list of business rule
 * templates from the ai_commerce_business_rule_templates table. The response
 * provides summary metadata for each template, including code, version,
 * business status, creation dates, and approval flows, facilitating management
 * by platform administrators.
 *
 * Authorization is restricted to admin users to protect core business/process
 * logic. All accesses are logged for compliance. Searching can be applied by
 * template code, status, version, or business context fields. Sorting and
 * pagination are supported as per CMS-integrated UI requirements.
 *
 * Failures due to invalid filters or pagination return actionable error
 * messages. This list operation is commonly paired with template detail,
 * create, update, and delete endpoints for full template lifecycle management.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination settings for business rule
 *   templates.
 * @path /aiCommerce/admin/businessRuleTemplates
 * @accessor api.functional.aiCommerce.admin.businessRuleTemplates.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria and pagination settings for business rule templates. */
    body: IAiCommerceBusinessRuleTemplate.IRequest;
  };
  export type Body = IAiCommerceBusinessRuleTemplate.IRequest;
  export type Response = IPageIAiCommerceBusinessRuleTemplate.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/businessRuleTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/businessRuleTemplates";
  export const random = (): IPageIAiCommerceBusinessRuleTemplate.ISummary =>
    typia.random<IPageIAiCommerceBusinessRuleTemplate.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a business rule template by ruleId from
 * ai_commerce_business_rule_templates.
 *
 * Fetches the detailed information for a business rule template, including
 * code, version, serialized rule logic, statuses, and audit fields, based on
 * the provided ruleId path parameter. The operation enables administrator users
 * to fully inspect the template's configuration, business logic, and workflow
 * context before making edits or changes.
 *
 * Authorization is strictly reserved for admins to safeguard process
 * configuration. All accesses are audit-logged. Attempting to retrieve a
 * non-existent or inaccessible ruleId will result in a clear error message.
 * Typically paired with create, update, and delete operations for comprehensive
 * template management.
 *
 * @param props.connection
 * @param props.ruleId The UUID of the business rule template to fetch.
 * @path /aiCommerce/admin/businessRuleTemplates/:ruleId
 * @accessor api.functional.aiCommerce.admin.businessRuleTemplates.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the business rule template to fetch. */
    ruleId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceBusinessRuleTemplate;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/businessRuleTemplates/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/businessRuleTemplates/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IAiCommerceBusinessRuleTemplate =>
    typia.random<IAiCommerceBusinessRuleTemplate>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing business rule template
 * (ai_commerce_business_rule_templates).
 *
 * Update a business rule template by specifying its ruleId and providing new
 * configuration values for name, template data, status, or version. The
 * ai_commerce_business_rule_templates schema governs the modifiable properties
 * and requires all updates to be audit-logged. Only administrators can perform
 * updates, and the ruleId must be valid and correspond to an existing record.
 *
 * This operation enforces data validation on editable fields, ensures
 * uniqueness of (code, version), and maintains audit trails according to
 * business compliance needs. Errors may occur if the ruleId is invalid, the
 * template does not exist, or updates violate uniqueness constraints.
 *
 * @param props.connection
 * @param props.ruleId Unique identifier of the business rule template to
 *   update.
 * @param props.body Update details for the business rule template.
 * @path /aiCommerce/admin/businessRuleTemplates/:ruleId
 * @accessor api.functional.aiCommerce.admin.businessRuleTemplates.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the business rule template to update. */
    ruleId: string & tags.Format<"uuid">;

    /** Update details for the business rule template. */
    body: IAiCommerceBusinessRuleTemplates.IUpdate;
  };
  export type Body = IAiCommerceBusinessRuleTemplates.IUpdate;
  export type Response = IAiCommerceBusinessRuleTemplates;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/businessRuleTemplates/:ruleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/businessRuleTemplates/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IAiCommerceBusinessRuleTemplates =>
    typia.random<IAiCommerceBusinessRuleTemplates>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a business rule template permanently
 * (ai_commerce_business_rule_templates).
 *
 * Delete an existing business rule template by providing the ruleId. This
 * operation removes the template record from the database, and is limited to
 * administrative users to ensure compliance and avoid accidental loss of
 * critical business logic. The ruleId parameter must reference a valid
 * template. The operation performs a hard delete—template records are
 * permanently removed and cannot be recovered. The deletion is disallowed if
 * the template is referenced by a live configuration.
 *
 * Operation is fully audit-logged, and errors are returned if the template is
 * referenced elsewhere or the ruleId is invalid.
 *
 * @param props.connection
 * @param props.ruleId Unique identifier for the business rule template to
 *   delete.
 * @path /aiCommerce/admin/businessRuleTemplates/:ruleId
 * @accessor api.functional.aiCommerce.admin.businessRuleTemplates.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the business rule template to delete. */
    ruleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/businessRuleTemplates/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/businessRuleTemplates/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
