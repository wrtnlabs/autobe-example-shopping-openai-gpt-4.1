import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCategoryTemplate } from "../../../../structures/IAiCommerceCategoryTemplate";
import { IPageIAiCommerceCategoryTemplate } from "../../../../structures/IPageIAiCommerceCategoryTemplate";

/**
 * Create a new category template in ai_commerce_category_templates.
 *
 * Creates and registers a new reusable category template in
 * ai_commerce_category_templates. The operation expects a payload containing
 * all required template metadata and data structure (typically including name,
 * code, serialized category tree, is_default flag, and business status).
 *
 * Strict validation is applied for template naming, code uniqueness, serialized
 * structure, and business rule compliance. On success, a new template entry is
 * created with all audit fields populated for evidence-preserving compliance.
 *
 * This endpoint is restricted to administrative users due to its impact on
 * global category setup. It returns the complete created template entity,
 * including all fields for immediate use or further editing.
 *
 * If the creation request attempts to violate unique code constraints or submit
 * malformed template data, the server returns an error message with correction
 * guidance.
 *
 * @param props.connection
 * @param props.body The creation data for a new category template.
 * @path /aiCommerce/admin/categoryTemplates
 * @accessor api.functional.aiCommerce.admin.categoryTemplates.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** The creation data for a new category template. */
    body: IAiCommerceCategoryTemplate.ICreate;
  };
  export type Body = IAiCommerceCategoryTemplate.ICreate;
  export type Response = IAiCommerceCategoryTemplate;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/categoryTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/categoryTemplates";
  export const random = (): IAiCommerceCategoryTemplate =>
    typia.random<IAiCommerceCategoryTemplate>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search category templates (paginated, filterable) from
 * ai_commerce_category_templates.
 *
 * Retrieves a paginated and filterable list of all category templates in the
 * ai_commerce_category_templates table. Administrators can search by name,
 * code, business status, or creation/update timestamps. This enhances
 * large-scale management of reusable category hierarchies and accelerates
 * onboarding of new channels or merchants.
 *
 * Security is strictly enforcedâ€”only admins can access this endpoint, ensuring
 * that only privileged users can see, review, or repurpose organization
 * templates across projects. Audit logs are maintained for all accesses of this
 * API for compliance review.
 *
 * Filtering supports advanced use-cases including partial name/code match,
 * business status selection, and sorting by created/updated times, designed to
 * integrate seamlessly with the CMS or backoffice UI.
 *
 * Error handling returns clear messages for invalid pagination, unsupported
 * search criteria, or sorting constraints. The response structure includes
 * pagination metadata and a summary of template state for each entry.
 *
 * @param props.connection
 * @param props.body Criteria for searching, filtering, and paginating category
 *   templates.
 * @path /aiCommerce/admin/categoryTemplates
 * @accessor api.functional.aiCommerce.admin.categoryTemplates.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Criteria for searching, filtering, and paginating category templates. */
    body: IAiCommerceCategoryTemplate.IRequest;
  };
  export type Body = IAiCommerceCategoryTemplate.IRequest;
  export type Response = IPageIAiCommerceCategoryTemplate.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/categoryTemplates",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/categoryTemplates";
  export const random = (): IPageIAiCommerceCategoryTemplate.ISummary =>
    typia.random<IPageIAiCommerceCategoryTemplate.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details for a specific category template from
 * ai_commerce_category_templates.
 *
 * Fetches the complete detail and configuration data for a category template
 * referenced by templateId, including business rules, JSON-encoded hierarchical
 * structure, approval status, and timestamps from
 * ai_commerce_category_templates.
 *
 * This endpoint enables administrator roles to view and verify a category
 * template before applying, editing, or deleting, supporting business rule
 * enforcement, change review, and audit workflows for category organization.
 *
 * The API is only accessible by admin users; authorization is enforced to
 * prevent exposure of internal configuration logic. Full error handling is
 * provided for invalid or non-existent IDs, and audit logs are generated for
 * all access runs. This is typically paired with update or erase operations in
 * API workflows.
 *
 * @param props.connection
 * @param props.templateId The UUID of the category template to retrieve.
 * @path /aiCommerce/admin/categoryTemplates/:templateId
 * @accessor api.functional.aiCommerce.admin.categoryTemplates.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the category template to retrieve. */
    templateId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceCategoryTemplate;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/categoryTemplates/:templateId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/categoryTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): IAiCommerceCategoryTemplate =>
    typia.random<IAiCommerceCategoryTemplate>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a category template by templateId in ai_commerce_category_templates.
 *
 * Modifies an existing category template in ai_commerce_category_templates,
 * identified by the templateId path parameter. The request body contains the
 * update data for the template, such as changes to name, code, tree structure,
 * or status fields, in compliance with business rules and schema constraints.
 *
 * The operation enforces strict admin-only access and is designed for
 * multi-stage review and approval workflows. All modifications update the
 * updated_at field and retain the audit trail, supporting rollback and legal
 * compliance.
 *
 * If the update request would result in a code conflict, invalid template tree,
 * or unsupported status/value, the operation fails with descriptive error
 * messages. This endpoint is typically paired with get (detail) or erase
 * (delete) ops in platform settings UIs.
 *
 * @param props.connection
 * @param props.templateId The UUID of the category template to update.
 * @param props.body The update information for the category template.
 * @path /aiCommerce/admin/categoryTemplates/:templateId
 * @accessor api.functional.aiCommerce.admin.categoryTemplates.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The UUID of the category template to update. */
    templateId: string & tags.Format<"uuid">;

    /** The update information for the category template. */
    body: IAiCommerceCategoryTemplate.IUpdate;
  };
  export type Body = IAiCommerceCategoryTemplate.IUpdate;
  export type Response = IAiCommerceCategoryTemplate;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/categoryTemplates/:templateId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/categoryTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): IAiCommerceCategoryTemplate =>
    typia.random<IAiCommerceCategoryTemplate>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a category template by templateId
 * (ai_commerce_category_templates).
 *
 * Soft deletes a category template specified by templateId from the
 * ai_commerce_category_templates table. This logical removal marks the template
 * as deleted via the deleted_at column, preserving legal evidence, supporting
 * rollback or audit, and maintaining referential integrity across
 * channel/category configuration.
 *
 * Authorization is strictly admin-only for deletion, with audit logs enforced
 * for all delete operations. Attempting to delete a template referenced by
 * active channels or with binding relationships will return an error to prevent
 * orphaned configurations.
 *
 * Administrators are encouraged to use the get detail operation prior to
 * deletion to confirm status and impact. Successful requests receive a
 * confirmation response, while failure cases return a structured error.
 *
 * @param props.connection
 * @param props.templateId UUID of the category template to delete.
 * @path /aiCommerce/admin/categoryTemplates/:templateId
 * @accessor api.functional.aiCommerce.admin.categoryTemplates.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the category template to delete. */
    templateId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/categoryTemplates/:templateId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/categoryTemplates/${encodeURIComponent(props.templateId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("templateId")(() => typia.assert(props.templateId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
