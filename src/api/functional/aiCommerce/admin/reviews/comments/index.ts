import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceComment } from "../../../../../structures/IAiCommerceComment";
import { IAiCommercePageIComment } from "../../../../../structures/IAiCommercePageIComment";

/**
 * Create a new comment on the specified review (ai_commerce_comments table).
 *
 * Authenticated buyers, sellers, or admins can create a new comment attached to
 * a given review via this endpoint. The request body includes the comment text,
 * optional parentId for thread structure, and visibility/status entries
 * compliant with community and business rules.
 *
 * Input validation ensures the reviewId exists, is visible to the caller, and
 * the posted comment meets content, length, and moderation requirements. Upon
 * success, the comment is recorded in ai_commerce_comments, a snapshot/audit
 * log entry is created, and notification routines are triggered for relevant
 * recipients.
 *
 * Reply nesting is supported through parentId; moderation and alert logic apply
 * according to comment content and role. The response returns the full
 * IAiCommerceComment object for UI confirmation and immediate display/use. Any
 * errors, such as non-existent review, thread limit exceeded, or violation of
 * posting rights, are reported in detail. Use this in combination with comment
 * listing and detail APIs for full discussion/messaging features.
 *
 * @param props.connection
 * @param props.reviewId Review identifier to which the comment is being
 *   attached.
 * @param props.body Required fields for creating a new review comment
 *   (IAiCommerceComment.ICreate).
 * @path /aiCommerce/admin/reviews/:reviewId/comments
 * @accessor api.functional.aiCommerce.admin.reviews.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Review identifier to which the comment is being attached. */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Required fields for creating a new review comment
     * (IAiCommerceComment.ICreate).
     */
    body: IAiCommerceComment.ICreate;
  };
  export type Body = IAiCommerceComment.ICreate;
  export type Response = IAiCommerceComment;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/reviews/:reviewId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/reviews/${encodeURIComponent(props.reviewId ?? "null")}/comments`;
  export const random = (): IAiCommerceComment =>
    typia.random<IAiCommerceComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve and filter comments for a specific review (ai_commerce_comments
 * table).
 *
 * Enables buyers, sellers, or admins to fetch and filter the list of comments
 * for an identified review. The operation supports pagination, search, and
 * filtering based on the IAiCommerceComment.IRequest input, including fields
 * like status, authorId, and comment update time. Output is standardized as
 * IAiCommercePageIComment.ISummary, providing a digestible, paginated, and
 * sortable list for user interfaces or moderation tools.
 *
 * Access is governed by review/comment visibility and user role: buyers can see
 * and search comments for reviews they are entitled to read; sellers can view
 * comments on reviews of their products; admins have global access. All
 * requests are logged for compliance.
 *
 * Validation ensures the review exists, has not been deleted, and comment
 * filters are within expected ranges. In the case of errors (review not found
 * or access violation), detailed responses outline the failure reason. This
 * endpoint complements comment creation, update, and deletion endpoints, and
 * underpins comment moderation/audit workflows.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier for the parent review whose comments
 *   are being queried.
 * @param props.body Comment query filters, search string, and pagination
 *   parameters (see IAiCommerceComment.IRequest).
 * @path /aiCommerce/admin/reviews/:reviewId/comments
 * @accessor api.functional.aiCommerce.admin.reviews.comments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier for the parent review whose comments are being
     * queried.
     */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Comment query filters, search string, and pagination parameters (see
     * IAiCommerceComment.IRequest).
     */
    body: IAiCommerceComment.IRequest;
  };
  export type Body = IAiCommerceComment.IRequest;
  export type Response = IAiCommercePageIComment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/reviews/:reviewId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/reviews/${encodeURIComponent(props.reviewId ?? "null")}/comments`;
  export const random = (): IAiCommercePageIComment.ISummary =>
    typia.random<IAiCommercePageIComment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a single comment for a review (ai_commerce_comments table).
 *
 * This endpoint retrieves the details for an identified comment that belongs to
 * a specific review. It ensures both reviewId and commentId exist and are
 * associated, handling authorization for buyers, sellers, or admins according
 * to their roles and the comment's visibility/privacy settings.
 *
 * The response includes the full IAiCommerceComment object (author, content,
 * status, timestamps, moderation flags) as appropriate for the role's access
 * rights. The operation defines validation for comment existence, association
 * with the given review, and the review's non-deleted state. In case of error
 * (comment not found, review deleted, authorization failure), a detailed error
 * is returned.
 *
 * Typical use cases include comment detail pages, moderation audits, or
 * notification deep-links. All access is audited as required by UGC compliance
 * rules.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier for the parent review.
 * @param props.commentId Unique identifier for the comment to retrieve.
 * @path /aiCommerce/admin/reviews/:reviewId/comments/:commentId
 * @accessor api.functional.aiCommerce.admin.reviews.comments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the parent review. */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier for the comment to retrieve. */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceComment;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/reviews/:reviewId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/reviews/${encodeURIComponent(props.reviewId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): IAiCommerceComment =>
    typia.random<IAiCommerceComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the content or status of an existing comment (ai_commerce_comments
 * table).
 *
 * Allows buyers, sellers, or admins who own or are entitled to manage the
 * comment to update its content, visibility, or status. All edits must comply
 * with system moderation and history requirements, including maximum
 * nesting/threading and permissible content types defined by platform
 * settings.
 *
 * The operation performs validation on comment existence, association with the
 * specified reviewId, edit permissions by role, and status. Updates are
 * snapshotted in audit trails. Any changes immediately trigger notification
 * workflows for the involved users as dictated by the underlying business
 * rules. Error responses detail insufficient permission, unauthorized access,
 * or content validation failures.
 *
 * This should be used together with the comment detail, history, and moderation
 * endpoints for full-featured comment management.
 *
 * @param props.connection
 * @param props.reviewId Parent review identifier for the comment.
 * @param props.commentId Unique identifier for the comment to update.
 * @param props.body Fields to update on a comment (see
 *   IAiCommerceComment.IUpdate).
 * @path /aiCommerce/admin/reviews/:reviewId/comments/:commentId
 * @accessor api.functional.aiCommerce.admin.reviews.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Parent review identifier for the comment. */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier for the comment to update. */
    commentId: string & tags.Format<"uuid">;

    /** Fields to update on a comment (see IAiCommerceComment.IUpdate). */
    body: IAiCommerceComment.IUpdate;
  };
  export type Body = IAiCommerceComment.IUpdate;
  export type Response = IAiCommerceComment;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/reviews/:reviewId/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/reviews/${encodeURIComponent(props.reviewId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): IAiCommerceComment =>
    typia.random<IAiCommerceComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (soft delete) a comment from a review (ai_commerce_comments
 * table).
 *
 * Authenticated buyers, sellers, or admins can mark a comment as deleted using
 * this operation. It records the deleted_at timestamp for the given comment and
 * audit logs this action. Hard deletion is not performed in order to preserve
 * platform evidence for disputes and moderation.
 *
 * Role checks ensure only the comment owner, associated seller, or admin can
 * execute this operation; attempts to delete a comment not owned or managed by
 * the requesting user will fail with an error. Associated notifications are
 * sent to relevant users where configured. The endpoint supports all
 * compliance, moderation, and UGC history requirements, complementing the
 * standard create, update, and list comment flows.
 *
 * Deleted comments may be displayed for admins or in audit logs, but are not
 * shown to regular users. Detailed errors are returned for missing,
 * unauthorized, or already deleted comments.
 *
 * @param props.connection
 * @param props.reviewId Parent review identifier for the comment.
 * @param props.commentId Unique identifier for the comment to logically delete.
 * @path /aiCommerce/admin/reviews/:reviewId/comments/:commentId
 * @accessor api.functional.aiCommerce.admin.reviews.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Parent review identifier for the comment. */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier for the comment to logically delete. */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/reviews/:reviewId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/reviews/${encodeURIComponent(props.reviewId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
