import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceTrendingProduct } from "../../../../structures/IAiCommerceTrendingProduct";

/**
 * Create a new trending product entry (ai_commerce_trending_products).
 *
 * Create a new trending product entry in ai_commerce_trending_products,
 * enabling an admin user to promote a product to trending status manually,
 * override analytics, or seed initial trending campaigns. Required input
 * includes product reference, analytics score, manual override flag, and timing
 * information in accordance with business rules.
 *
 * Only users with administrative privileges can access this operation. All
 * creation actions are rigorously logged for compliance and future audit. Input
 * validation ensures that only products eligible for trending are accepted
 * (e.g., status, availability, non-duplication). Manual overrides are
 * prominent, so downstream business rules show these entries with higher
 * priority for the specified time period.
 *
 * This endpoint may be used in conjunction with analytics engine outputs,
 * automated recommendation triggers, or marketing campaigns. Failure scenarios
 * include duplicate trending entries, ineligible product IDs, or invalid
 * score/override states.
 *
 * @param props.connection
 * @param props.body Trending product creation data including product reference,
 *   score, and override flags.
 * @path /aiCommerce/admin/trendingProducts
 * @accessor api.functional.aiCommerce.admin.trendingProducts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Trending product creation data including product reference, score,
     * and override flags.
     */
    body: IAiCommerceTrendingProduct.ICreate;
  };
  export type Body = IAiCommerceTrendingProduct.ICreate;
  export type Response = IAiCommerceTrendingProduct;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/trendingProducts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/trendingProducts";
  export const random = (): IAiCommerceTrendingProduct =>
    typia.random<IAiCommerceTrendingProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of an existing trending product
 * (ai_commerce_trending_products).
 *
 * Update trending analytics, override status, or supplemental metadata for an
 * existing entry in ai_commerce_trending_products. This API supports fine-tuned
 * control over discovery, allowing admins to manually sustain or suppress
 * product trending state beyond purely analytics-driven assignment.
 *
 * The operation requires trendingProductId as a path parameter and a body
 * containing the fields to update (e.g., updated score, override flag,
 * rationale, and timing). All changes are logged for compliance and can have
 * downstream effects on user feeds or homepage segments. Only users with admin
 * role can access this operation, enforcing rigorous access control for trend
 * manipulation.
 *
 * Related API operations include trending product creation, detailed retrieval,
 * and listing endpoints. Error handling covers not found, forbidden, invalid
 * parameters, and update failures due to immutable or out-of-date records.
 *
 * @param props.connection
 * @param props.trendingProductId Unique identifier of the trending product
 *   record to update.
 * @param props.body Fields to update for the selected trending product, such as
 *   score or override flags.
 * @path /aiCommerce/admin/trendingProducts/:trendingProductId
 * @accessor api.functional.aiCommerce.admin.trendingProducts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the trending product record to update. */
    trendingProductId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the selected trending product, such as score or
     * override flags.
     */
    body: IAiCommerceTrendingProduct.IUpdate;
  };
  export type Body = IAiCommerceTrendingProduct.IUpdate;
  export type Response = IAiCommerceTrendingProduct;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/trendingProducts/:trendingProductId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/trendingProducts/${encodeURIComponent(props.trendingProductId ?? "null")}`;
  export const random = (): IAiCommerceTrendingProduct =>
    typia.random<IAiCommerceTrendingProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("trendingProductId")(() =>
        typia.assert(props.trendingProductId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a trending product entry by ID (ai_commerce_trending_products).
 *
 * Delete a trending product record identified by trendingProductId from
 * ai_commerce_trending_products. This action immediately removes the trending
 * status from the associated product and propagates changes to related
 * discovery channels and analytics flows. Only admins have access, and actions
 * are logged for audit. Permanent deletion may have cascading implications for
 * current and historical analytics, recommendation results, and business
 * reporting.
 *
 * The trendingProductId is a required UUID path parameter that uniquely
 * identifies the trending entry to be deleted. Associated analytics and
 * discovery modules may respond by recalculating feed inputs following
 * deletion. Common error cases include not found, forbidden, and attempted
 * deletion of protected records.
 *
 * @param props.connection
 * @param props.trendingProductId Unique identifier of the trending product
 *   record to delete.
 * @path /aiCommerce/admin/trendingProducts/:trendingProductId
 * @accessor api.functional.aiCommerce.admin.trendingProducts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the trending product record to delete. */
    trendingProductId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/trendingProducts/:trendingProductId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/trendingProducts/${encodeURIComponent(props.trendingProductId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("trendingProductId")(() =>
        typia.assert(props.trendingProductId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
