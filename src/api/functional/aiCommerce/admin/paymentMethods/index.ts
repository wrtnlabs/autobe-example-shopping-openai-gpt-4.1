import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommercePaymentMethod } from "../../../../structures/IAiCommercePaymentMethod";
import { IPageIAiCommercePaymentMethod } from "../../../../structures/IPageIAiCommercePaymentMethod";

/**
 * Create a new payment method in the ai_commerce_payment_methods table.
 *
 * This operation allows an administrator to create a new payment method, which
 * is added to the ai_commerce_payment_methods table. The provided method code
 * must be unique across all payment methods, as it will be used for referencing
 * this method in payment flows, analytics, and configuration mapping.
 * Administrators need to provide a clear display name for the payment method,
 * enabling buyers to identify the method in UI forms.
 *
 * Internally, if external API or gateway configuration is needed, details are
 * stored in the configuration field for future use. Active status is set to
 * true by default for new methods but can later be toggled with the update
 * endpoint.
 *
 * Only administrators can perform this action, supporting strict control of
 * which payment methods are exposed to users and ensuring platform compliance.
 * Errors are raised if a duplicate method_code is provided. All creation events
 * are audit logged for platform compliance, enabling traceability for all
 * changes in available payment methods.
 *
 * @param props.connection
 * @param props.body Payment method creation details, including unique method
 *   code, display name, and optional configuration.
 * @path /aiCommerce/admin/paymentMethods
 * @accessor api.functional.aiCommerce.admin.paymentMethods.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Payment method creation details, including unique method code,
     * display name, and optional configuration.
     */
    body: IAiCommercePaymentMethod.ICreate;
  };
  export type Body = IAiCommercePaymentMethod.ICreate;
  export type Response = IAiCommercePaymentMethod;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/paymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentMethods";
  export const random = (): IAiCommercePaymentMethod =>
    typia.random<IAiCommercePaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and filter all payment methods with full metadata from the
 * ai_commerce_payment_methods table.
 *
 * This operation allows admins to search and page through all currently defined
 * payment methods, as captured in the ai_commerce_payment_methods table.
 * Results include method codes, display names, activation flags, and
 * (optionally) gateway integration or configuration metadata.
 *
 * Used for configuring payment options, managing system status, or diagnosing
 * payment setup issues. The list can be filtered by active status, method code,
 * or configuration, and supports analytics about payment method usage on the
 * platform. Typical admin-only endpoint, supporting both operational and
 * financial configuration needs.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination parameters for listing
 *   payment methods.
 * @path /aiCommerce/admin/paymentMethods
 * @accessor api.functional.aiCommerce.admin.paymentMethods.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filtering, and pagination parameters for listing payment
     * methods.
     */
    body: IAiCommercePaymentMethod.IRequest;
  };
  export type Body = IAiCommercePaymentMethod.IRequest;
  export type Response = IPageIAiCommercePaymentMethod;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/paymentMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentMethods";
  export const random = (): IPageIAiCommercePaymentMethod =>
    typia.random<IPageIAiCommercePaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve metadata/details for a single payment method from the
 * ai_commerce_payment_methods table.
 *
 * This endpoint returns the metadata and configuration details for a single
 * payment method identified by paymentMethodId in the
 * ai_commerce_payment_methods table. Data includes method code, name,
 * activation, configuration, and audit fields for administrative review and
 * troubleshooting.
 *
 * This is useful for platform admins reviewing payment integrations, updating
 * gateways, or analyzing usage of specific payment methods. Data access is
 * admin-restricted and may link to further system configuration or payment
 * analytics endpoints.
 *
 * @param props.connection
 * @param props.paymentMethodId ID of the payment method to retrieve.
 * @path /aiCommerce/admin/paymentMethods/:paymentMethodId
 * @accessor api.functional.aiCommerce.admin.paymentMethods.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** ID of the payment method to retrieve. */
    paymentMethodId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommercePaymentMethod;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/paymentMethods/:paymentMethodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentMethods/${encodeURIComponent(props.paymentMethodId ?? "null")}`;
  export const random = (): IAiCommercePaymentMethod =>
    typia.random<IAiCommercePaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentMethodId")(() =>
        typia.assert(props.paymentMethodId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing payment method in the ai_commerce_payment_methods table.
 *
 * An administrator can update the properties of an existing payment method in
 * the ai_commerce_payment_methods table. Changing the display_name allows for
 * improved buyer understanding, while setting is_active can disable methods
 * that are being retired. Complex configuration changes (for example,
 * credentials or integration details) are performed by providing a new
 * configuration payload.
 *
 * The endpoint performs validation on incoming configuration and status, checks
 * for unique constraints, and will return detailed errors on any violation. All
 * updates are strictly logged for compliance, preserving before and after
 * states for audit requirements. Only users with admin authority can perform
 * this operation, and any attempt to update a non-existent paymentMethodId will
 * return an appropriate error.
 *
 * @param props.connection
 * @param props.paymentMethodId Unique identifier of the payment method to
 *   update.
 * @param props.body Fields to update for the payment method, such as display
 *   name, status, or configuration.
 * @path /aiCommerce/admin/paymentMethods/:paymentMethodId
 * @accessor api.functional.aiCommerce.admin.paymentMethods.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the payment method to update. */
    paymentMethodId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the payment method, such as display name,
     * status, or configuration.
     */
    body: IAiCommercePaymentMethod.IUpdate;
  };
  export type Body = IAiCommercePaymentMethod.IUpdate;
  export type Response = IAiCommercePaymentMethod;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/paymentMethods/:paymentMethodId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/paymentMethods/${encodeURIComponent(props.paymentMethodId ?? "null")}`;
  export const random = (): IAiCommercePaymentMethod =>
    typia.random<IAiCommercePaymentMethod>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentMethodId")(() =>
        typia.assert(props.paymentMethodId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an existing payment method by paymentMethodId (hard delete) from
 * ai_commerce_payment_methods.
 *
 * When an admin invokes this API to delete a payment method, the payment method
 * is permanently removed from the ai_commerce_payment_methods table. This
 * removal is a hard delete since the deleted_at field is present for compliance
 * and auditing but does not prevent complete deletion if business policy
 * requires. The operation enforces referential integrity, ensuring active
 * payments linked to this method must be resolved or migrated before deletion.
 *
 * All deletions are audit logged, including the actor, timestamp, and affected
 * payment method. Attempts to delete a non-existent paymentMethodId yield an
 * error. Only administrative users have access to delete payment method
 * definitions.
 *
 * @param props.connection
 * @param props.paymentMethodId Unique identifier for the payment method to
 *   delete.
 * @path /aiCommerce/admin/paymentMethods/:paymentMethodId
 * @accessor api.functional.aiCommerce.admin.paymentMethods.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the payment method to delete. */
    paymentMethodId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/paymentMethods/:paymentMethodId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentMethods/${encodeURIComponent(props.paymentMethodId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentMethodId")(() =>
        typia.assert(props.paymentMethodId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
