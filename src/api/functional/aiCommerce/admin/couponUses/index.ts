import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCouponUse } from "../../../../structures/IAiCommerceCouponUse";
import { IPageIAiCommerceCouponUse } from "../../../../structures/IPageIAiCommerceCouponUse";

/**
 * Redeem a valid issued coupon by creating an ai_commerce_coupon_uses record.
 *
 * Authenticated users (admin, seller, or the end user with coupon) can redeem a
 * valid, issued coupon by creating a new coupon use (redemption) entry. The
 * endpoint validates eligibility (coupon status, expiry, user, order context),
 * ensures usage quota is not exceeded, and locks the usage event for audit.
 *
 * The coupon issue status is atomically updated to reflect redemption, and
 * cross-entity updates are made to ensure accurate incentive accounting.
 * Related APIs include coupon issuance, query issued coupons (for a user or
 * campaign), and reporting coupon usage. All redemptions are logged for
 * compliance and analytics; abuses are rejected with a descriptive error.
 * Coupon cannot be redeemed twice or by unauthorized actors.
 *
 * @param props.connection
 * @param props.body Redemption details: coupon issue, user, order/context, and
 *   event metadata for recording the usage.
 * @path /aiCommerce/admin/couponUses
 * @accessor api.functional.aiCommerce.admin.couponUses.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Redemption details: coupon issue, user, order/context, and event
     * metadata for recording the usage.
     */
    body: IAiCommerceCouponUse.ICreate;
  };
  export type Body = IAiCommerceCouponUse.ICreate;
  export type Response = IAiCommerceCouponUse;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/couponUses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/couponUses";
  export const random = (): IAiCommerceCouponUse =>
    typia.random<IAiCommerceCouponUse>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated coupon use events from ai_commerce_coupon_uses
 * for admin/seller analytics.
 *
 * Authenticated administrators or sellers can query coupon redemption events
 * with advanced filters: user, coupon code, order reference, status, redemption
 * date, campaign reference, or usage window. The operation supports sorting,
 * pagination, and status breakdowns to surface trends, redemption velocity, and
 * anomalies.
 *
 * Sensitive details (such as user IDs and campaign linkage) are only shown to
 * privileged users. Returned records include linked coupon issuance data, the
 * affected user/account, and a summary of redemption context. Error handling
 * includes validation for non-existent filter keys, excessive search window
 * size, or unauthorized filter scopes.
 *
 * Typical use cases include tracking which coupons were redeemed in a campaign,
 * investigating coupon abuse, and reviewing redemption history for a given
 * buyer or order. All query actions are logged for audit, and real-time
 * performance is optimized. Updates and deletions must use separate endpoints.
 *
 * Business logic enforces that only active, valid coupon usage events are
 * included for general use; deleted or revoked uses appear only to admins for
 * compliance analysis.
 *
 * @param props.connection
 * @param props.body Search criteria—user, coupon, order, status, or
 *   campaign—plus pagination/sort fields.
 * @path /aiCommerce/admin/couponUses
 * @accessor api.functional.aiCommerce.admin.couponUses.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria—user, coupon, order, status, or campaign—plus
     * pagination/sort fields.
     */
    body: IAiCommerceCouponUse.IRequest;
  };
  export type Body = IAiCommerceCouponUse.IRequest;
  export type Response = IPageIAiCommerceCouponUse;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/couponUses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/couponUses";
  export const random = (): IPageIAiCommerceCouponUse =>
    typia.random<IPageIAiCommerceCouponUse>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch details of a specific coupon use event from ai_commerce_coupon_uses by
 * couponUseId.
 *
 * The endpoint fetches a single coupon usage record by its unique couponUseId,
 * returning full context including the issuing coupon, redeemed user, order,
 * status, redemption date, and campaign linkage/tag.
 *
 * Role-based access ensures only admins, authorized sellers, or the involved
 * user can view the record. If the coupon use is not found or inaccessible, the
 * API returns an appropriate error. Use cases include support investigation,
 * abuse review, and verifying entitlement in support cases. All requests are
 * audit-logged for legal traceability. Related endpoints include listing coupon
 * uses and searching by campaign or user.
 *
 * @param props.connection
 * @param props.couponUseId Unique identifier of the coupon usage/redemption
 *   event to retrieve.
 * @path /aiCommerce/admin/couponUses/:couponUseId
 * @accessor api.functional.aiCommerce.admin.couponUses.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the coupon usage/redemption event to retrieve. */
    couponUseId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceCouponUse;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/couponUses/:couponUseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/couponUses/${encodeURIComponent(props.couponUseId ?? "null")}`;
  export const random = (): IAiCommerceCouponUse =>
    typia.random<IAiCommerceCouponUse>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponUseId")(() => typia.assert(props.couponUseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a coupon use/redemption in ai_commerce_coupon_uses by couponUseId, for
 * admin/seller corrections.
 *
 * Authorized administrators (and, where policy allows, issuing sellers) may
 * update a coupon usage record by couponUseId, changing its status (e.g.,
 * revoke, mark as refunded), event metadata, or associated order/context. This
 * is only allowed before settlement/finalization or as part of a fraud
 * investigation. Updates are strictly validated against current status,
 * redemption history, and business constraints; only allowed transitions are
 * permitted.
 *
 * Attempting to modify a finalized, expired, or audited usage event is denied.
 * All update operations are trace-logged for compliance, and only authorized
 * actors can update another user's redemption record. Related APIs include
 * coupon use creation (redeem), listing, and deletion/revocation endpoints.
 *
 * @param props.connection
 * @param props.couponUseId Unique id of the coupon usage event to be updated.
 * @param props.body Update fields for the coupon use event: status, order,
 *   event metadata, or administrative correction.
 * @path /aiCommerce/admin/couponUses/:couponUseId
 * @accessor api.functional.aiCommerce.admin.couponUses.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique id of the coupon usage event to be updated. */
    couponUseId: string & tags.Format<"uuid">;

    /**
     * Update fields for the coupon use event: status, order, event
     * metadata, or administrative correction.
     */
    body: IAiCommerceCouponUse.IUpdate;
  };
  export type Body = IAiCommerceCouponUse.IUpdate;
  export type Response = IAiCommerceCouponUse;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/couponUses/:couponUseId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/couponUses/${encodeURIComponent(props.couponUseId ?? "null")}`;
  export const random = (): IAiCommerceCouponUse =>
    typia.random<IAiCommerceCouponUse>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponUseId")(() => typia.assert(props.couponUseId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a coupon use record in ai_commerce_coupon_uses by
 * couponUseId.
 *
 * Role-restricted users (admin, authorized seller) can delete a coupon use
 * record by couponUseId, intended for compliance, privacy, or administrative
 * correction (e.g., fraud cases or duplicate issue/usage correction).
 *
 * Before deletion, the system checks status and financial settlement: only
 * unfinalized uses may be deleted. Attempts to delete post-settlement or
 * previously audited records result in a validation error. Audit trails of all
 * deletion actions are maintained, including actor, context, and timestamp for
 * audit.
 *
 * Physical data removal is enforced; this operation does not perform logical
 * delete. Only privileged roles may invoke this operation.
 *
 * @param props.connection
 * @param props.couponUseId ID of coupon use/redemption record to delete.
 * @path /aiCommerce/admin/couponUses/:couponUseId
 * @accessor api.functional.aiCommerce.admin.couponUses.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of coupon use/redemption record to delete. */
    couponUseId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/couponUses/:couponUseId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/couponUses/${encodeURIComponent(props.couponUseId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponUseId")(() => typia.assert(props.couponUseId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
