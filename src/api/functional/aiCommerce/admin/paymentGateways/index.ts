import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommercePaymentGateway } from "../../../../structures/IAiCommercePaymentGateway";
import { IPageIAiCommercePaymentGateway } from "../../../../structures/IPageIAiCommercePaymentGateway";

/**
 * Create a new payment gateway configuration (admin only) in
 * ai_commerce_payment_gateways.
 *
 * An administrator can register a new payment gateway to the platform by
 * providing all required details for integration: unique gateway code,
 * descriptive display name, endpoint URL for payment API, activation status,
 * supported currency codes (comma-separated), and other configuration as
 * needed. The operation ensures the code and display name are unique, raising
 * errors on constraint violations.
 *
 * All payment gateway creations are audit logged for legal and compliance
 * traceability, specifying the actor, timestamp, and created configuration.
 * Successful creation enables the gateway for platform payment operations,
 * subject to activation status. Only admin users have access to perform this
 * operation.
 *
 * @param props.connection
 * @param props.body Complete payment gateway configuration and identifiers for
 *   creation. Requires unique gateway_code, display name, endpoint, activation,
 *   and currency list.
 * @path /aiCommerce/admin/paymentGateways
 * @accessor api.functional.aiCommerce.admin.paymentGateways.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Complete payment gateway configuration and identifiers for creation.
     * Requires unique gateway_code, display name, endpoint, activation, and
     * currency list.
     */
    body: IAiCommercePaymentGateway.ICreate;
  };
  export type Body = IAiCommercePaymentGateway.ICreate;
  export type Response = IAiCommercePaymentGateway;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/paymentGateways",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentGateways";
  export const random = (): IAiCommercePaymentGateway =>
    typia.random<IAiCommercePaymentGateway>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list payment gateway configurations in
 * ai_commerce_payment_gateways (admin-only).
 *
 * Administrators can retrieve a paginated, searchable list of payment gateway
 * definitions and configurations with complex filters for status, supported
 * currencies, display name, or region. The endpoint leverages JSON query and
 * full-text search on the ai_commerce_payment_gateways table, supporting
 * advanced administration and oversight of the payment gateway ecosystem.
 *
 * The search request body enables specifying multiple criteria, plus sorting
 * and pagination for efficiency when many gateway configurations exist. This
 * endpoint is restricted to admin users due to the sensitive nature of gateway
 * management (as changes may affect system payment flows). All query operations
 * are logged for security and traceability. The results include detailed
 * gateway configuration and status fields optimized for management UIs.
 *
 * @param props.connection
 * @param props.body Search criteria, filtering, and pagination information for
 *   payment gateway query.
 * @path /aiCommerce/admin/paymentGateways
 * @accessor api.functional.aiCommerce.admin.paymentGateways.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filtering, and pagination information for payment
     * gateway query.
     */
    body: IAiCommercePaymentGateway.IRequest;
  };
  export type Body = IAiCommercePaymentGateway.IRequest;
  export type Response = IPageIAiCommercePaymentGateway;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/paymentGateways",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/paymentGateways";
  export const random = (): IPageIAiCommercePaymentGateway =>
    typia.random<IPageIAiCommercePaymentGateway>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific payment gateway by paymentGatewayId
 * (admin-only).
 *
 * An admin user can obtain the details of a single payment gateway from the
 * ai_commerce_payment_gateways table using its paymentGatewayId. The response
 * returns all fields including gateway code, display name, API endpoint,
 * supported currencies, and status. This data is used for managing and auditing
 * payment systems as well as diagnosing integration or business problems.
 *
 * Security: Only admin users may access this endpoint due to the sensitivity of
 * payment gateway configurational data. All access, including query time and
 * user, is logged for compliance. Errors delivered if the specified
 * paymentGatewayId does not reference an existing record, or if the admin lacks
 * permission. This endpoint is read-only, and results are optimized for system
 * management UIs.
 *
 * @param props.connection
 * @param props.paymentGatewayId Unique identifier of the payment gateway to
 *   retrieve.
 * @path /aiCommerce/admin/paymentGateways/:paymentGatewayId
 * @accessor api.functional.aiCommerce.admin.paymentGateways.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the payment gateway to retrieve. */
    paymentGatewayId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommercePaymentGateway;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/paymentGateways/:paymentGatewayId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentGateways/${encodeURIComponent(props.paymentGatewayId ?? "null")}`;
  export const random = (): IAiCommercePaymentGateway =>
    typia.random<IAiCommercePaymentGateway>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentGatewayId")(() =>
        typia.assert(props.paymentGatewayId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update properties of an existing payment gateway (admin only) in
 * ai_commerce_payment_gateways.
 *
 * When invoked by an admin, this endpoint updates the configuration or status
 * of an existing payment gateway in the ai_commerce_payment_gateways table.
 * Fields such as display_name, API endpoint, active state, and supported
 * currency codes can be altered to reflect new business requirements or
 * integration changes.
 *
 * All changes are validated for configuration correctness and referential
 * integrity. Attempts to update a gateway with a duplicate code or invalid
 * settings result in detailed error messages. Updates are logged to maintain a
 * non-repudiable compliance trail. Only administrators can perform these
 * updates, and a permission error is raised otherwise. If the specified gateway
 * does not exist, an appropriate error is returned.
 *
 * @param props.connection
 * @param props.paymentGatewayId Unique identifier for the payment gateway to
 *   update.
 * @param props.body Updated payment gateway fields/artifacts including status,
 *   configuration, and endpoint.
 * @path /aiCommerce/admin/paymentGateways/:paymentGatewayId
 * @accessor api.functional.aiCommerce.admin.paymentGateways.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the payment gateway to update. */
    paymentGatewayId: string & tags.Format<"uuid">;

    /**
     * Updated payment gateway fields/artifacts including status,
     * configuration, and endpoint.
     */
    body: IAiCommercePaymentGateway.IUpdate;
  };
  export type Body = IAiCommercePaymentGateway.IUpdate;
  export type Response = IAiCommercePaymentGateway;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/paymentGateways/:paymentGatewayId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/paymentGateways/${encodeURIComponent(props.paymentGatewayId ?? "null")}`;
  export const random = (): IAiCommercePaymentGateway =>
    typia.random<IAiCommercePaymentGateway>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentGatewayId")(() =>
        typia.assert(props.paymentGatewayId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an existing payment gateway configuration from
 * ai_commerce_payment_gateways (admin only).
 *
 * On execution by an admin, this endpoint permanently deletes the targeted
 * payment gateway from the ai_commerce_payment_gateways table by identifying
 * the UUID. Referential integrity is checked to ensure no live payment flows
 * are attached to the gateway. The deleted_at field indicates logical removal,
 * enabling compliance with core business rules and regulations about record
 * retention.
 *
 * All deletion actions are strictly audit logged, capturing the user,
 * timestamp, and target configuration. Only administrators have permission to
 * delete payment gateways, and attempts to delete non-existent gateways result
 * in an error response. The action is irreversible and removes the gateway from
 * all future payment routing.
 *
 * @param props.connection
 * @param props.paymentGatewayId Unique identifier of the payment gateway to
 *   delete.
 * @path /aiCommerce/admin/paymentGateways/:paymentGatewayId
 * @accessor api.functional.aiCommerce.admin.paymentGateways.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the payment gateway to delete. */
    paymentGatewayId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/paymentGateways/:paymentGatewayId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/paymentGateways/${encodeURIComponent(props.paymentGatewayId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("paymentGatewayId")(() =>
        typia.assert(props.paymentGatewayId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
