import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceChannel } from "../../../../structures/IAiCommerceChannel";
import { IPageIAiCommerceChannel } from "../../../../structures/IPageIAiCommerceChannel";
export * as settings from "./settings/index";
export * as sections from "./sections/index";
export * as categories from "./categories/index";

/**
 * Create a new aiCommerce sales channel (admin only).
 *
 * Channel creation allows platform administrators to onboard new sales outlets
 * (such as apps, partner portals, or test platforms) into aiCommerce. All
 * required channel attributes—code, name, locale, activation, and current
 * workflow status—must be supplied and validated for uniqueness and schema
 * constraints.
 *
 * Only authenticated admin users may access this function. Upon creation, the
 * new channel is assigned a system-generated UUID, and all events are audited
 * in accordance with compliance requirements.
 *
 * This operation is fundamental to aiCommerce's extensible platform model,
 * allowing rapid expansion and configuration of new business outlets. Input
 * validation rules enforce unique channel codes and logical business
 * constraints, preventing conflicting configuration data. Upon creation, the
 * entire new row as stored in the ai_commerce_channels model is returned for
 * immediate system integration or admin display.
 *
 * @param props.connection
 * @param props.body Definition and configuration values for the new sales
 *   channel, including code, name, locale, and workflow status.
 * @path /aiCommerce/admin/channels
 * @accessor api.functional.aiCommerce.admin.channels.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Definition and configuration values for the new sales channel,
     * including code, name, locale, and workflow status.
     */
    body: IAiCommerceChannel.ICreate;
  };
  export type Body = IAiCommerceChannel.ICreate;
  export type Response = IAiCommerceChannel;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/channels";
  export const random = (): IAiCommerceChannel =>
    typia.random<IAiCommerceChannel>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve paginated and filtered list of aiCommerce sales channels (admin
 * only).
 *
 * This operation enables administrators to perform advanced search and
 * pagination of sales channel records. Administrators may filter by activation
 * status, business status, channel name, and locale, allowing efficient
 * navigation through potentially hundreds of channels across the platform.
 *
 * The operation integrates full support for pagination, sorting, and partial
 * name matching for rapid business management. The data returned includes
 * unique identifiers, key configuration values, and business status for each
 * channel.
 *
 * AICommerce restricts channel configuration access to admin roles only.
 * Security policies require that only authenticated admins may access this
 * endpoint; rate-limiting and access logs are enforced at the system layer.
 *
 * This endpoint is essential for global configuration, channel onboarding, and
 * agile business management workflows. Related endpoints allow full CRUD for
 * individual channels. Returned data strictly reflects the latest persisted
 * state in ai_commerce_channels, excluding soft-deleted entries unless
 * specifically filtered.
 *
 * @param props.connection
 * @param props.body Channel list search and filter criteria, including business
 *   status, locale, and activation filters.
 * @path /aiCommerce/admin/channels
 * @accessor api.functional.aiCommerce.admin.channels.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Channel list search and filter criteria, including business status,
     * locale, and activation filters.
     */
    body: IAiCommerceChannel.IRequest;
  };
  export type Body = IAiCommerceChannel.IRequest;
  export type Response = IPageIAiCommerceChannel;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/channels";
  export const random = (): IPageIAiCommerceChannel =>
    typia.random<IPageIAiCommerceChannel>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific aiCommerce sales channel (admin
 * only).
 *
 * This operation returns the full configuration and status details of a
 * specific aiCommerce sales channel given its unique identifier. The detail
 * view includes all base fields, such as code, name, locale, activation and
 * business status, creation/update timestamps, and indexes.
 *
 * Security enforcement limits access to admins for operational integrity and
 * auditability. The returned data exactly mirrors the stored channel in the
 * ai_commerce_channels model and excludes soft-deleted entries.
 *
 * This endpoint integrates with channel management features and is typically
 * used in admin portals to view or edit channel information, onboard new
 * integrations, and support compliance reporting. Invalid or non-existent IDs
 * trigger clear not-found responses, and all accesses are logged for audit
 * purposes.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the target sales channel
 * @path /aiCommerce/admin/channels/:channelId
 * @accessor api.functional.aiCommerce.admin.channels.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target sales channel */
    channelId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceChannel;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IAiCommerceChannel =>
    typia.random<IAiCommerceChannel>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing aiCommerce sales channel (admin only).
 *
 * Apply changes to essential channel properties such as name, locale,
 * activation status, or workflow state for a specific aiCommerce sales channel
 * by UUID. Updating a channel triggers full validation to protect unique
 * constraints (such as code) and aligns with AICommerce's audit and compliance
 * rules.
 *
 * Only admin users can update channel records. All modifications generate audit
 * logs to support platform forensics, with the API returning the full persisted
 * channel after update, reflecting all schema fields.
 *
 * This endpoint is integral to agile business management, channel rebranding,
 * and operational responses to business rule/template changes. Attempts to edit
 * system-critical or immutable fields are rejected, with clear error replies
 * specifying the allowed field set.
 *
 * All state changes are captured in the platform's audit infrastructure per
 * compliance needs.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the target aiCommerce sales
 *   channel to be updated
 * @param props.body Updated channel configuration and status information; only
 *   modifiable fields per schema
 * @path /aiCommerce/admin/channels/:channelId
 * @accessor api.functional.aiCommerce.admin.channels.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the target aiCommerce sales channel to be
     * updated
     */
    channelId: string & tags.Format<"uuid">;

    /**
     * Updated channel configuration and status information; only modifiable
     * fields per schema
     */
    body: IAiCommerceChannel.IUpdate;
  };
  export type Body = IAiCommerceChannel.IUpdate;
  export type Response = IAiCommerceChannel;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/channels/:channelId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): IAiCommerceChannel =>
    typia.random<IAiCommerceChannel>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (logical removal) of an aiCommerce sales channel by UUID (admin
 * only).
 *
 * Mark the specified aiCommerce sales channel as deleted by setting its
 * deleted_at column, as per the ai_commerce_channels model. This operation
 * supports platform compliance and evidence by enforcing soft delete—auditing
 * all changes and preserving deleted records in the database.
 *
 * Only platform admins may perform channel deletion; all actions are fully
 * logged. Soft-deleted channels are excluded from most platform operations but
 * can be restored or referenced for historical analytics if compliance rules
 * permit.
 *
 * Attempts to remove a non-existing or already deleted channel result in a
 * clear business error response, consistent with API error handling
 * conventions. This is a non-reversible logical delete as defined in the
 * AICommerce channel management schema
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the aiCommerce sales channel to
 *   be soft-deleted
 * @path /aiCommerce/admin/channels/:channelId
 * @accessor api.functional.aiCommerce.admin.channels.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the aiCommerce sales channel to be soft-deleted */
    channelId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/channels/:channelId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
