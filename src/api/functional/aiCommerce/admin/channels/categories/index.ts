import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCategory } from "../../../../../structures/IAiCommerceCategory";
import { IPageIAiCommerceCategory } from "../../../../../structures/IPageIAiCommerceCategory";

/**
 * Create a new category under a specified channel in ai_commerce_categories.
 *
 * Admin users can create new product categories for a given channel using this
 * endpoint. Categories are organized as hierarchical trees under channels,
 * essential for merchandising, filtering, and analytics. When invoked, the
 * operation validates uniqueness of the category code within the channel,
 * required fields, and compliance with business logic (e.g., hierarchy depth,
 * duplication prevention).
 *
 * The operation processes category metadata, parent association (if not root),
 * and visibility settings. The ai_commerce_categories Prisma model captures
 * these details, with fields for level, business/workflow status, creation
 * influence, and audit trails. If a new category is assigned a parentId, the
 * endpoint ensures parent existence and correct placement in the tree. Errors
 * may include missing/invalid parentId, duplicate code within the channel, or
 * invalid level/sortOrder assignments. Successful creation returns the complete
 * category object for further administrative actions or front-end refresh
 * logic.
 *
 * @param props.connection
 * @param props.channelId Unique identifier of the channel under which to create
 *   the new category (UUID format).
 * @param props.body Details of the new category to create, including code,
 *   name, parentId, level, sort order, and status.
 * @path /aiCommerce/admin/channels/:channelId/categories
 * @accessor api.functional.aiCommerce.admin.channels.categories.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the channel under which to create the new
     * category (UUID format).
     */
    channelId: string & tags.Format<"uuid">;

    /**
     * Details of the new category to create, including code, name,
     * parentId, level, sort order, and status.
     */
    body: IAiCommerceCategory.ICreate;
  };
  export type Body = IAiCommerceCategory.ICreate;
  export type Response = IAiCommerceCategory;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/channels/:channelId/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/categories`;
  export const random = (): IAiCommerceCategory =>
    typia.random<IAiCommerceCategory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of categories in a sales channel
 * (ai_commerce_categories).
 *
 * This endpoint provides a flexible search and discovery interface for all
 * categories belonging to a given channel. The request body must follow
 * IAiCommerceCategory.IRequest, with support for pagination, search keywords,
 * filtering by status, and hierarchical queries (including depth and parent
 * relationships).
 *
 * The response returns a paged data structure, with summary category
 * information according to IPageIAiCommerceCategory.ISummary. This endpoint is
 * for admin-level or privileged business users who maintain category
 * hierarchies, and observes all access controls and business validation as
 * defined in the ai_commerce_categories schema.
 *
 * Validation rules ensure uniqueness of category codes within a channel and
 * restriction to non-deleted or active categories unless otherwise specified in
 * query filters. Edge cases such as too deep recursion or non-existent parent
 * references are handled with clear error messages.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the target sales channel
 * @param props.body Search, filtering, and pagination criteria for category
 *   retrieval
 * @path /aiCommerce/admin/channels/:channelId/categories
 * @accessor api.functional.aiCommerce.admin.channels.categories.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the target sales channel */
    channelId: string & tags.Format<"uuid">;

    /** Search, filtering, and pagination criteria for category retrieval */
    body: IAiCommerceCategory.IRequest;
  };
  export type Body = IAiCommerceCategory.IRequest;
  export type Response = IPageIAiCommerceCategory.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/channels/:channelId/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/categories`;
  export const random = (): IPageIAiCommerceCategory.ISummary =>
    typia.random<IPageIAiCommerceCategory.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update category attributes for a given channel and category in
 * ai_commerce_categories.
 *
 * Administrators can modify an existing product category under a sales channel
 * with this endpoint. The ai_commerce_categories table supports updating fields
 * such as the display name, business status, level, parent assignment, and sort
 * order, enabling live catalog refinement and merchandising optimization.
 *
 * During an update, the API validates that the category exists under the given
 * channel, checks the category code's uniqueness (if changed), and enforces
 * hierarchy rulesâ€”disallowing invalid parent assignments or cyclical
 * relationships. The operation uses the IAiCommerceCategory.IUpdate schema for
 * the request body, and on success, returns the updated category object
 * reflecting all changes and updated audit timestamps. Potential errors include
 * non-existent categoryId, unauthorized channelId, duplicate code, or invalid
 * hierarchy moves. The design follows Prisma schema's comments and business
 * rules for multi-level categories used in channel-specific merchandising and
 * analytics.
 *
 * @param props.connection
 * @param props.channelId Sales channel identifier containing the category (UUID
 *   format).
 * @param props.categoryId Target category's unique identifier (UUID format).
 * @param props.body Fields to update in the category, such as name, code,
 *   hierarchy, sort order, etc.
 * @path /aiCommerce/admin/channels/:channelId/categories/:categoryId
 * @accessor api.functional.aiCommerce.admin.channels.categories.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Sales channel identifier containing the category (UUID format). */
    channelId: string & tags.Format<"uuid">;

    /** Target category's unique identifier (UUID format). */
    categoryId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the category, such as name, code, hierarchy, sort
     * order, etc.
     */
    body: IAiCommerceCategory.IUpdate;
  };
  export type Body = IAiCommerceCategory.IUpdate;
  export type Response = IAiCommerceCategory;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/channels/:channelId/categories/:categoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): IAiCommerceCategory =>
    typia.random<IAiCommerceCategory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a product category from a channel in
 * ai_commerce_categories.
 *
 * This endpoint allows admin users to delete a specific category from a sales
 * channel. The ai_commerce_categories schema supports a soft delete mechanism
 * (deleted_at), but this API performs a permanent removal: after validation, it
 * physically removes the category, provided there are no remaining child
 * categories or assigned products. All audit and business logic steps, such as
 * checking dependency existence, are enforced to prevent data corruption.
 *
 * Attempting to delete a category with child nodes or products leads to a
 * failure with a detailed error response. Deletion operations are logged for
 * compliance and evidence. On success, the response confirms removal. This is a
 * critical operation for catalog management, reflecting sales channel and
 * category system design, and should not be used without proper administrative
 * permissions.
 *
 * @param props.connection
 * @param props.channelId Parent channel ID for the category (UUID format).
 * @param props.categoryId Unique identifier of the category to be deleted (UUID
 *   format).
 * @path /aiCommerce/admin/channels/:channelId/categories/:categoryId
 * @accessor api.functional.aiCommerce.admin.channels.categories.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Parent channel ID for the category (UUID format). */
    channelId: string & tags.Format<"uuid">;

    /** Unique identifier of the category to be deleted (UUID format). */
    categoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/channels/:channelId/categories/:categoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.param("categoryId")(() => typia.assert(props.categoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
