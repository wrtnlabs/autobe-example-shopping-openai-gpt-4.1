import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceSection } from "../../../../../structures/IAiCommerceSection";
import { IPageIAiCommerceSection } from "../../../../../structures/IPageIAiCommerceSection";

/**
 * Create a new section for a given sales channel (ai_commerce_sections).
 *
 * Administrators can use this operation to establish a new section under a
 * sales channel, providing details such as code, name, is_active,
 * business_status, and display order, consistent with the ai_commerce_sections
 * table structure.
 *
 * The request body must satisfy all required and optional fields of
 * IAiCommerceSection.ICreate, and the endpoint will reject requests if
 * name/code uniqueness or validation constraints are violated within the parent
 * channel. All creations are audit-logged and subject to business workflow
 * rules, possibly triggering downstream events for reporting or campaign
 * launch. Only admin-level users are authorized to perform this operation.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the target channel
 * @param props.body Section creation parameters as per business and schema
 *   requirements
 * @path /aiCommerce/admin/channels/:channelId/sections
 * @accessor api.functional.aiCommerce.admin.channels.sections.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier for the target channel */
    channelId: string & tags.Format<"uuid">;

    /** Section creation parameters as per business and schema requirements */
    body: IAiCommerceSection.ICreate;
  };
  export type Body = IAiCommerceSection.ICreate;
  export type Response = IAiCommerceSection;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/channels/:channelId/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/sections`;
  export const random = (): IAiCommerceSection =>
    typia.random<IAiCommerceSection>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of channel sections for a specific sales
 * channel (ai_commerce_sections).
 *
 * This API operation returns a list of all sections configured within a given
 * sales channel, allowing advanced filtering, sorting, and pagination according
 * to business needs. The response contains key fields such as name, code,
 * operational status, business_status, and sort_order, as specified in the
 * ai_commerce_sections schema.
 *
 * Advanced search parameters (such as partial name match, business status,
 * is_active, and display order) should be supplied via the request body,
 * following the IAiCommerceSection.IRequest structure. The result is a paged
 * response optimized for management interfaces and channel analytics
 * workflows.
 *
 * This endpoint is typically restricted to admin users or channel operators,
 * supporting both maintenance and reporting scenarios. Validation and business
 * rules include enforcing visibility of only non-deleted, active sections
 * unless explicitly filtering for archived or deleted records.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the target channel
 * @param props.body Filtering, sorting, and pagination options for section
 *   search
 * @path /aiCommerce/admin/channels/:channelId/sections
 * @accessor api.functional.aiCommerce.admin.channels.sections.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the target channel */
    channelId: string & tags.Format<"uuid">;

    /** Filtering, sorting, and pagination options for section search */
    body: IAiCommerceSection.IRequest;
  };
  export type Body = IAiCommerceSection.IRequest;
  export type Response = IPageIAiCommerceSection.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/channels/:channelId/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/sections`;
  export const random = (): IPageIAiCommerceSection.ISummary =>
    typia.random<IPageIAiCommerceSection.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details of a single channel section within a given sales
 * channel (ai_commerce_sections).
 *
 * This API operation fetches details for a specific section within a given
 * channel, identified by its unique sectionId and channelId. The response
 * includes all key properties (code, name, operational status, business_status,
 * sort_order, etc.) as defined by the ai_commerce_sections model.
 *
 * Access control ensures that only administrators or privileged channel
 * managers can view sensitive business configuration and status details. The
 * endpoint supports audit and compliance checksâ€”returning only the latest
 * (non-deleted) state. Error handling includes visibility of not found,
 * deleted, or inaccessible results, supporting secure management dashboards or
 * integration pipelines.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the sales channel
 * @param props.sectionId Unique identifier for the channel section
 * @path /aiCommerce/admin/channels/:channelId/sections/:sectionId
 * @accessor api.functional.aiCommerce.admin.channels.sections.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the sales channel */
    channelId: string & tags.Format<"uuid">;

    /** Unique identifier for the channel section */
    sectionId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceSection;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/channels/:channelId/sections/:sectionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/sections/${encodeURIComponent(props.sectionId ?? "null")}`;
  export const random = (): IAiCommerceSection =>
    typia.random<IAiCommerceSection>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.param("sectionId")(() => typia.assert(props.sectionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update channel section configuration for a given sales channel
 * (ai_commerce_sections).
 *
 * This API operation enables administrators to adjust the properties of an
 * existing section within a sales channel, including updating code, name,
 * status, or display order. Path parameters specify both the target channel and
 * section.
 *
 * The request body follows IAiCommerceSection.IUpdate and must satisfy schema
 * constraints, including uniqueness of code/name within the channel and valid
 * state transitions (e.g., cannot set archived to active without prerequisite
 * checks). Audit trails record all changes, and errors will be returned for
 * missing, locked, or business-critical records. Only users with admin or
 * equivalent privileges can use this endpoint.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the sales channel
 * @param props.sectionId Unique identifier for the section to update
 * @param props.body Updated properties for the section entity according to
 *   schema and business logic
 * @path /aiCommerce/admin/channels/:channelId/sections/:sectionId
 * @accessor api.functional.aiCommerce.admin.channels.sections.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the sales channel */
    channelId: string & tags.Format<"uuid">;

    /** Unique identifier for the section to update */
    sectionId: string & tags.Format<"uuid">;

    /**
     * Updated properties for the section entity according to schema and
     * business logic
     */
    body: IAiCommerceSection.IUpdate;
  };
  export type Body = IAiCommerceSection.IUpdate;
  export type Response = IAiCommerceSection;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/channels/:channelId/sections/:sectionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/sections/${encodeURIComponent(props.sectionId ?? "null")}`;
  export const random = (): IAiCommerceSection =>
    typia.random<IAiCommerceSection>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.param("sectionId")(() => typia.assert(props.sectionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) a section from a sales channel (ai_commerce_sections).
 *
 * This API allows administrators to erase a specific section under a channel,
 * removing its record from ai_commerce_sections. Both the channelId and
 * sectionId must be specified in the path, and the operation is executed as a
 * hard delete since no soft delete restoration logic is specified in the
 * schema.
 *
 * The process must check business rules, such as not deleting active or core
 * sections critical for channel operation. Deletions are strictly reserved for
 * admin users and must be audit-logged for evidence and compliance. Error
 * handling covers non-existent, deleted, or protected sections and returns
 * clear responses for management auditing.
 *
 * @param props.connection
 * @param props.channelId Unique identifier for the parent channel
 * @param props.sectionId Unique identifier for the section to delete
 * @path /aiCommerce/admin/channels/:channelId/sections/:sectionId
 * @accessor api.functional.aiCommerce.admin.channels.sections.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the parent channel */
    channelId: string & tags.Format<"uuid">;

    /** Unique identifier for the section to delete */
    sectionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/channels/:channelId/sections/:sectionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/channels/${encodeURIComponent(props.channelId ?? "null")}/sections/${encodeURIComponent(props.sectionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("channelId")(() => typia.assert(props.channelId));
      assert.param("sectionId")(() => typia.assert(props.sectionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
