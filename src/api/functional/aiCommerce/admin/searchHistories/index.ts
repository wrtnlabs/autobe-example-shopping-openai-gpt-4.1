import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceSearchHistory } from "../../../../structures/IAiCommerceSearchHistory";
import { IPageIAiCommerceSearchHistory } from "../../../../structures/IPageIAiCommerceSearchHistory";

/**
 * Search, filter, and paginate user search histories for discovery analytics.
 *
 * This endpoint enables analytics teams or authorized admins to query search
 * histories by text query, user, filter context (e.g. device, locale), and date
 * range, supporting rich business insights about discovery behavior and
 * trends.
 *
 * Because of the sensitivity of search histories, especially those tied to PII,
 * access is restricted to admins with analytics, support, or compliance
 * needsâ€”it is not available to general users. Advanced parameters support
 * filtering by user, anonymization state, and aggregate calculation when
 * paginated over larger datasets.
 *
 * The response is a paginated, filtered dataset with summary stats as well as
 * individual logs for inspection or downstream analysis. Failed or unauthorized
 * access attempts are recorded, and rate-limiting/batch controls are enforced
 * for system stability.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination criteria to search
 *   discovery histories
 * @path /aiCommerce/admin/searchHistories
 * @accessor api.functional.aiCommerce.admin.searchHistories.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering, sorting, and pagination criteria to search discovery
     * histories
     */
    body: IAiCommerceSearchHistory.IRequest;
  };
  export type Body = IAiCommerceSearchHistory.IRequest;
  export type Response = IPageIAiCommerceSearchHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/searchHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/searchHistories";
  export const random = (): IPageIAiCommerceSearchHistory =>
    typia.random<IPageIAiCommerceSearchHistory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail of a specific user search history event for analytics or
 * compliance review.
 *
 * This endpoint retrieves a single search history event, identified by its
 * unique ID, including all relevant metadata: query string, filters used,
 * result count, timestamps, and user/session context.
 *
 * Access is strictly limited to admin users for compliance and analytic
 * traceability. All accesses are audit-logged with timestamp and identity of
 * reviewer to meet privacy and legal requirements. User context information is
 * only included when the corresponding legal basis exists (e.g., PII access
 * rights for compliance responds to legitimate business needs).
 *
 * The operation may redact or anonymize sensitive fields, depending on the
 * requesting user's permission and system configuration. Error handling
 * includes not found, unauthorized, or redacted scenarios, and all read
 * accesses are tracked for evidence and reporting.
 *
 * @param props.connection
 * @param props.searchHistoryId Unique identifier for the search history event
 *   to retrieve
 * @path /aiCommerce/admin/searchHistories/:searchHistoryId
 * @accessor api.functional.aiCommerce.admin.searchHistories.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the search history event to retrieve */
    searchHistoryId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceSearchHistory;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/searchHistories/:searchHistoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/searchHistories/${encodeURIComponent(props.searchHistoryId ?? "null")}`;
  export const random = (): IAiCommerceSearchHistory =>
    typia.random<IAiCommerceSearchHistory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("searchHistoryId")(() =>
        typia.assert(props.searchHistoryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
