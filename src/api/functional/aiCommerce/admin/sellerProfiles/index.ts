import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceSellerProfiles } from "../../../../structures/IAiCommerceSellerProfiles";
import { IPageIAiCommerceSellerProfiles } from "../../../../structures/IPageIAiCommerceSellerProfiles";

/**
 * Paginated search of seller profiles for admin-level moderation and analytics.
 *
 * Enables platform administrators to search and browse seller profiles from
 * ai_commerce_seller_profiles table. The operation supports advanced query
 * parameters for filtering by display name, approval status, and other core
 * profile attributes. Returns paginated data for high-volume moderation and
 * compliance operations.
 *
 * @param props.connection
 * @param props.body Filtering and pagination options for listing seller
 *   profiles.
 * @path /aiCommerce/admin/sellerProfiles
 * @accessor api.functional.aiCommerce.admin.sellerProfiles.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering and pagination options for listing seller profiles. */
    body: IAiCommerceSellerProfiles.IRequest;
  };
  export type Body = IAiCommerceSellerProfiles.IRequest;
  export type Response = IPageIAiCommerceSellerProfiles;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/sellerProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/sellerProfiles";
  export const random = (): IPageIAiCommerceSellerProfiles =>
    typia.random<IPageIAiCommerceSellerProfiles>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin retrieves a complete seller profile by ID for audit or moderation.
 *
 * This operation allows a platform administrator to retrieve all details for a
 * single seller profile, identified by its unique ID. All business, branding,
 * compliance, status, and audit fields as defined in the
 * ai_commerce_seller_profiles schema are retrieved and returned in the
 * response. This operation is restricted to admin-level roles, as seller
 * profile data often includes sensitive business/verification details.
 *
 * If a profile with the supplied ID does not exist, or if the caller is not an
 * authorized admin, the operation returns an error with a clear audit trail.
 *
 * @param props.connection
 * @param props.sellerProfileId Unique identifier of the seller profile to
 *   retrieve.
 * @path /aiCommerce/admin/sellerProfiles/:sellerProfileId
 * @accessor api.functional.aiCommerce.admin.sellerProfiles.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the seller profile to retrieve. */
    sellerProfileId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceSellerProfiles;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/sellerProfiles/:sellerProfileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/sellerProfiles/${encodeURIComponent(props.sellerProfileId ?? "null")}`;
  export const random = (): IAiCommerceSellerProfiles =>
    typia.random<IAiCommerceSellerProfiles>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerProfileId")(() =>
        typia.assert(props.sellerProfileId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing seller profile (ai_commerce_seller_profiles table) for the
 * specified sellerProfileId.
 *
 * This API endpoint allows a seller (or platform admin) to update their profile
 * information, such as display_name, profile_metadata, approval_status, and
 * suspension_reason if needed. All field changes are subject to validation
 * according to the database schema constraints, ensuring required fields and
 * uniqueness are preserved.
 *
 * Security and permission checks require that the requesting user be the
 * profile owner (seller) or an admin operator, with actions fully audit logged.
 * Business rules may enforce further restrictions based on approval status or
 * suspension state.
 *
 * On success, the full updated seller profile is returned. If the profile is
 * not found, or if the user is unauthorized or submits invalid data, the system
 * returns appropriate business or validation errors. The update is strictly
 * recorded for audit and compliance purposes.
 *
 * @param props.connection
 * @param props.sellerProfileId Unique identifier for the seller profile being
 *   updated.
 * @param props.body Payload of fields to update in the seller profile,
 *   according to the DB schema.
 * @path /aiCommerce/admin/sellerProfiles/:sellerProfileId
 * @accessor api.functional.aiCommerce.admin.sellerProfiles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the seller profile being updated. */
    sellerProfileId: string & tags.Format<"uuid">;

    /**
     * Payload of fields to update in the seller profile, according to the
     * DB schema.
     */
    body: IAiCommerceSellerProfiles.IUpdate;
  };
  export type Body = IAiCommerceSellerProfiles.IUpdate;
  export type Response = IAiCommerceSellerProfiles;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/sellerProfiles/:sellerProfileId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/sellerProfiles/${encodeURIComponent(props.sellerProfileId ?? "null")}`;
  export const random = (): IAiCommerceSellerProfiles =>
    typia.random<IAiCommerceSellerProfiles>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerProfileId")(() =>
        typia.assert(props.sellerProfileId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete (hard remove) a seller profile for the specified
 * sellerProfileId.
 *
 * This API operation performs a hard deletion of a seller profile from the
 * ai_commerce_seller_profiles table, identified by sellerProfileId. No soft
 * delete exists for this entity, so deletion is irreversible and data is fully
 * removed from the database. This API can only be used by the owning seller or
 * an administrator following explicit business rules and audit protocols.
 *
 * Before deletion, the system checks for related dependencies to prevent
 * referential integrity violations (e.g., linked stores, analytics).
 * Authorization enforcement is strict and every delete operation is audit
 * logged for regulatory and legal compliance.
 *
 * If the profile exists and is deletable, the operation completes without
 * returning a body. Errors are raised if the profile is not found, the user is
 * unauthorized, or dependent references prevent deletion. This endpoint is not
 * used for soft-deletion scenarios.
 *
 * @param props.connection
 * @param props.sellerProfileId Unique identifier for the seller profile to
 *   delete (UUID).
 * @path /aiCommerce/admin/sellerProfiles/:sellerProfileId
 * @accessor api.functional.aiCommerce.admin.sellerProfiles.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the seller profile to delete (UUID). */
    sellerProfileId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/sellerProfiles/:sellerProfileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/sellerProfiles/${encodeURIComponent(props.sellerProfileId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerProfileId")(() =>
        typia.assert(props.sellerProfileId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
