import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceOrder } from "../../../../structures/IAiCommerceOrder";
import { IPageIAiCommerceOrder } from "../../../../structures/IPageIAiCommerceOrder";
export * as items from "./items/index";
export * as subOrders from "./subOrders/index";
export * as statusHistory from "./statusHistory/index";
export * as fulfillments from "./fulfillments/index";
export * as afterSales from "./afterSales/index";
export * as cancellations from "./cancellations/index";
export * as refunds from "./refunds/index";
export * as analytics from "./analytics/index";
export * as snapshots from "./snapshots/index";
export * as auditLogs from "./auditLogs/index";

/**
 * Place (create) a new order through checkout (ai_commerce_orders).
 *
 * Create a new order with all provided details and line items. This operation
 * is invoked at checkout, processing the purchase request, generating a global
 * and channel order code, assigning items to sellers, and locking in price,
 * currency, and address snapshot in ai_commerce_orders.
 *
 * Integrated checks enforce business requirements, such as item and variant
 * availability (inventory), compliance with purchase policy, payment amount
 * calculation, and address/data snapshotting. After success, the operation
 * returns the created order as per the defined schema, with all linked data.
 *
 * Admin-level permissions are required, and the entire creation process is
 * strictly audited. Error handling covers invalid cart, insufficient stock,
 * expired address, or payment failure. This is the canonical endpoint for order
 * placement and lifecycle initiation.
 *
 * @param props.connection
 * @param props.body Order creation request including buyer, channel, item
 *   detail, payment, and address snapshot references.
 * @path /aiCommerce/admin/orders
 * @accessor api.functional.aiCommerce.admin.orders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Order creation request including buyer, channel, item detail,
     * payment, and address snapshot references.
     */
    body: IAiCommerceOrder.ICreate;
  };
  export type Body = IAiCommerceOrder.ICreate;
  export type Response = IAiCommerceOrder;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/admin/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/orders";
  export const random = (): IAiCommerceOrder =>
    typia.random<IAiCommerceOrder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Advanced search and retrieval of a filtered, paginated list of orders
 * (ai_commerce_orders).
 *
 * Retrieve a filtered and paginated list of orders from the system. This
 * operation provides advanced search capabilities to locate orders based on
 * order code, status, buyer information, channel, payment status, amount,
 * period, and other attributes as defined in the ai_commerce_orders table.
 *
 * Comprehensive pagination is supported, enabling configurable page sizes and
 * sorting by creation date, status, channel, or amount in either ascending or
 * descending order. This endpoint is used by admins and authorized staff to
 * monitor, audit, or act upon orders at every stage in their business
 * lifecycle.
 *
 * Security considerations include strict role-based access controls to limit
 * visibility and manipulation of order data to authorized personnel only, with
 * all search and retrieval activities needing to be recorded for compliance and
 * audit.
 *
 * The operation works against the ai_commerce_orders schema and includes all
 * available order fields and relations necessary for operational transparency
 * and decision-making.
 *
 * @param props.connection
 * @param props.body Search and filter criteria, pagination, and sorting
 *   parameters for retrieving orders.
 * @path /aiCommerce/admin/orders
 * @accessor api.functional.aiCommerce.admin.orders.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter criteria, pagination, and sorting parameters for
     * retrieving orders.
     */
    body: IAiCommerceOrder.IRequest;
  };
  export type Body = IAiCommerceOrder.IRequest;
  export type Response = IPageIAiCommerceOrder;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/admin/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/admin/orders";
  export const random = (): IPageIAiCommerceOrder =>
    typia.random<IPageIAiCommerceOrder>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details on a single order (ai_commerce_orders) by orderId.
 *
 * Get all detailed information about a specific order identified by an orderId.
 * This operation is essential for order management and customer support,
 * enabling in-depth inspection of the order's lifecycle, status, payment,
 * delivery, and history.
 *
 * Permission to access this endpoint is restricted to admins or authorized
 * staff, as the operation may expose sensitive buyer and transaction details.
 * Proper logging and compliance monitoring are enforced for every request.
 *
 * Returned data is fully aligned with the ai_commerce_orders schema, populating
 * all available relations, including items, status history, payments, refunds,
 * fulfillments, and compliance audit entries for the specified order.
 *
 * @param props.connection
 * @param props.orderId Unique identifier (UUID) of the order to retrieve.
 * @path /aiCommerce/admin/orders/:orderId
 * @accessor api.functional.aiCommerce.admin.orders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the order to retrieve. */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceOrder;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/admin/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IAiCommerceOrder =>
    typia.random<IAiCommerceOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing order (ai_commerce_orders) by orderId.
 *
 * Update an existing order by its unique orderId, making permitted changes to
 * address, business status, or workflow fields as allowed by the order status
 * and the ai_commerce_orders schema. This endpoint is essential for compliance
 * actions (e.g., after-sales acceptance, admin status change, address
 * correction before fulfillment).
 *
 * This endpoint is secured for admin use, with all transition validation
 * performed according to the latest state of the order, and with a full audit
 * trail. Integration with related tables ensures business logic is enforced
 * across all referenced data (items, payments, fulfillment, snapshots).
 * Rejected updates and error cases, such as addressing immutable fields after
 * fulfillment or compliance violation, will provide actionable feedback for
 * resolution.
 *
 * @param props.connection
 * @param props.orderId Unique identifier (UUID) of the order to update.
 * @param props.body Order update request (only allowed fields per status/logic)
 * @path /aiCommerce/admin/orders/:orderId
 * @accessor api.functional.aiCommerce.admin.orders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the order to update. */
    orderId: string & tags.Format<"uuid">;

    /** Order update request (only allowed fields per status/logic) */
    body: IAiCommerceOrder.IUpdate;
  };
  export type Body = IAiCommerceOrder.IUpdate;
  export type Response = IAiCommerceOrder;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/admin/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IAiCommerceOrder =>
    typia.random<IAiCommerceOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (mark deleted) an order (ai_commerce_orders) by orderId.
 *
 * Mark an order as deleted in the system by setting the deleted_at field using
 * the orderId, while retaining data for compliance, audit, and historical
 * review. This is a soft delete operation as defined by the ai_commerce_orders
 * schema, and it does not remove the order from storage but marks it as
 * logically deleted.
 *
 * This operation is permissioned for admin roles, with all deletion requests
 * being recorded in compliance/audit logs, including reason, actor, and timing.
 * The operation will return a confirmation upon successful soft deletion.
 * Orders involved in payment, after-sales, or dispute flows cannot be
 * physically removed but will be marked deleted for access/recovery workflows.
 *
 * @param props.connection
 * @param props.orderId Unique identifier (UUID) of the order to mark as
 *   deleted.
 * @path /aiCommerce/admin/orders/:orderId
 * @accessor api.functional.aiCommerce.admin.orders.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the order to mark as deleted. */
    orderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/admin/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
