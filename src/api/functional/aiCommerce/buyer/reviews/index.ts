import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceReview } from "../../../../structures/IAiCommerceReview";
import { IPageIAiCommerceReview } from "../../../../structures/IPageIAiCommerceReview";
export * as comments from "./comments/index";

/**
 * Create a new review for an order item (ai_commerce_reviews).
 *
 * Creates a review for a purchased product under ai_commerce_reviews,
 * referencing a completed order item. Verifies eligibility and ownership,
 * validates required fields (text body, numeric rating, visibility), and links
 * the review to the order item. Prevents duplicate reviews per order item as
 * per schema uniqueness constraint.
 *
 * Buyers may only create reviews for their own completed purchases. Sellers and
 * admins cannot create reviews through this endpoint. The system enforces
 * business rules, executes moderation checks, logs the event for compliance,
 * and triggers notification or incentives as necessary. Validation errors,
 * unauthorized, or business rule violations result in descriptive error
 * responses.
 *
 * The response returns all review fields, suitable for immediate display or
 * further moderation/feedback workflows.
 *
 * @param props.connection
 * @param props.body Fields required to create a review, including order item,
 *   rating, body, and metadata.
 * @path /aiCommerce/buyer/reviews
 * @accessor api.functional.aiCommerce.buyer.reviews.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Fields required to create a review, including order item, rating,
     * body, and metadata.
     */
    body: IAiCommerceReview.ICreate;
  };
  export type Body = IAiCommerceReview.ICreate;
  export type Response = IAiCommerceReview;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/reviews";
  export const random = (): IAiCommerceReview =>
    typia.random<IAiCommerceReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list reviews with advanced filtering (ai_commerce_reviews).
 *
 * Returns a paginated, filtered list of reviews. The request body supports
 * search on ai_commerce_reviews fields such as author_id, order_item_id,
 * product, status, rating, as well as pagination and sort order. For buyers,
 * the results are filtered to reviews they've authored; sellers see reviews on
 * their products; admins can query all reviews.
 *
 * Business logic supports integration with moderation and reply flows.
 * Sensitive fields such as seller responses may be included/excluded based on
 * requester role. Errors cover invalid filters, unauthorized access, or
 * database issues. The response is designed for UI summary display but can be
 * expanded with query flags as permitted by business rules.
 *
 * The operation is often used in conjunction with review creation or detail
 * endpoints in review dashboards.
 *
 * @param props.connection
 * @param props.body Review filter/search parameters and pagination/sort
 *   options.
 * @path /aiCommerce/buyer/reviews
 * @accessor api.functional.aiCommerce.buyer.reviews.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Review filter/search parameters and pagination/sort options. */
    body: IAiCommerceReview.IRequest;
  };
  export type Body = IAiCommerceReview.IRequest;
  export type Response = IPageIAiCommerceReview.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/reviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/reviews";
  export const random = (): IPageIAiCommerceReview.ISummary =>
    typia.random<IPageIAiCommerceReview.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detail of a specific review (ai_commerce_reviews).
 *
 * Fetches a single review from ai_commerce_reviews using the provided reviewId.
 * Enforces permission based on user role and resource ownership: buyers access
 * their own reviews, sellers their product reviews, admins all reviews. The
 * response includes all base fields and related data such as order_item_id,
 * timestamps, statuses, reply if any, and compliance information.
 *
 * Handles business validation for existence, access, and context. Errors are
 * returned when review is missing, permission is denied, or lookup fails. This
 * operation is integral to review detail UIs and supports chaining with comment
 * and moderation functionality.
 *
 * Complies with all audit/logging requirements, and supports future
 * extensibility for reply threads or media attachments if permitted.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review to retrieve.
 * @path /aiCommerce/buyer/reviews/:reviewId
 * @accessor api.functional.aiCommerce.buyer.reviews.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the review to retrieve. */
    reviewId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceReview;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IAiCommerceReview =>
    typia.random<IAiCommerceReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the content, rating, or seller response of a review
 * (ai_commerce_reviews table).
 *
 * This API allows an authenticated user (buyer, seller, or admin) to update an
 * existing review, altering its content, numeric score, visibility, or, in the
 * case of sellers, providing a response.
 *
 * The operation enforces role-based permissions: buyers can only update their
 * own reviews, sellers can set/edit their response only for reviews written
 * about their products, and admins can perform global moderation. It requires
 * full verification that the review exists, has not been deleted, and that the
 * acting user has sufficient rights. All modifications are snapshotted for
 * audit, version history, and legal recovery.
 *
 * Validation ensures the rating falls within accepted bounds (as governed by
 * the UI/system config), the comment length is reasonable, and all edits comply
 * with platform community guidelines. In case of failure (e.g., editing a
 * non-existent or already deleted review, or insufficient permissions), the API
 * returns a detailed error conforming to compliance/error-handling
 * requirements.
 *
 * This endpoint works in conjunction with the review editing history,
 * notification, and moderation logic. Any update will trigger history recording
 * and downstream notification workflows according to user preferences and audit
 * rules.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier for the review to be updated.
 * @param props.body Review update data (content, rating, visibility, seller
 *   response, etc) as per IAiCommerceReview.IUpdate schema.
 * @path /aiCommerce/buyer/reviews/:reviewId
 * @accessor api.functional.aiCommerce.buyer.reviews.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the review to be updated. */
    reviewId: string & tags.Format<"uuid">;

    /**
     * Review update data (content, rating, visibility, seller response,
     * etc) as per IAiCommerceReview.IUpdate schema.
     */
    body: IAiCommerceReview.IUpdate;
  };
  export type Body = IAiCommerceReview.IUpdate;
  export type Response = IAiCommerceReview;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/reviews/:reviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): IAiCommerceReview =>
    typia.random<IAiCommerceReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete a review by marking it as deleted (ai_commerce_reviews
 * table).
 *
 * This API allows an authenticated buyer, seller, or admin to logically remove
 * a review by updating its deleted_at timestamp, ensuring that deleted reviews
 * are retained for legal, compliance, and audit purposes.
 *
 * Buyers are restricted to deleting their own reviews; sellers can only delete
 * reviews of their own products (typically for moderation within policy), and
 * admins can execute deletions globally. Successful invocation sets the
 * deleted_at field rather than fully removing the underlying record, in
 * accordance with platform UGC policies and audit guidelines.
 *
 * This operation supports platform compliance rules, making logically deleted
 * reviews unavailable for standard user queries but preserving them in the
 * system for evidence recovery. Detailed error codes are returned if the review
 * does not exist, is already deleted, or the calling party lacks sufficient
 * privileges. The deletion event is snapshotted and added to the review's
 * audit/edit history for forensics.
 *
 * Use in conjunction with review restoration or audit APIs as dictated by legal
 * recovery, compliance, or investigative workflows.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier for the review to be logically
 *   deleted.
 * @path /aiCommerce/buyer/reviews/:reviewId
 * @accessor api.functional.aiCommerce.buyer.reviews.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the review to be logically deleted. */
    reviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/reviews/:reviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/reviews/${encodeURIComponent(props.reviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
