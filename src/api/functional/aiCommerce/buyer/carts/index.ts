import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCart } from "../../../../structures/IAiCommerceCart";
import { IPageIAiCommerceCart } from "../../../../structures/IPageIAiCommerceCart";
export * as items from "./items/index";
export * as itemOptions from "./itemOptions/index";

/**
 * Create a new shopping cart (ai_commerce_carts) for buyer or guest session.
 *
 * This operation initializes a new shopping cart in the ai_commerce_carts table
 * for either an authenticated buyer (user) or a guest (using session tracking).
 * Optionally, the request may specify a linked store for store-centric
 * checkout.
 *
 * Carts automatically attach default status and timestamps, and are unique per
 * buyer session. For guests, device/cookie/session token associations are
 * provisioned. Cart creation logic includes audit record and supports cart
 * merging if a previous draft exists for this user/session.
 *
 * Upon successful creation, returns the full cart model, including primary key
 * and relevant metadata. Access, privacy, and session logic follow platform
 * data protections and audit trails.
 *
 * @param props.connection
 * @param props.body Shopping cart creation request—may include
 *   buyer/store/session references as needed.
 * @path /aiCommerce/buyer/carts
 * @accessor api.functional.aiCommerce.buyer.carts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Shopping cart creation request—may include buyer/store/session
     * references as needed.
     */
    body: IAiCommerceCart.ICreate;
  };
  export type Body = IAiCommerceCart.ICreate;
  export type Response = IAiCommerceCart;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/carts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/carts";
  export const random = (): IAiCommerceCart => typia.random<IAiCommerceCart>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of shopping carts (ai_commerce_carts)
 * with advanced filtering.
 *
 * This operation returns a paginated, optionally filtered collection of
 * shopping cart records from the ai_commerce_carts table. Carts may belong to
 * registered buyers or represent guest/anonymous sessions, with data filtered
 * according to the user's role and permissions.
 *
 * Supports searching by status (active, draft, checked_out, expired), total
 * quantity, store association, timestamps, and buyer identity (where
 * permitted). Multiple query filters and sorting can be applied for analytics
 * or cross-device cart management.
 *
 * The response provides summary information (cart id, status, total items,
 * associated store and buyer if applicable, timestamps) to support shopping
 * experiences and administrative management. Security is handled to ensure no
 * unauthorized cart cross-access; buyers may view only their own carts, admins
 * can search across all records.
 *
 * Audit trails and data privacy policies are enforced in the query logic, in
 * accordance with platform rules.
 *
 * @param props.connection
 * @param props.body Filtering and pagination options for searching shopping
 *   carts.
 * @path /aiCommerce/buyer/carts
 * @accessor api.functional.aiCommerce.buyer.carts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering and pagination options for searching shopping carts. */
    body: IAiCommerceCart.IRequest;
  };
  export type Body = IAiCommerceCart.IRequest;
  export type Response = IPageIAiCommerceCart.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/carts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/carts";
  export const random = (): IPageIAiCommerceCart.ISummary =>
    typia.random<IPageIAiCommerceCart.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single shopping cart detail by ID (ai_commerce_carts) for owner or
 * admin.
 *
 * This operation returns the full shopping cart record for a given cartId
 * (ai_commerce_carts primary key), including buyer details (if present),
 * associated store info, cart item list, and audit-compliant timestamps.
 * Intended for enabling the buyer's multi-session shopping continuity,
 * cross-device recovery, or admin purposes.
 *
 * Buyers may use this endpoint to resume, review, or recover their own
 * pending/active cart. Admins may use it for diagnostics or support. Strict
 * access control ensures cart data remains private to the owner; guest carts
 * require secure session tracking. Inactive/deleted/expired carts are presented
 * only if platform policy allows.
 *
 * Relations—cart items, buyer/store references—are eager-loaded to minimize
 * round trips in client UX.
 *
 * Security, privacy consent, and audit logging are followed in line with
 * platform compliance. Errors are returned for unauthorized access, missing or
 * invalid cart IDs.
 *
 * @param props.connection
 * @param props.cartId UUID of the shopping cart to retrieve.
 * @path /aiCommerce/buyer/carts/:cartId
 * @accessor api.functional.aiCommerce.buyer.carts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the shopping cart to retrieve. */
    cartId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceCart;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): IAiCommerceCart => typia.random<IAiCommerceCart>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update attributes of an existing shopping cart (ai_commerce_carts) by ID.
 *
 * This operation updates the main properties of an existing cart
 * (ai_commerce_carts) including status (e.g., activating, expiring), associated
 * store reference, or cart-level notes (if platform supports). Not intended for
 * adding/removing items—use item endpoints for those actions.
 *
 * Only the cart owner (buyer) or an admin may update their cart. Platform rules
 * enforce that only valid status transitions, and denial of concurrent
 * conflicting changes, are permitted. All updates produce audit log entries for
 * legal and troubleshooting purposes. Error responses are returned for
 * unauthorized updates, invalid status transitions, or data constraint
 * violations.
 *
 * @param props.connection
 * @param props.cartId UUID of the shopping cart to update.
 * @param props.body Fields to update in the shopping cart (status, store, or
 *   allowed modifications).
 * @path /aiCommerce/buyer/carts/:cartId
 * @accessor api.functional.aiCommerce.buyer.carts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the shopping cart to update. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the shopping cart (status, store, or allowed
     * modifications).
     */
    body: IAiCommerceCart.IUpdate;
  };
  export type Body = IAiCommerceCart.IUpdate;
  export type Response = IAiCommerceCart;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/carts/:cartId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): IAiCommerceCart => typia.random<IAiCommerceCart>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (logical removal) of a shopping cart (ai_commerce_carts) by ID,
 * preserving for audit/compliance.
 *
 * This operation marks a shopping cart as deleted (ai_commerce_carts),
 * performing a soft delete by setting the deleted_at timestamp without
 * physically erasing the row from the database. Only the cart's owner (buyer)
 * or a platform admin may initiate this removal.
 *
 * The logical deletion preserves the cart for possible recovery, platform
 * analytics, and legal evidence retention per privacy law. All delete
 * operations are entered into the audit log with actor and before/after state
 * snapshots. If a cart is referenced by orders, merges, or other entities,
 * deletion is allowed only if business integrity is unaffected. Errors result
 * for unauthorized or invalid delete actions.
 *
 * @param props.connection
 * @param props.cartId UUID of the shopping cart to delete (soft-delete).
 * @path /aiCommerce/buyer/carts/:cartId
 * @accessor api.functional.aiCommerce.buyer.carts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the shopping cart to delete (soft-delete). */
    cartId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/carts/:cartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
