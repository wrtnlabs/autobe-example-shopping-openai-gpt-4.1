import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCartItem } from "../../../../../structures/IAiCommerceCartItem";
import { IPageIAiCommerceCartItem } from "../../../../../structures/IPageIAiCommerceCartItem";

/**
 * Add a new item (ai_commerce_cart_items) to a shopping cart by cartId
 * (ai_commerce_carts).
 *
 * Creates a new cart item in ai_commerce_cart_items for a specified cart (by
 * cartId). Request specifies product/variant, quantity, and option selections
 * if applicable. The operation validates product existence, inventory, cart
 * status (must be open), and merges with existing item if same
 * product/variant/options already present, incrementing quantity up to limits.
 *
 * Triggers cart-level recalculation for total quantity and status, returns the
 * newly created/merged cart item as confirmation. Only the cart's owner (buyer)
 * or admin can add items. Audit trails, error scenarios (insufficient
 * inventory/invalid product) handled as per business logic.
 *
 * @param props.connection
 * @param props.cartId UUID of the cart to add the item to.
 * @param props.body Details of the item to add to the cart, including
 *   product/variant reference, options, and quantity.
 * @path /aiCommerce/buyer/carts/:cartId/items
 * @accessor api.functional.aiCommerce.buyer.carts.items.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the cart to add the item to. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Details of the item to add to the cart, including product/variant
     * reference, options, and quantity.
     */
    body: IAiCommerceCartItem.ICreate;
  };
  export type Body = IAiCommerceCartItem.ICreate;
  export type Response = IAiCommerceCartItem;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/carts/:cartId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/items`;
  export const random = (): IAiCommerceCartItem =>
    typia.random<IAiCommerceCartItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated, filterable list of cart items (ai_commerce_cart_items)
 * from a specific cart.
 *
 * This operation lists or searches the set of items present in the specified
 * shopping cart (specified by cartId, referencing ai_commerce_cart_items for
 * that cart). Returns paginated detail including item product/variant
 * associations, selected options, quantity, price snapshot, and status.
 *
 * Useful for client UIs, analytics, pre-checkout validation, or cart content
 * auditing. Query filters (by product, variant, status) and pagination controls
 * support performance for carts with large item counts. Buyers see only their
 * own cart's contents; admins may use for diagnostics. Errors are returned for
 * ownership mismatch or invalid cart reference.
 *
 * @param props.connection
 * @param props.cartId UUID of the cart whose items you want to list.
 * @param props.body Query parameters and filters for cart item search or
 *   paging.
 * @path /aiCommerce/buyer/carts/:cartId/items
 * @accessor api.functional.aiCommerce.buyer.carts.items.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the cart whose items you want to list. */
    cartId: string & tags.Format<"uuid">;

    /** Query parameters and filters for cart item search or paging. */
    body: IAiCommerceCartItem.IRequest;
  };
  export type Body = IAiCommerceCartItem.IRequest;
  export type Response = IPageIAiCommerceCartItem.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/carts/:cartId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/items`;
  export const random = (): IPageIAiCommerceCartItem.ISummary =>
    typia.random<IPageIAiCommerceCartItem.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single cart item detail (ai_commerce_cart_items) by cartId/itemId.
 *
 * Returns a detailed record for one cart item, by cartId and cartItemId.
 * Includes product/variant data, selected options, pricing at time of addition,
 * quantity, and audit timestamps. Owner (buyer) or admin can fetch their own
 * cart's item. Use for rendering cart item inspection screens or preparing for
 * item update/deletion.
 *
 * Access is limited to the cart owner (buyer) or admins. Error cases include
 * invalid IDs, mismatched cart ownership, or unauthorized access. The operation
 * loads all relevant relations, so clients need not fetch product separately.
 *
 * @param props.connection
 * @param props.cartId UUID of the cart which owns the item.
 * @param props.cartItemId UUID of the cart item to fetch.
 * @path /aiCommerce/buyer/carts/:cartId/items/:cartItemId
 * @accessor api.functional.aiCommerce.buyer.carts.items.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the cart which owns the item. */
    cartId: string & tags.Format<"uuid">;

    /** UUID of the cart item to fetch. */
    cartItemId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceCartItem;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/carts/:cartId/items/:cartItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/items/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): IAiCommerceCartItem =>
    typia.random<IAiCommerceCartItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific shopping cart item (ai_commerce_cart_items) for a buyer.
 *
 * Buyers can update a specific cart item by providing both the parent cart ID
 * and the cart item ID as path parameters. Modifiable fields generally include
 * variant (if applicable) and quantity. Validation ensures the cart and item
 * are active, ownership is correct, and that the new product/variant/quantity
 * are allowed and available. Errors result if the references are invalid, the
 * item is no longer editable (e.g., already checked out/deleted), or the buyer
 * does not have ownership. The operation produces a fully updated cart item on
 * success. All business and audit rules are respected.
 *
 * @param props.connection
 * @param props.cartId Unique ID of the parent shopping cart to which the item
 *   belongs.
 * @param props.cartItemId Unique ID of the cart item to update within the cart.
 * @param props.body Payload containing fields to update in the cart item, such
 *   as variant ID and quantity.
 * @path /aiCommerce/buyer/carts/:cartId/items/:cartItemId
 * @accessor api.functional.aiCommerce.buyer.carts.items.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique ID of the parent shopping cart to which the item belongs. */
    cartId: string & tags.Format<"uuid">;

    /** Unique ID of the cart item to update within the cart. */
    cartItemId: string & tags.Format<"uuid">;

    /**
     * Payload containing fields to update in the cart item, such as variant
     * ID and quantity.
     */
    body: IAiCommerceCartItem.IUpdate;
  };
  export type Body = IAiCommerceCartItem.IUpdate;
  export type Response = IAiCommerceCartItem;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/carts/:cartId/items/:cartItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/items/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): IAiCommerceCartItem =>
    typia.random<IAiCommerceCartItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) a cart item from a shopping cart
 * (ai_commerce_cart_items).
 *
 * Buyers can remove an item from their shopping cart by specifying both cart ID
 * and cart item ID. The operation marks the item as deleted, does not
 * physically remove it (supports audit traceability/compliance), and only
 * succeeds if the cart/item are valid and actively owned by the buyer. Errors
 * and denials occur for invalid references, unauthorized access, or
 * business-rule violations such as trying to delete already checked out items.
 * Maintains audit logs as required.
 *
 * @param props.connection
 * @param props.cartId Unique ID of the shopping cart.
 * @param props.cartItemId Unique ID of the cart item to be deleted.
 * @path /aiCommerce/buyer/carts/:cartId/items/:cartItemId
 * @accessor api.functional.aiCommerce.buyer.carts.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique ID of the shopping cart. */
    cartId: string & tags.Format<"uuid">;

    /** Unique ID of the cart item to be deleted. */
    cartItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/carts/:cartId/items/:cartItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/items/${encodeURIComponent(props.cartItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("cartItemId")(() => typia.assert(props.cartItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
