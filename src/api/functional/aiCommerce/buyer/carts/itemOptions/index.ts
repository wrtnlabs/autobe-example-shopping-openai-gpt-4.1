import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceCartItemOption } from "../../../../../structures/IAiCommerceCartItemOption";
import { IPageIAiCommerceCartItemOption } from "../../../../../structures/IPageIAiCommerceCartItemOption";

/**
 * Add a new cart item option (ai_commerce_cart_item_options) for a specific
 * cart.
 *
 * Buyers can add a new cart item option (e.g., size/color) by posting to their
 * cart's itemOptions subroute. The body (IAiCommerceCartItemOption.ICreate)
 * provides option details (option name, value, associated cartItem, etc.).
 * Security: only the cart owner may use this, and product/option validations
 * are enforced. Errors for unauthorized access, invalid options, or
 * business-rule conflicts. On success, returns the newly created option object
 * as defined in schema.
 *
 * @param props.connection
 * @param props.cartId Identifier of the shopping cart to which the option is
 *   being added.
 * @param props.body Information about the cart item option to be created
 *   (option name/value, associated cart item, etc.).
 * @path /aiCommerce/buyer/carts/:cartId/itemOptions
 * @accessor api.functional.aiCommerce.buyer.carts.itemOptions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the shopping cart to which the option is being added. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Information about the cart item option to be created (option
     * name/value, associated cart item, etc.).
     */
    body: IAiCommerceCartItemOption.ICreate;
  };
  export type Body = IAiCommerceCartItemOption.ICreate;
  export type Response = IAiCommerceCartItemOption;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/carts/:cartId/itemOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/itemOptions`;
  export const random = (): IAiCommerceCartItemOption =>
    typia.random<IAiCommerceCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list cart item options (ai_commerce_cart_item_options) for a
 * specific cart.
 *
 * Given a cart ID, an authenticated buyer can fetch a paginated/searchable list
 * of item option selections. Filtering and sorting logic are supplied in a
 * request body object per schema (IAiCommerceCartItemOption.IRequest). Enforces
 * buyer ownership, cart status, and security. The endpoint uses
 * ai_commerce_cart_item_options for the result, with audit-compliant business
 * logic. Proper path parameters, types, and role assignment ensure schema
 * conformance.
 *
 * @param props.connection
 * @param props.cartId Identifier of the shopping cart to retrieve item options
 *   from.
 * @param props.body Search, filter, and pagination criteria for listing cart
 *   item options.
 * @path /aiCommerce/buyer/carts/:cartId/itemOptions
 * @accessor api.functional.aiCommerce.buyer.carts.itemOptions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Identifier of the shopping cart to retrieve item options from. */
    cartId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination criteria for listing cart item
     * options.
     */
    body: IAiCommerceCartItemOption.IRequest;
  };
  export type Body = IAiCommerceCartItemOption.IRequest;
  export type Response = IPageIAiCommerceCartItemOption;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/carts/:cartId/itemOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/itemOptions`;
  export const random = (): IPageIAiCommerceCartItemOption =>
    typia.random<IPageIAiCommerceCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details for a specific cart item option (ai_commerce_cart_item_options)
 * by ID.
 *
 * A buyer can look up details for a specific item option in their cart by
 * providing both the parent cartId and optionId. The handler validates cart
 * existence, option presence, and buyer ownership. Returns full option data if
 * found and accessible. Denies or errors if the references are invalid, item is
 * deleted, or the buyer is unauthorized. All structure, access, and output
 * types match schema requirements.
 *
 * @param props.connection
 * @param props.cartId Identifier of the shopping cart containing the option.
 * @param props.itemOptionId Identifier of the specific cart item option to
 *   retrieve.
 * @path /aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId
 * @accessor api.functional.aiCommerce.buyer.carts.itemOptions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the shopping cart containing the option. */
    cartId: string & tags.Format<"uuid">;

    /** Identifier of the specific cart item option to retrieve. */
    itemOptionId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceCartItemOption;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/itemOptions/${encodeURIComponent(props.itemOptionId ?? "null")}`;
  export const random = (): IAiCommerceCartItemOption =>
    typia.random<IAiCommerceCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("itemOptionId")(() => typia.assert(props.itemOptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a cart item option (ai_commerce_cart_item_options) in a specific cart.
 *
 * Buyers may update a specific cart item option, such as changing value or name
 * (e.g., from 'Red' to 'Blue' for color, or updating size). Requires both
 * cartId and optionId as path params, verifies identities, and enforces
 * buyer-only access. Only allowed option names/values (per item/product) are
 * accepted. Output is the fully updated item option record, all
 * structure/statistics per schema.
 *
 * @param props.connection
 * @param props.cartId Identifier of the cart containing the option.
 * @param props.itemOptionId Identifier of the cart item option to update.
 * @param props.body Fields to update for the cart item option (option name,
 *   value, etc.).
 * @path /aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId
 * @accessor api.functional.aiCommerce.buyer.carts.itemOptions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the cart containing the option. */
    cartId: string & tags.Format<"uuid">;

    /** Identifier of the cart item option to update. */
    itemOptionId: string & tags.Format<"uuid">;

    /** Fields to update for the cart item option (option name, value, etc.). */
    body: IAiCommerceCartItemOption.IUpdate;
  };
  export type Body = IAiCommerceCartItemOption.IUpdate;
  export type Response = IAiCommerceCartItemOption;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/itemOptions/${encodeURIComponent(props.itemOptionId ?? "null")}`;
  export const random = (): IAiCommerceCartItemOption =>
    typia.random<IAiCommerceCartItemOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("itemOptionId")(() => typia.assert(props.itemOptionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) a cart item option (ai_commerce_cart_item_options) from
 * a cart.
 *
 * Buyers may delete a previously chosen cart item option by providing the
 * cartId and itemOptionId. The item is soft-deleted for compliance/audit
 * (preserved, not erased). Must be a valid cart/option and owned by the buyer.
 * Deny if ID invalid, ownership not present, or already deleted/checked out.
 * Confirms deletion by status (no body).
 *
 * @param props.connection
 * @param props.cartId ID of the shopping cart containing the option.
 * @param props.itemOptionId ID of the cart item option to remove.
 * @path /aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId
 * @accessor api.functional.aiCommerce.buyer.carts.itemOptions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the shopping cart containing the option. */
    cartId: string & tags.Format<"uuid">;

    /** ID of the cart item option to remove. */
    itemOptionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/carts/:cartId/itemOptions/:itemOptionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/carts/${encodeURIComponent(props.cartId ?? "null")}/itemOptions/${encodeURIComponent(props.itemOptionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("cartId")(() => typia.assert(props.cartId));
      assert.param("itemOptionId")(() => typia.assert(props.itemOptionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
