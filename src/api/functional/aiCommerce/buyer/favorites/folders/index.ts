import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceFavoritesFolder } from "../../../../../structures/IAiCommerceFavoritesFolder";
import { IPageIAiCommerceFavoritesFolder } from "../../../../../structures/IPageIAiCommerceFavoritesFolder";

/**
 * Create a new favorites folder for grouping saved items for a buyer
 * (ai_commerce_favorites_folders table).
 *
 * This API endpoint allows an authenticated buyer to create an organizational
 * folder in their favorites collection.
 *
 * Upon invocation, the system ensures the provided folder name is unique to the
 * user and links the folder to the requesting buyer's account. Descriptions
 * (optional) support explanatory or categorizing detail. The operation
 * implements strict validation against duplicate names, prohibited characters,
 * and length limits. When successful, the new folder is immediately available
 * for organizing product, inquiry, or address favorites.
 *
 * Security is enforceable by 'buyer' role authentication. Attempts by
 * unauthorized roles are rejected. The operation references the
 * ai_commerce_favorites_folders table and follows all historical audit and
 * update mechanisms as specified in the Prisma schema commentary.
 *
 * Error handling covers name collisions, forbidden values, and authentication
 * failures. The folder is fully compliant with audit trails and organizational
 * enforcement for user management of favorites. Follow-up actions may include
 * batch organization of existing or future favorites using the new folder.
 *
 * @param props.connection
 * @param props.body Information required to create a new favorites folder,
 *   including folder name and description.
 * @path /aiCommerce/buyer/favorites/folders
 * @accessor api.functional.aiCommerce.buyer.favorites.folders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create a new favorites folder, including
     * folder name and description.
     */
    body: IAiCommerceFavoritesFolder.ICreate;
  };
  export type Body = IAiCommerceFavoritesFolder.ICreate;
  export type Response = IAiCommerceFavoritesFolder;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/favorites/folders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/favorites/folders";
  export const random = (): IAiCommerceFavoritesFolder =>
    typia.random<IAiCommerceFavoritesFolder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve favorite folders for the authenticated user
 * (ai_commerce_favorites_folders).
 *
 * Returns a list of folders used to organize address, product, and inquiry
 * favorites for the current authenticated buyer or seller. Supports searching
 * by folder name, filtering, and advanced organizational structures. Pagination
 * and sorting options are included as per business needs. Each folder shown is
 * owned by the current user only.
 *
 * Security: Buyers or sellers are limited to viewing/managing their folders.
 * Edge cases like non-existent or already-deleted folders are handled
 * transparently, with audit logging as needed.
 *
 * The operation supports compliance requirements for organization, privacy, and
 * user experience business logic. It follows
 * IAiCommerceFavoritesFolder.IRequest request body and returns paginated
 * IAiCommerceFavoritesFolder.ISummary responses.
 *
 * @param props.connection
 * @param props.body Folder search, filter, and pagination criteria
 * @path /aiCommerce/buyer/favorites/folders
 * @accessor api.functional.aiCommerce.buyer.favorites.folders.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Folder search, filter, and pagination criteria */
    body: IAiCommerceFavoritesFolder.IRequest;
  };
  export type Body = IAiCommerceFavoritesFolder.IRequest;
  export type Response = IPageIAiCommerceFavoritesFolder.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/favorites/folders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/favorites/folders";
  export const random = (): IPageIAiCommerceFavoritesFolder.ISummary =>
    typia.random<IPageIAiCommerceFavoritesFolder.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific favorite folder by ID
 * (ai_commerce_favorites_folders).
 *
 * Fetches metadata and detailed information for a user's favorite folder,
 * including name, description, and organizational state. Ownership is verified,
 * and access is limited to the authenticated buyer or seller who owns the
 * folder. The operation ensures compliance and audit logging.
 *
 * Based on ai_commerce_favorites_folders, and keyed by folderId. Soft-deleted
 * or unauthorized access returns descriptive errors. Audit logic is in place as
 * needed for traceability.
 *
 * @param props.connection
 * @param props.folderId Unique identifier for the favorite folder record
 * @path /aiCommerce/buyer/favorites/folders/:folderId
 * @accessor api.functional.aiCommerce.buyer.favorites.folders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the favorite folder record */
    folderId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceFavoritesFolder;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/favorites/folders/:folderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/folders/${encodeURIComponent(props.folderId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesFolder =>
    typia.random<IAiCommerceFavoritesFolder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("folderId")(() => typia.assert(props.folderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the name or description of a buyer-owned favorites folder
 * (ai_commerce_favorites_folders).
 *
 * This endpoint allows an authenticated buyer to update the organizational
 * metadata of one of their existing favorites folders by folderId.
 *
 * The system verifies that the buyer owns the folder, prevents renaming to a
 * name already in use in another of the buyer's folders, and enforces all data
 * integrity rules noted in the table documentation. Edits may include changing
 * the folder name or description. Updates use server-side validation for field
 * limits, uniqueness, and character constraints.
 *
 * Audit logging records all updates for compliance and organizational tracking.
 * Ownership is strictly enforced, and any unauthorized update attempt (wrong
 * buyer or insufficient permissions) is rejected. The operation relies on the
 * ai_commerce_favorites_folders schema described in the Prisma file.
 *
 * Successful updates enable buyers to dynamically re-organize their saved
 * content. Errors include unauthorized access, duplicate folder names, or
 * validation issues with the updated data.
 *
 * @param props.connection
 * @param props.folderId Unique identifier of the favorites folder to update.
 * @param props.body Updated folder information: new name and/or description for
 *   the favorites folder.
 * @path /aiCommerce/buyer/favorites/folders/:folderId
 * @accessor api.functional.aiCommerce.buyer.favorites.folders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the favorites folder to update. */
    folderId: string & tags.Format<"uuid">;

    /**
     * Updated folder information: new name and/or description for the
     * favorites folder.
     */
    body: IAiCommerceFavoritesFolder.IUpdate;
  };
  export type Body = IAiCommerceFavoritesFolder.IUpdate;
  export type Response = IAiCommerceFavoritesFolder;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/favorites/folders/:folderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/favorites/folders/${encodeURIComponent(props.folderId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesFolder =>
    typia.random<IAiCommerceFavoritesFolder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("folderId")(() => typia.assert(props.folderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) a buyer-owned favorites folder from the system
 * (ai_commerce_favorites_folders).
 *
 * This API endpoint enables a buyer to remove one of their organizing folders
 * from favorites using the folderId parameter. Rather than physical deletion,
 * this is a soft delete, where the deleted_at field is set to the current
 * timestamp, making the folder unavailable for future organization operations
 * but retaining it for compliance/audit.
 *
 * The system checks for buyer ownership before proceeding and reassigns or
 * un-links contained favorites as prescribed by business rules (such as moving
 * favorites to a default folder or leaving them ungrouped).
 *
 * Security is enforced such that only the owner can delete their folder. Audit
 * trails reflect the action, including actor, timestamp, and before/after
 * folder state. The operation references the ai_commerce_favorites_folders
 * schema's description and policy for safe, reversible data deletion and
 * traceability.
 *
 * Error scenarios include attempts to delete non-owned folders, invalid IDs, or
 * folders already deleted. No response body is provided on success.
 *
 * @param props.connection
 * @param props.folderId Unique identifier of the favorites folder to remove.
 * @path /aiCommerce/buyer/favorites/folders/:folderId
 * @accessor api.functional.aiCommerce.buyer.favorites.folders.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the favorites folder to remove. */
    folderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/favorites/folders/:folderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/folders/${encodeURIComponent(props.folderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("folderId")(() => typia.assert(props.folderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
