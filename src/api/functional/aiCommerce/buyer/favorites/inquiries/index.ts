import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceFavoritesInquiries } from "../../../../../structures/IAiCommerceFavoritesInquiries";
import { IPageIAiCommerceFavoritesInquiries } from "../../../../../structures/IPageIAiCommerceFavoritesInquiries";

/**
 * Create a new inquiry favorite and return the stored record (with snapshot and
 * folder if assigned).
 *
 * Add a new favorite inquiry for the authenticated user. The request specifies
 * the inquiry ID to favorite, optional folder and label, and creates a snapshot
 * of the current state of the inquiry for evidence purposes. Uniqueness is
 * enforced per user and inquiry; attempting to favorite the same inquiry twice
 * triggers a validation error.
 *
 * Favoriting an inquiry powers features such as notification of answers, rapid
 * lookup, and organizational flows for the user. Only logged-in users may
 * favorite inquiries. The result includes the created favorite record, its
 * snapshot, and metadata.
 *
 * @param props.connection
 * @param props.body Required and optional data for favoriting a product
 *   inquiry.
 * @path /aiCommerce/buyer/favorites/inquiries
 * @accessor api.functional.aiCommerce.buyer.favorites.inquiries.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Required and optional data for favoriting a product inquiry. */
    body: IAiCommerceFavoritesInquiries.ICreate;
  };
  export type Body = IAiCommerceFavoritesInquiries.ICreate;
  export type Response = IAiCommerceFavoritesInquiries;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/favorites/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/favorites/inquiries";
  export const random = (): IAiCommerceFavoritesInquiries =>
    typia.random<IAiCommerceFavoritesInquiries>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search favorited product inquiries for the authenticated user.
 *
 * List or search the authenticated user's favorited product inquiries, allowing
 * filtering by folder, label, or inquiry state. The results are paginated and
 * optimized for user UX, enabling quick lookup and management. This operation
 * returns summary information suitable for lists, rather than detailed inquiry
 * content.
 *
 * Commonly paired with alert configuration, favorited inquiry notification
 * flows, and organizational management UIs. The operation only returns the
 * user's own favorites; unauthorized access returns an empty or error result.
 *
 * Errors occur for invalid filters or if the user is not authenticated. The
 * default sort order is by created date descending.
 *
 * @param props.connection
 * @param props.body Filtering and pagination options for favorited inquiries
 *   search.
 * @path /aiCommerce/buyer/favorites/inquiries
 * @accessor api.functional.aiCommerce.buyer.favorites.inquiries.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering and pagination options for favorited inquiries search. */
    body: IAiCommerceFavoritesInquiries.IRequest;
  };
  export type Body = IAiCommerceFavoritesInquiries.IRequest;
  export type Response = IPageIAiCommerceFavoritesInquiries.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/favorites/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/aiCommerce/buyer/favorites/inquiries";
  export const random = (): IPageIAiCommerceFavoritesInquiries.ISummary =>
    typia.random<IPageIAiCommerceFavoritesInquiries.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific inquiry favorite by
 * favoriteInquiryId.
 *
 * Fetch a specific inquiry favorite by its favoriteInquiryId, returning the
 * full detail as stored in ai_commerce_favorites_inquiries, including
 * organizational folder assignment, snapshot, and timestamps.
 *
 * This API supports per-user favorite management, compliance snapshot linking,
 * alert review, and organization. Only authenticated users can access their own
 * favorites, and errors are returned for missing, deleted, or unauthorized
 * favorites.
 *
 * The operation is commonly used to display favorite inquiry detail screens and
 * to support favorite update or notification review interfaces.
 *
 * @param props.connection
 * @param props.favoriteInquiryId The unique identifier for the inquiry favorite
 *   to retrieve.
 * @path /aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId
 * @accessor api.functional.aiCommerce.buyer.favorites.inquiries.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier for the inquiry favorite to retrieve. */
    favoriteInquiryId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceFavoritesInquiries;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/inquiries/${encodeURIComponent(props.favoriteInquiryId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesInquiries =>
    typia.random<IAiCommerceFavoritesInquiries>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteInquiryId")(() =>
        typia.assert(props.favoriteInquiryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update label, folder, or alert settings for an existing inquiry favorite by
 * favoriteInquiryId.
 *
 * Allows an authenticated user to update organizational metadata for an inquiry
 * favorite, such as changing its folder, updating a label, or adjusting alert
 * preferences. User authorization is required, and attempts to edit another
 * user's favorite or a deleted entry will fail.
 *
 * Content and snapshot linkage remain read-only for audit and compliance.
 * Updated records are returned in full, allowing front ends to reflect new
 * organization, alerts, or preferences immediately.
 *
 * @param props.connection
 * @param props.favoriteInquiryId The unique identifier of the inquiry favorite
 *   to update.
 * @param props.body Updatable organizational data for the inquiry favorite.
 * @path /aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId
 * @accessor api.functional.aiCommerce.buyer.favorites.inquiries.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the inquiry favorite to update. */
    favoriteInquiryId: string & tags.Format<"uuid">;

    /** Updatable organizational data for the inquiry favorite. */
    body: IAiCommerceFavoritesInquiries.IUpdate;
  };
  export type Body = IAiCommerceFavoritesInquiries.IUpdate;
  export type Response = IAiCommerceFavoritesInquiries;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/favorites/inquiries/${encodeURIComponent(props.favoriteInquiryId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesInquiries =>
    typia.random<IAiCommerceFavoritesInquiries>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteInquiryId")(() =>
        typia.assert(props.favoriteInquiryId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a favorite inquiry (soft delete) for the authenticated user
 * (ai_commerce_favorites_inquiries).
 *
 * Delete a user's favorite inquiry by marking it as deleted. The operation
 * verifies user permissions, favorite inquiry ownership, and ensures the
 * operation is auditable and compliant with the business logic in
 * ai_commerce_favorites_inquiries.
 *
 * Security consideration: Accessible only to authenticated buyers or sellers
 * who own the favorite inquiry. Soft deletion preserves record integrity and
 * audit logging for evidence.
 *
 * This operation references the Prisma schema's ai_commerce_favorites_inquiries
 * table, specifically utilizing the deleted_at column for soft removal. No data
 * is physically erased, satisfying compliance requirements for privacy and
 * legal retention.
 *
 * Business logic and ownership validation are enforced. Errors are returned if
 * the favorite does not exist, does not belong to the user, or has already been
 * deleted.
 *
 * @param props.connection
 * @param props.favoriteInquiryId Unique identifier of the favorite inquiry to
 *   remove
 * @path /aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId
 * @accessor api.functional.aiCommerce.buyer.favorites.inquiries.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the favorite inquiry to remove */
    favoriteInquiryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/favorites/inquiries/:favoriteInquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/inquiries/${encodeURIComponent(props.favoriteInquiryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteInquiryId")(() =>
        typia.assert(props.favoriteInquiryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
