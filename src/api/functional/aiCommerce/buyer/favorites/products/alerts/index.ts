import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAiCommerceFavoritesAlert } from "../../../../../../structures/IAiCommerceFavoritesAlert";

/**
 * Create a new alert trigger for a favorited product
 * (ai_commerce_favorites_alerts).
 *
 * When invoked, this endpoint allows the authenticated buyer to create an
 * additional alert configuration for a given favorited product, specifying the
 * alert trigger type (e.g., price_drop, restocked) and whether it should be
 * enabled.
 *
 * The system associates the new alert with both the favorite product and the
 * specific buyer, validating that no identical alert type already exists for
 * this favorite (as enforced by business uniqueness constraints). All provided
 * values are validated for correctness and compliance with the
 * ai_commerce_favorites_alerts schema commentary.
 *
 * Security checks ensure that only the owner of the favorite can add new
 * alerts, and all creations are fully audit logged. The resulting alert
 * configuration is returned in detail for immediate UI feedback or confirmation
 * to the buyer. Error cases cover forbidden IDs, invalid request types, or
 * attempts to create duplicate alert triggers for the same favorite.
 *
 * @param props.connection
 * @param props.favoriteProductId ID of the product favorite for alert creation.
 * @param props.body Details for a new alert trigger on a favorite product,
 *   including type and state (enabled/disabled).
 * @path /aiCommerce/buyer/favorites/products/:favoriteProductId/alerts
 * @accessor api.functional.aiCommerce.buyer.favorites.products.alerts.createAlert
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createAlert(
  connection: IConnection,
  props: createAlert.Props,
): Promise<createAlert.Response> {
  return true === connection.simulate
    ? createAlert.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createAlert.METADATA,
          path: createAlert.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createAlert {
  export type Props = {
    /** ID of the product favorite for alert creation. */
    favoriteProductId: string & tags.Format<"uuid">;

    /**
     * Details for a new alert trigger on a favorite product, including type
     * and state (enabled/disabled).
     */
    body: IAiCommerceFavoritesAlert.ICreate;
  };
  export type Body = IAiCommerceFavoritesAlert.ICreate;
  export type Response = IAiCommerceFavoritesAlert;

  export const METADATA = {
    method: "POST",
    path: "/aiCommerce/buyer/favorites/products/:favoriteProductId/alerts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/favorites/products/${encodeURIComponent(props.favoriteProductId ?? "null")}/alerts`;
  export const random = (): IAiCommerceFavoritesAlert =>
    typia.random<IAiCommerceFavoritesAlert>();
  export const simulate = (
    connection: IConnection,
    props: createAlert.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createAlert.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Configure or update alert trigger settings for a favorited product
 * (ai_commerce_favorites_alerts).
 *
 * This endpoint allows a buyer to configure or update alert settings on a
 * favorited product, such as enabling alerts for price changes, restocks, or
 * other defined business events.
 *
 * The system ensures the operation targets a favorite product record belonging
 * to the current buyer, validates changes to alert settings, and applies them
 * on the ai_commerce_favorites_alerts record(s). The underlying table supports
 * various alert types, enabling personalized notification for product changes.
 * All updates are strictly tied to favoriteProductId ownership and enforce
 * existing business and data integrity rules from the schema.
 *
 * Security is ensured by verifying buyer authentication and record ownership;
 * attempts to alter alert settings for others' favorites are denied. The result
 * includes the list of updated alert configurations. Detailed audit logs record
 * alert configuration changes for buyer accountability and historical
 * inspection.
 *
 * @param props.connection
 * @param props.favoriteProductId ID of the product favorite on which to update
 *   alert settings.
 * @param props.body List of updated alert configurations (enable/disable
 *   specific triggers) for the specified favorite product.
 * @path /aiCommerce/buyer/favorites/products/:favoriteProductId/alerts
 * @accessor api.functional.aiCommerce.buyer.favorites.products.alerts.updateAlerts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateAlerts(
  connection: IConnection,
  props: updateAlerts.Props,
): Promise<updateAlerts.Response> {
  return true === connection.simulate
    ? updateAlerts.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateAlerts.METADATA,
          path: updateAlerts.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateAlerts {
  export type Props = {
    /** ID of the product favorite on which to update alert settings. */
    favoriteProductId: string & tags.Format<"uuid">;

    /**
     * List of updated alert configurations (enable/disable specific
     * triggers) for the specified favorite product.
     */
    body: IAiCommerceFavoritesAlert.IUpdateRequest;
  };
  export type Body = IAiCommerceFavoritesAlert.IUpdateRequest;
  export type Response = IAiCommerceFavoritesAlert.IList;

  export const METADATA = {
    method: "PATCH",
    path: "/aiCommerce/buyer/favorites/products/:favoriteProductId/alerts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/favorites/products/${encodeURIComponent(props.favoriteProductId ?? "null")}/alerts`;
  export const random = (): IAiCommerceFavoritesAlert.IList =>
    typia.random<IAiCommerceFavoritesAlert.IList>();
  export const simulate = (
    connection: IConnection,
    props: updateAlerts.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateAlerts.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * View the details of a specific alert trigger on a favorited product
 * (ai_commerce_favorites_alerts).
 *
 * This API endpoint allows the buyer to view the details (trigger type, enabled
 * state, recent activity) of a specific notification alert configured for a
 * favorite product. Both favoriteProductId and alertId must be provided for
 * context and strict access validation, ensuring buyers cannot read alert
 * configurations on others' favorites.
 *
 * The response includes full metadata on the alert, such as trigger type,
 * state, and last triggered/modified information. Strong validation against
 * buyer ownership, valid IDs, and access rights is enforced, with any violation
 * resulting in a denied request.
 *
 * Audit logging records all data access for compliance. This operation
 * references the ai_commerce_favorites_alerts Prisma schema comments regarding
 * structure, relationships, and evidence requirements.
 *
 * @param props.connection
 * @param props.favoriteProductId ID of the product favorite related to the
 *   alert.
 * @param props.alertId ID of the specific alert configuration for this favorite
 *   product.
 * @path /aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId
 * @accessor api.functional.aiCommerce.buyer.favorites.products.alerts.atAlert
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atAlert(
  connection: IConnection,
  props: atAlert.Props,
): Promise<atAlert.Response> {
  return true === connection.simulate
    ? atAlert.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atAlert.METADATA,
          path: atAlert.path(props),
          status: null,
        },
      );
}
export namespace atAlert {
  export type Props = {
    /** ID of the product favorite related to the alert. */
    favoriteProductId: string & tags.Format<"uuid">;

    /** ID of the specific alert configuration for this favorite product. */
    alertId: string & tags.Format<"uuid">;
  };
  export type Response = IAiCommerceFavoritesAlert;

  export const METADATA = {
    method: "GET",
    path: "/aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/products/${encodeURIComponent(props.favoriteProductId ?? "null")}/alerts/${encodeURIComponent(props.alertId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesAlert =>
    typia.random<IAiCommerceFavoritesAlert>();
  export const simulate = (
    connection: IConnection,
    props: atAlert.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atAlert.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.param("alertId")(() => typia.assert(props.alertId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing alert configuration for a favorite product
 * (ai_commerce_favorites_alerts).
 *
 * This endpoint allows a buyer to update any configurable properties for an
 * existing alert on a favorited product, specified by both favoriteProductId
 * and alertId.
 *
 * The operation enforces that the alert is bound to the calling buyer and the
 * specified favorite product, and changes apply only to mutable fields (e.g.,
 * enabling/disabling, changing trigger type). Strict schema-driven validation
 * and business constraints (no duplicate alerts per type) are applied.
 *
 * Security is handled through ownership checks and record validation; all
 * actions are fully audit-logged for compliance. The updated alert
 * configuration is returned in the response on success. Possible error cases
 * include lack of ownership, forbidden edits, or constraint violations.
 *
 * @param props.connection
 * @param props.favoriteProductId ID of the product favorite associated with the
 *   alert to update.
 * @param props.alertId ID of the alert configuration to update.
 * @param props.body Updated alert trigger settings (enabled/disabled, type) for
 *   this favorite product alert.
 * @path /aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId
 * @accessor api.functional.aiCommerce.buyer.favorites.products.alerts.updateAlert
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateAlert(
  connection: IConnection,
  props: updateAlert.Props,
): Promise<updateAlert.Response> {
  return true === connection.simulate
    ? updateAlert.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateAlert.METADATA,
          path: updateAlert.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateAlert {
  export type Props = {
    /** ID of the product favorite associated with the alert to update. */
    favoriteProductId: string & tags.Format<"uuid">;

    /** ID of the alert configuration to update. */
    alertId: string & tags.Format<"uuid">;

    /**
     * Updated alert trigger settings (enabled/disabled, type) for this
     * favorite product alert.
     */
    body: IAiCommerceFavoritesAlert.IUpdate;
  };
  export type Body = IAiCommerceFavoritesAlert.IUpdate;
  export type Response = IAiCommerceFavoritesAlert;

  export const METADATA = {
    method: "PUT",
    path: "/aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/aiCommerce/buyer/favorites/products/${encodeURIComponent(props.favoriteProductId ?? "null")}/alerts/${encodeURIComponent(props.alertId ?? "null")}`;
  export const random = (): IAiCommerceFavoritesAlert =>
    typia.random<IAiCommerceFavoritesAlert>();
  export const simulate = (
    connection: IConnection,
    props: updateAlert.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateAlert.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.param("alertId")(() => typia.assert(props.alertId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) an alert trigger from a buyer’s favorite product
 * (ai_commerce_favorites_alerts).
 *
 * This API endpoint allows a buyer to remove an alert trigger from a favorite
 * product. Both the favorite product ID and alert configuration ID must be
 * provided, and the operation requires that the alert belongs to the buyer and
 * the correct favorite.
 *
 * Instead of a hard/physical delete, a soft delete approach sets the deleted_at
 * timestamp so that audit history and event evidence are preserved. Security
 * validation denies attempts by non-owners or mismatched favorite/alert pairs.
 * The operation follows the data integrity, audit, and compliance commentary of
 * the ai_commerce_favorites_alerts table.
 *
 * Typical errors handled include not-found pairs, unauthorized access, or
 * redundant deletions. No response body is returned for successful deletes.
 *
 * @param props.connection
 * @param props.favoriteProductId ID of the product favorite whose alert trigger
 *   should be deleted.
 * @param props.alertId Unique identifier of the alert trigger to delete.
 * @path /aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId
 * @accessor api.functional.aiCommerce.buyer.favorites.products.alerts.eraseAlert
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseAlert(
  connection: IConnection,
  props: eraseAlert.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseAlert.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseAlert.METADATA,
          path: eraseAlert.path(props),
          status: null,
        },
      );
}
export namespace eraseAlert {
  export type Props = {
    /** ID of the product favorite whose alert trigger should be deleted. */
    favoriteProductId: string & tags.Format<"uuid">;

    /** Unique identifier of the alert trigger to delete. */
    alertId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/aiCommerce/buyer/favorites/products/:favoriteProductId/alerts/:alertId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/aiCommerce/buyer/favorites/products/${encodeURIComponent(props.favoriteProductId ?? "null")}/alerts/${encodeURIComponent(props.alertId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseAlert.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseAlert.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.param("alertId")(() => typia.assert(props.alertId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
