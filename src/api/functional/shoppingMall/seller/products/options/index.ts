import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductOption } from "../../../../../structures/IShoppingMallProductOption";
import { IPageIShoppingMallProductOption } from "../../../../../structures/IPageIShoppingMallProductOption";

/**
 * Create a new option on a product (shopping_mall_product_options table).
 *
 * Creates a new option for the specified product by accepting option details
 * such as name, whether it is required, and its intended order for UI purposes.
 * Only sellers who own the product and admins can use this operation;
 * permission errors are returned for unauthorized attempts, with all such
 * events logged for compliance.
 *
 * Business validation ensures that the option name is unique per product,
 * required attributes are filled, and maximum option count per product is
 * enforced if applicable. The API creates the database record, updates search
 * indices, and triggers any necessary business rule workflows associated with
 * product option definition.
 *
 * Upon successful creation, the response returns the full option object. Error
 * handling addresses duplicate names, invalid product references, rejected
 * validation, or constraint violations. Extensible for future metadata fields
 * and localization attributes.
 *
 * @param props.connection
 * @param props.productId UUID of the product to which the new option will be
 *   added.
 * @param props.body Data required to create a new product option.
 * @path /shoppingMall/seller/products/:productId/options
 * @accessor api.functional.shoppingMall.seller.products.options.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the product to which the new option will be added. */
    productId: string & tags.Format<"uuid">;

    /** Data required to create a new product option. */
    body: IShoppingMallProductOption.ICreate;
  };
  export type Body = IShoppingMallProductOption.ICreate;
  export type Response = IShoppingMallProductOption;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products/:productId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options`;
  export const random = (): IShoppingMallProductOption =>
    typia.random<IShoppingMallProductOption>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of options for a specified product
 * (shopping_mall_product_options table).
 *
 * Fetches a list of all options linked to a particular product, providing
 * support for advanced filtering, sorting, and pagination to accommodate large
 * datasets and complex UIs. The response includes both required and optional
 * options, ordered by the UI display position, and indicates option names and
 * requirements as stored in the shopping_mall_product_options table.
 *
 * Role-based access ensures that sellers (owners of the product), admins, and
 * authorized business users can access this endpoint. Sensitive or hidden
 * option information is excluded according to the user's permissions and
 * business rules. In case the product does not exist, permission is
 * insufficient, or the owner does not match, appropriate business errors and
 * audit logs are produced.
 *
 * Integrates with shopping_mall_products for option grouping and with
 * shopping_mall_product_option_values for downstream API navigation. Supports
 * localization and extended attributes for future extensibility.
 *
 * @param props.connection
 * @param props.productId UUID of the product whose options are requested.
 * @param props.body Filter, sort, and pagination criteria for options
 *   retrieval.
 * @path /shoppingMall/seller/products/:productId/options
 * @accessor api.functional.shoppingMall.seller.products.options.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the product whose options are requested. */
    productId: string & tags.Format<"uuid">;

    /** Filter, sort, and pagination criteria for options retrieval. */
    body: IShoppingMallProductOption.IRequest;
  };
  export type Body = IShoppingMallProductOption.IRequest;
  export type Response = IPageIShoppingMallProductOption.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/seller/products/:productId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options`;
  export const random = (): IPageIShoppingMallProductOption.ISummary =>
    typia.random<IPageIShoppingMallProductOption.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the detail for a specific product option
 * (shopping_mall_product_options table).
 *
 * Returns full information for a specific product option belonging to a
 * product, including its name, required status, UI display order, and all
 * business-meta as recorded in shopping_mall_product_options. Foreign key
 * relationships to the target product and associated option values are
 * included.
 *
 * Security measures ensure that only sellers who own the parent product, or
 * admins, can access this detail. Unauthorized access attempts are logged for
 * audit. If the option does not exist or is not attached to the specified
 * product, an appropriate error is returned for business and compliance
 * traceability.
 *
 * This operation is typically used in option editing forms, business logic
 * reviews, and audit UIs. Associated endpoints include option update and value
 * management APIs.
 *
 * @param props.connection
 * @param props.productId UUID identifier of the parent product.
 * @param props.optionId UUID identifier of the product option to retrieve.
 * @path /shoppingMall/seller/products/:productId/options/:optionId
 * @accessor api.functional.shoppingMall.seller.products.options.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID identifier of the parent product. */
    productId: string & tags.Format<"uuid">;

    /** UUID identifier of the product option to retrieve. */
    optionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallProductOption;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/products/:productId/options/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallProductOption =>
    typia.random<IShoppingMallProductOption>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific product option in the shopping_mall_product_options table.
 *
 * This operation updates an option entity associated with a parent product in
 * the product catalog. The update process enforces role-based access
 * controlâ€”only the seller who owns the product or an admin may perform updates.
 * Option fields such as 'name', 'required', and 'position' can be altered.
 * Attempts to rename to a duplicate name within the same product will yield a
 * conflict error.
 *
 * The underlying Prisma schema table, shopping_mall_product_options, manages
 * all options for each product, and changes are immediately reflected in
 * variant generation logic and can impact inventory structure. The system
 * automatically records all updates as historical snapshots in the appropriate
 * audit trail for compliance.
 *
 * If an invalid product or option identifier is specified, a clear HTTP 404
 * error will be returned. Any modification is subject to validation constraints
 * in the schema (e.g., name required, position is integer, required is
 * boolean).
 *
 * @param props.connection
 * @param props.productId Unique identifier for the parent product.
 * @param props.optionId Unique identifier for the option being updated.
 * @param props.body Fields for updating the product option (e.g., name,
 *   required, position).
 * @path /shoppingMall/seller/products/:productId/options/:optionId
 * @accessor api.functional.shoppingMall.seller.products.options.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the parent product. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier for the option being updated. */
    optionId: string & tags.Format<"uuid">;

    /**
     * Fields for updating the product option (e.g., name, required,
     * position).
     */
    body: IShoppingMallProductOption.IUpdate;
  };
  export type Body = IShoppingMallProductOption.IUpdate;
  export type Response = IShoppingMallProductOption;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/options/:optionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallProductOption =>
    typia.random<IShoppingMallProductOption>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an option from a product using the shopping_mall_product_options
 * table.
 *
 * This operation performs a soft deletion of an option from the
 * shopping_mall_product_options table, scoped by product and option
 * identifiers. The system first validates ownership and role permissions. Soft
 * deletion is achieved by updating the 'deleted_at' field, complying with
 * strict audit and evidence requirements.
 *
 * If the option is actively referenced by existing variants, the operation
 * checks business rules and either rejects the deletion or triggers updates for
 * affected variant records. The endpoint provides clear error messaging for
 * constraint violations, not-found errors, or permission denial.
 *
 * Every soft delete operation triggers audit log updates and historical
 * snapshots to permit compliance audit and future restoration if necessary.
 * Only the product owner (seller) or an administrator may invoke this
 * operation.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the parent product.
 * @param props.optionId Unique identifier of the option to be deleted.
 * @path /shoppingMall/seller/products/:productId/options/:optionId
 * @accessor api.functional.shoppingMall.seller.products.options.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the parent product. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the option to be deleted. */
    optionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId/options/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
