import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductSeoMetadata } from "../../../../../structures/IShoppingMallProductSeoMetadata";

/**
 * Retrieve SEO metadata for a given product
 * (shopping_mall_product_seo_metadata).
 *
 * This operation allows sellers and administrators to retrieve the full SEO
 * configuration for a designated product in the catalog. The response contains
 * the meta title, meta description, and meta keywords, all as maintained in the
 * shopping_mall_product_seo_metadata entity. It supports management UIs,
 * product editing screens, SEO auditing, and external service integrations for
 * auto-update of product metadata on partner platforms.
 *
 * Access control is granted to sellers who own the product, as well as to
 * admins with global privilege. The endpoint checks that the specified product
 * exists and that the requester is permitted to view its SEO data. If the
 * product or its SEO metadata record are missing, an appropriate error is
 * returned, and access may be denied for insufficient privileges.
 *
 * The operation does not modify any data. It streams the content of the
 * shopping_mall_product_seo_metadata object for the product, supporting preview
 * interfaces, analytics export, and search engine QA. All accesses are logged
 * for audit and legal compliance.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose SEO metadata to
 *   retrieve.
 * @path /shoppingMall/seller/products/:productId/seo
 * @accessor api.functional.shoppingMall.seller.products.seo.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product whose SEO metadata to retrieve. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallProductSeoMetadata;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/products/:productId/seo",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/seo`;
  export const random = (): IShoppingMallProductSeoMetadata =>
    typia.random<IShoppingMallProductSeoMetadata>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update or create product SEO metadata (shopping_mall_product_seo_metadata).
 *
 * This operation permits an authenticated seller (who owns the product) or
 * admin to upsert SEO metadata for a product. This covers the fields
 * meta_title, meta_description, and meta_keywords according to the business
 * rules defined in the shopping_mall_product_seo_metadata model. The operation
 * validates that the product exists, the requester has permission, and the new
 * metadata is compliant with length, keyword, and formatting requirements.
 *
 * If the product does not yet have SEO metadata, a new record is inserted; if
 * one exists, it is updated with the request body contents. On success, the
 * response is the full resulting SEO metadata object. SEO metadata changes are
 * immediately reflected in product search, display, and external SEO
 * integrations; all updates are snapshotted for audit and rollback support.
 *
 * Relevant errors, such as forbidden fields, permission violations, or
 * non-existent product ID, result in appropriate error responses. The endpoint
 * supports localization, multi-language content as permitted by the catalog
 * configuration, and triggers downstream update notifications for search/SEO
 * services when changes are committed.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose SEO metadata is
 *   to be updated.
 * @param props.body SEO metadata information to be created or updated,
 *   including meta title, description, and keywords.
 * @path /shoppingMall/seller/products/:productId/seo
 * @accessor api.functional.shoppingMall.seller.products.seo.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the product whose SEO metadata is to be updated. */
    productId: string & tags.Format<"uuid">;

    /**
     * SEO metadata information to be created or updated, including meta
     * title, description, and keywords.
     */
    body: IShoppingMallProductSeoMetadata.IUpdate;
  };
  export type Body = IShoppingMallProductSeoMetadata.IUpdate;
  export type Response = IShoppingMallProductSeoMetadata;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/seo",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/seo`;
  export const random = (): IShoppingMallProductSeoMetadata =>
    typia.random<IShoppingMallProductSeoMetadata>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
