import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductBundle } from "../../../../../structures/IShoppingMallProductBundle";
import { IPageIShoppingMallProductBundle } from "../../../../../structures/IPageIShoppingMallProductBundle";

/**
 * Create a new product bundle for a given product
 * (shopping_mall_product_bundles table).
 *
 * This API operation allows authenticated sellers (or admins) to register a new
 * bundle under an existing product. It operates on the
 * shopping_mall_product_bundles table, creating a new record and linking it to
 * the specified product by productId.
 *
 * The request body must supply all mandatory fields such as bundle name, type
 * (fixed/optional), description (optionally), and the initial position/order
 * for display. It also enables definition of constituent bundle items, which
 * are subsequently managed via related endpoints.
 *
 * Role-based permission enforcement ensures only sellers with ownership of the
 * product, or administrators, are authorized to create bundles. Input
 * validation checks for duplicate bundle names for the same product, ensures
 * required fields are present, and that the parent product is in a valid status
 * for editing (e.g., not deleted or discontinued).
 *
 * On successful creation, the response returns the newly created bundle object
 * in full detail, as per the shopping_mall_product_bundles schema. Related
 * operations include updating bundles, removing bundles, and adjusting bundle
 * item composition.
 *
 * @param props.connection
 * @param props.productId ID of the product to which the new bundle will be
 *   attached (UUID, shopping_mall_products.id).
 * @param props.body Bundle creation schema including name, type, description,
 *   position, and initial composition information.
 * @path /shoppingMall/seller/products/:productId/bundles
 * @accessor api.functional.shoppingMall.seller.products.bundles.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * ID of the product to which the new bundle will be attached (UUID,
     * shopping_mall_products.id).
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Bundle creation schema including name, type, description, position,
     * and initial composition information.
     */
    body: IShoppingMallProductBundle.ICreate;
  };
  export type Body = IShoppingMallProductBundle.ICreate;
  export type Response = IShoppingMallProductBundle;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/products/:productId/bundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles`;
  export const random = (): IShoppingMallProductBundle =>
    typia.random<IShoppingMallProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve product bundles for a given product using advanced
 * query/pagination.
 *
 * Lists bundles associated with a single product, using productId as primary
 * filter. Supports filtering on bundle_type, name, status, and allows sorting
 * by display order or other attributes. Pagination options provide efficient
 * navigation of large bundle sets. Useful for both sellers (to manage bundles)
 * and admins (to audit or review product configurations).
 *
 * Only accessible to the owning seller or administrators. The operation
 * enforces permissions and validates that only bundles for the specified
 * product are returned. Errors include unauthorized access, product not found,
 * or invalid query parameters. The response includes only the bundles relevant
 * to the given productId, provided in paginated format for UI efficiency.
 *
 * @param props.connection
 * @param props.productId Parent product identifier to filter bundles for
 * @param props.body Bundle listing/filter/search and pagination options as
 *   IShoppingMallProductBundle.IRequest DTO.
 * @path /shoppingMall/seller/products/:productId/bundles
 * @accessor api.functional.shoppingMall.seller.products.bundles.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Parent product identifier to filter bundles for */
    productId: string & tags.Format<"uuid">;

    /**
     * Bundle listing/filter/search and pagination options as
     * IShoppingMallProductBundle.IRequest DTO.
     */
    body: IShoppingMallProductBundle.IRequest;
  };
  export type Body = IShoppingMallProductBundle.IRequest;
  export type Response = IPageIShoppingMallProductBundle;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/seller/products/:productId/bundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles`;
  export const random = (): IPageIShoppingMallProductBundle =>
    typia.random<IPageIShoppingMallProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details/metadata for a given product's bundle
 * (shopping_mall_product_bundles table).
 *
 * This API operation modifies an existing bundle associated with a product,
 * identified by the productId and bundleId path parameters. It modifies the
 * corresponding row in the shopping_mall_product_bundles table, updating fields
 * like name, type, description, or bundle position as provided in the request
 * body.
 *
 * Only sellers who own the product or platform admins are authorized to update
 * bundles. Edit permissions are restricted based on business logic, such as
 * bundle status, the product's lifecycle state, and uniqueness constraints for
 * the bundle name within the product. If an attempt is made to update a bundle
 * under a discontinued or deleted product, or with conflicting business rules,
 * the update is rejected with a clear error message.
 *
 * On successful update, the full product bundle information is returned in the
 * response, reflecting all changes. The operation works closely with product
 * bundle creation and deletion endpoints for managing the full bundle
 * lifecycle.
 *
 * @param props.connection
 * @param props.productId ID of the product to which the bundle belongs (UUID,
 *   shopping_mall_products.id).
 * @param props.bundleId Unique identifier of the product bundle (UUID,
 *   shopping_mall_product_bundles.id).
 * @param props.body Bundle update schema including updatable fields such as
 *   name, type, description, position, or composition.
 * @path /shoppingMall/seller/products/:productId/bundles/:bundleId
 * @accessor api.functional.shoppingMall.seller.products.bundles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * ID of the product to which the bundle belongs (UUID,
     * shopping_mall_products.id).
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the product bundle (UUID,
     * shopping_mall_product_bundles.id).
     */
    bundleId: string & tags.Format<"uuid">;

    /**
     * Bundle update schema including updatable fields such as name, type,
     * description, position, or composition.
     */
    body: IShoppingMallProductBundle.IUpdate;
  };
  export type Body = IShoppingMallProductBundle.IUpdate;
  export type Response = IShoppingMallProductBundle;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/products/:productId/bundles/:bundleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles/${encodeURIComponent(props.bundleId ?? "null")}`;
  export const random = (): IShoppingMallProductBundle =>
    typia.random<IShoppingMallProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("bundleId")(() => typia.assert(props.bundleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (logically remove) a product bundle under a product
 * (shopping_mall_product_bundles table).
 *
 * This API operation performs a logical deletion (soft delete) of the specified
 * product bundle under a product. Leveraging the deleted_at timestamp on the
 * shopping_mall_product_bundles table, the operation marks the bundle as
 * deleted, maintaining full auditability for compliance and recovery.
 *
 * Only the owning seller or administrative users are authorized to perform this
 * action. Business logic guarantees that a bundle may only be deleted when the
 * parent product is in a permissible state and the user has appropriate
 * permissions. Attempting to delete a bundle under a product not owned by the
 * user, or already marked as deleted/discontinued, results in a business logic
 * error.
 *
 * No response body is returned on success, but audit logs and bundle history
 * support compliance and rollback needs. This operation is closely connected to
 * bundle update and create endpoints, providing full lifecycle control over
 * product bundles.
 *
 * @param props.connection
 * @param props.productId ID of the product to which the bundle belongs (UUID,
 *   shopping_mall_products.id).
 * @param props.bundleId Unique identifier of the product bundle (UUID,
 *   shopping_mall_product_bundles.id).
 * @path /shoppingMall/seller/products/:productId/bundles/:bundleId
 * @accessor api.functional.shoppingMall.seller.products.bundles.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * ID of the product to which the bundle belongs (UUID,
     * shopping_mall_products.id).
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the product bundle (UUID,
     * shopping_mall_product_bundles.id).
     */
    bundleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/products/:productId/bundles/:bundleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles/${encodeURIComponent(props.bundleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("bundleId")(() => typia.assert(props.bundleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
