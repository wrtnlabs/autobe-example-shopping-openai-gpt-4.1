import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAfterSaleService } from "../../../../../structures/IShoppingMallAfterSaleService";

/**
 * Retrieve details for a specific after-sales service case by order and
 * afterSaleServiceId (shopping_mall_after_sale_services).
 *
 * Retrieve comprehensive details about a single after-sales service case for a
 * specific order. The operation fetches all relevant business data fields,
 * including the associated order ID, after-sale service case type (such as
 * return, exchange, or refund), status, user-provided reasons, linked evidence
 * snapshots, and resolution messaging.
 *
 * Authorization and visibility are enforced based on the user's relationship to
 * the order or their platform role: customers can view their own after-sales
 * records, sellers can view only after-sales records linked to their
 * orders/products, and admins can view all.
 *
 * This retrieval operation references the shopping_mall_after_sale_services
 * table and pulls all fields defined therein, aligning with audit and legal
 * evidence needs. Error handling ensures that non-existent or unauthorized
 * queries result in clear, actionable errors.
 *
 * Related operations include list/search for all after-sale cases and update or
 * delete operations for authorized users.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order whose after-sales
 *   service is being queried.
 * @param props.afterSaleServiceId Unique identifier of the target after-sales
 *   service case within the order.
 * @path /shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.seller.orders.afterSaleServices.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the target order whose after-sales service is
     * being queried.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the target after-sales service case within the
     * order.
     */
    afterSaleServiceId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an after-sales service record for a specific order
 * (shopping_mall_after_sale_services).
 *
 * Update the information for a specific after-sales service case within an
 * order. Permitted updates include status transitions (such as processing,
 * approved, or denied), updated resolution messages, and changes to
 * user-submitted reasons or evidence reference fields as permitted by business
 * logic and authorization.
 *
 * The endpoint consumes data per the IShoppingMallAfterSaleService.IUpdate DTO
 * and validates that all updates comply with business rules and eligibility
 * (e.g., certain statuses can only transition in allowed ways; after-sales
 * services may be locked after resolution or escalation). All updates are
 * snapshotted for compliance, and notification flows may be triggered depending
 * on the update.
 *
 * Only authorized actors can perform updates: requesting customers for their
 * own cases (with constraints), sellers for seller-side workflow, and admins
 * for oversight and dispute scenarios. Unauthorized updates yield clear,
 * actionable errors.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to which this after-sales
 *   service belongs.
 * @param props.afterSaleServiceId Unique identifier of the after-sales service
 *   case being updated.
 * @param props.body Fields required to update the after-sales service record,
 *   following business rules and compliance.
 * @path /shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.seller.orders.afterSaleServices.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the order to which this after-sales service
     * belongs.
     */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the after-sales service case being updated. */
    afterSaleServiceId: string & tags.Format<"uuid">;

    /**
     * Fields required to update the after-sales service record, following
     * business rules and compliance.
     */
    body: IShoppingMallAfterSaleService.IUpdate;
  };
  export type Body = IShoppingMallAfterSaleService.IUpdate;
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (logically remove) an after-sales service record for a specific
 * order (shopping_mall_after_sale_services).
 *
 * Logically remove an after-sales service case by marking it as deleted—setting
 * its deleted_at field—rather than removing the record from the database. This
 * implements a soft deletion, retaining the full evidence trail for compliance
 * and dispute requirements.
 *
 * Actors authorized to perform this operation include the requester for their
 * own after-sales cases (within permissions), the responsible seller in
 * specific after-sales flows, and administrators with audit privileges. If
 * attempted on an already resolved, locked, or escalated after-sales case, the
 * operation will block with an error explaining required next steps or stating
 * compliance lock-out.
 *
 * This operation ensures that no actual data is lost (just flagged as deleted),
 * which is critical for audit/legal compliance in regulated e-commerce. All
 * deletions are snapshotted, and audit/deletion event logs are created.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order related to the
 *   after-sales service being deleted.
 * @param props.afterSaleServiceId Unique identifier of the after-sales service
 *   case to be logically deleted.
 * @path /shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.seller.orders.afterSaleServices.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the order related to the after-sales service
     * being deleted.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the after-sales service case to be logically
     * deleted.
     */
    afterSaleServiceId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/seller/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new after-sales service record for a specific order
 * (shopping_mall_after_sale_services).
 *
 * Initiate a new after-sales service process attached to a particular order.
 * This operation enables customers (buyers) to file return/exchange/refund or
 * other after-sales requests against their orders, referencing necessary
 * evidence snapshots and business context. The endpoint accepts comprehensive
 * creation data as mandated by the IShoppingMallAfterSaleService.ICreate DTO,
 * including case type, status, reason, and optional evidence linkages.
 *
 * Business logic enforces eligibility checks: only orders eligible within the
 * after-sales window and matching business rules can trigger a request. If the
 * service is requested by a seller (e.g., for recall), seller audit linkage and
 * escalation apply. The record creation is snapshotted for audit, and
 * notifications are issued to all stakeholders.
 *
 * Responses provide the freshly created after-sale service record. Security and
 * data integrity are enforced according to the roles and the actor's
 * relationship with the order and service.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order for which the after-sales
 *   service is being initiated.
 * @param props.body Fields required to create a new after-sales service record
 *   aligned to the provided order, based on business and compliance rules.
 * @path /shoppingMall/seller/orders/:orderId/afterSaleServices
 * @accessor api.functional.shoppingMall.seller.orders.afterSaleServices.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the order for which the after-sales service is
     * being initiated.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Fields required to create a new after-sales service record aligned to
     * the provided order, based on business and compliance rules.
     */
    body: IShoppingMallAfterSaleService.ICreate;
  };
  export type Body = IShoppingMallAfterSaleService.ICreate;
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/seller/orders/:orderId/afterSaleServices",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/seller/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
