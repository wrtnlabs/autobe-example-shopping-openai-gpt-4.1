import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallFavoriteProduct } from "../../../../structures/IShoppingMallFavoriteProduct";
import { IPageIShoppingMallFavoriteProduct } from "../../../../structures/IPageIShoppingMallFavoriteProduct";

/**
 * Create a new favorite product entry for the authenticated customer
 * (shopping_mall_favorite_products).
 *
 * Customers use this endpoint to mark a product as a favorite. Favoriting a
 * product not only records the customer-product association but also snaps a
 * historical record of the product's business state at the time of favoriting,
 * supporting downstream AI-driven personalization and audit requirements.
 *
 * Permission checks ensure only authenticated customers can perform this action
 * on their own behalf. Attempting to favorite a product that is already
 * favorited returns a constrained error; attempts to favorite non-existent or
 * deleted products also fail with explicit validation errors. The business
 * logic validates the presence of the product and available snapshot. Creation
 * triggers personalized notification enablers if requested by the user. All
 * records preserve compliance with evidence retention rules and are never
 * physically deleted.
 *
 * Any operation error (constraint violations, missing fields, unauthorized)
 * returns well-formed error codes and reason messages in the response.
 *
 * This API is tightly linked to shopping_mall_favorite_products (the main
 * favorite record), shopping_mall_products (target entity), and
 * shopping_mall_customers (acting user identity) in the schema. The request and
 * response DTOs are versioned with the service prefix for future
 * extensibility.
 *
 * @param props.connection
 * @param props.body Details for the favorite product, including product and
 *   snapshot identifiers, notification preference, and batch organization
 *   label.
 * @path /shoppingMall/customer/favoriteProducts
 * @accessor api.functional.shoppingMall.customer.favoriteProducts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Details for the favorite product, including product and snapshot
     * identifiers, notification preference, and batch organization label.
     */
    body: IShoppingMallFavoriteProduct.ICreate;
  };
  export type Body = IShoppingMallFavoriteProduct.ICreate;
  export type Response = IShoppingMallFavoriteProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/favoriteProducts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/favoriteProducts";
  export const random = (): IShoppingMallFavoriteProduct =>
    typia.random<IShoppingMallFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate a customer's favorited products
 * (shopping_mall_favorite_products table).
 *
 * This endpoint enables an authenticated customer to retrieve a paginated,
 * searchable, and sortable list of all products they have favorited. Results
 * may be filtered by organizational batch_label, notification_enabled status,
 * or creation/update timestamps. Each record includes the linked product entity
 * and the snapshot preserved at the moment of favoriting for audit and
 * evidence. This supports personalized list management, notification setting
 * review, and batch organizing actions.
 *
 * Security requires customer authentication; only the requesting user's
 * favorites are accessible unless an admin queries for support/audit purposes.
 * The endpoint supports pagination controls (page, limit), sorting (by created
 * date, name, favorite status), and advanced search for favorites featuring
 * localized or full product text. Error handling includes permission denials
 * for non-authenticated access and validation for out-of-range pagination. This
 * operation is fully auditable, supporting rollback and compliance requests,
 * and integrates with notification preferences for downstream alerting.
 *
 * Paired operations include creating and deleting a favorite (POST/DELETE
 * /favoriteProducts/{favoriteProductId}), batch updates, and exporting
 * favorites for personalization or evidence export.
 *
 * @param props.connection
 * @param props.body Search and pagination filters for favorite products batch
 *   operations and organization.
 * @path /shoppingMall/customer/favoriteProducts
 * @accessor api.functional.shoppingMall.customer.favoriteProducts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination filters for favorite products batch operations
     * and organization.
     */
    body: IShoppingMallFavoriteProduct.IRequest;
  };
  export type Body = IShoppingMallFavoriteProduct.IRequest;
  export type Response = IPageIShoppingMallFavoriteProduct;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/favoriteProducts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/favoriteProducts";
  export const random = (): IPageIShoppingMallFavoriteProduct =>
    typia.random<IPageIShoppingMallFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a detailed favorited product by ID (shopping_mall_favorite_products
 * table).
 *
 * This endpoint retrieves detailed information about a single product favorited
 * by a user, identified by favoriteProductId. The result includes the full
 * favorite record, all meta fields (such as notification_enabled and
 * batch_label), links to the preserved product snapshot, and the original
 * product entity, if present. Security is enforced so that only the favoriting
 * user may access their own favorite records; admin access is granted for
 * support or compliance audit. The result supports review for personalization,
 * notification settings, batch labels, and export or evidence operations.
 *
 * Attempts to retrieve a favorite that does not exist, is deleted, or is not
 * owned by the user will return an error according to platform business rules.
 * The operation also integrates with downstream personalization, notification,
 * and snapshot export logic, and is part of the broader user-facing favorites
 * management suite.
 *
 * @param props.connection
 * @param props.favoriteProductId Unique identifier of the favorited product
 *   entry to retrieve
 * @path /shoppingMall/customer/favoriteProducts/:favoriteProductId
 * @accessor api.functional.shoppingMall.customer.favoriteProducts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the favorited product entry to retrieve */
    favoriteProductId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallFavoriteProduct;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/favoriteProducts/:favoriteProductId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/favoriteProducts/${encodeURIComponent(props.favoriteProductId ?? "null")}`;
  export const random = (): IShoppingMallFavoriteProduct =>
    typia.random<IShoppingMallFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update properties (such as notification preference or label) of a favorite
 * product for the current customer (shopping_mall_favorite_products).
 *
 * Authenticated customers may use this endpoint to update details of an
 * existing favorite product instance, such as enabling/disabling notifications
 * or adjusting the batch/organizational label assigned to the favorite. The
 * operation enforces ownership verification—the specified favorite must exist
 * and belong to the requesting user.
 *
 * Updates are limited to mutable fields like label/tags or notification
 * triggers; the association between the user and the product remains fixed. All
 * successful updates are timestamped for audit, with changes reflected in
 * future personalization and notification workflows. Attempting to update a
 * favorite not owned by the user, or one that does not exist or has been
 * deleted, leads to error responses with explicit reason codes.
 *
 * Linked schema entities for this operation are
 * shopping_mall_favorite_products, shopping_mall_customers, and
 * shopping_mall_products (via snapshot/favorite association). Security and
 * compliance constraints are strictly enforced.
 *
 * @param props.connection
 * @param props.favoriteProductId Unique identifier of the favorite product
 *   record to update.
 * @param props.body Fields to update in the favorite product, such as
 *   notification status or batch label.
 * @path /shoppingMall/customer/favoriteProducts/:favoriteProductId
 * @accessor api.functional.shoppingMall.customer.favoriteProducts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the favorite product record to update. */
    favoriteProductId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the favorite product, such as notification status
     * or batch label.
     */
    body: IShoppingMallFavoriteProduct.IUpdate;
  };
  export type Body = IShoppingMallFavoriteProduct.IUpdate;
  export type Response = IShoppingMallFavoriteProduct;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/favoriteProducts/:favoriteProductId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/favoriteProducts/${encodeURIComponent(props.favoriteProductId ?? "null")}`;
  export const random = (): IShoppingMallFavoriteProduct =>
    typia.random<IShoppingMallFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (mark as removed) a favorite product belonging to the current
 * customer (shopping_mall_favorite_products).
 *
 * Customers may use this endpoint to remove a product from their favorites. The
 * API enforces that customers can only delete their own favorite records, not
 * those of others. The deletion is soft—setting a deleted_at timestamp and
 * preserving the record for evidence retention, personalization audit, and
 * possible future recovery scenarios.
 *
 * Attempts to remove a favorite that does not exist, is already deleted, or
 * does not belong to the authenticated user will result in validation or
 * permission errors with explicit reason codes. All operations generate audit
 * records, ensuring compliance with legal and business requirements. There is
 * no response body; success is confirmed by standard HTTP status codes.
 *
 * Linked schema entities include shopping_mall_favorite_products (main favorite
 * record), shopping_mall_customers (user context), and audit/snapshot tables
 * for evidence chain.
 *
 * @param props.connection
 * @param props.favoriteProductId Unique identifier of the favorite product
 *   record to delete.
 * @path /shoppingMall/customer/favoriteProducts/:favoriteProductId
 * @accessor api.functional.shoppingMall.customer.favoriteProducts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the favorite product record to delete. */
    favoriteProductId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/favoriteProducts/:favoriteProductId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/favoriteProducts/${encodeURIComponent(props.favoriteProductId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteProductId")(() =>
        typia.assert(props.favoriteProductId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
