import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallExternalAccount } from "../../../../../structures/IShoppingMallExternalAccount";
import { IPageIShoppingMallExternalAccount } from "../../../../../structures/IPageIShoppingMallExternalAccount";

/**
 * Search and retrieve all external accounts linked to a specific customer
 * (shopping_mall_external_accounts).
 *
 * This endpoint allows retrieval of all external OAuth/social accounts
 * associated with a single customer, referenced by {customerId}. It enables
 * customers to audit and manage their linked OAuth accounts (Google, Apple,
 * Kakao, Naver, etc), supporting re-linking, disconnection, or
 * troubleshooting.
 *
 * Customer authentication is required, and the system verifies that the
 * customer is querying only their own external accounts. Administrators may use
 * this operation for customer support/audit cases, subject to access policy.
 * Returned data includes provider name, linked status, timestamps, and unique
 * external account identifiers.
 *
 * Filtering options allow queries by provider, status (active, revoked,
 * pending), linkage date, or external account ID. Pagination and sorting are
 * supported for accounts with many links over time. Error handling includes
 * permission checks, invalid ID handling, and rate limiting for repeated
 * queries.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer whose
 *   external accounts are being queried.
 * @param props.body Criteria for filtering, searching, and paginating the
 *   customer's linked external accounts.
 * @path /shoppingMall/customer/customers/:customerId/externalAccounts
 * @accessor api.functional.shoppingMall.customer.customers.externalAccounts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the target customer whose external accounts are
     * being queried.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Criteria for filtering, searching, and paginating the customer's
     * linked external accounts.
     */
    body: IShoppingMallExternalAccount.IRequest;
  };
  export type Body = IShoppingMallExternalAccount.IRequest;
  export type Response = IPageIShoppingMallExternalAccount.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/customers/:customerId/externalAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts`;
  export const random = (): IPageIShoppingMallExternalAccount.ISummary =>
    typia.random<IPageIShoppingMallExternalAccount.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve metadata for a single external account linked to a customer
 * (shopping_mall_external_accounts).
 *
 * This endpoint fetches detailed information about a specific external
 * OAuth/social account connected to a customer, identified by both {customerId}
 * and {externalAccountId}. Customers can use this to verify the status or
 * metadata of a particular external login.
 *
 * Only the owning customer (or an admin, under compliance) can access this
 * resource; role-based access control is enforced. Returned data includes
 * provider name, linked user ID, linkage date, and status.
 *
 * This operation provides transparency for multi-auth scenarios, helps users
 * troubleshoot login issues, and surfaces provider-specific metadata. Security
 * measures include strict path parameter validation and access checks to
 * prevent unauthorized access to another user's accounts. Errors are returned
 * for invalid IDs or insufficient permissions.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer who owns this
 *   external account association.
 * @param props.externalAccountId Unique identifier of the target external
 *   account entry to be retrieved.
 * @path /shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId
 * @accessor api.functional.shoppingMall.customer.customers.externalAccounts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the customer who owns this external account
     * association.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the target external account entry to be
     * retrieved.
     */
    externalAccountId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallExternalAccount;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): IShoppingMallExternalAccount =>
    typia.random<IShoppingMallExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing external account linked to a customer
 * (shopping_mall_external_accounts).
 *
 * This endpoint allows the authenticated customer (or admin under compliance)
 * to update editable metadata on a specific external account association.
 * Supported updates include status (e.g., manual revocation, relinking),
 * annotation of provider-specific metadata, or customer preferences for
 * authentication notifications.
 *
 * Security measures ensure customers can only modify their account and not
 * others. Only fields allowed by business rules, compliance, and OAuth provider
 * policy may be updated. The request is rejected if attempted on system-managed
 * or immutable fields (e.g., provider, external_user_id). Full auditing is
 * enforced.
 *
 * This operation is used for user-initiated disconnect/revoke flows, recovery
 * from login issues, or syncing status with third-party OAuth identities.
 * Validation errors and forbidden field updates are properly surfaced. All
 * changes are logged for audit and compliance.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer who owns the
 *   external account to update.
 * @param props.externalAccountId Unique identifier of the external account
 *   record to be modified.
 * @param props.body Editable metadata for the external account such as status
 *   changes or customer-specific preferences or annotations.
 * @path /shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId
 * @accessor api.functional.shoppingMall.customer.customers.externalAccounts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the customer who owns the external account to
     * update.
     */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the external account record to be modified. */
    externalAccountId: string & tags.Format<"uuid">;

    /**
     * Editable metadata for the external account such as status changes or
     * customer-specific preferences or annotations.
     */
    body: IShoppingMallExternalAccount.IUpdate;
  };
  export type Body = IShoppingMallExternalAccount.IUpdate;
  export type Response = IShoppingMallExternalAccount;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): IShoppingMallExternalAccount =>
    typia.random<IShoppingMallExternalAccount>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove or logically delete a linked external account from the customer
 * profile (shopping_mall_external_accounts).
 *
 * This endpoint allows a customer (or authorized admin) to remove the
 * association of an external OAuth/social account from their account/profile.
 * Only the owner can unlink external accounts unless a compliant admin performs
 * the action for risk or fraud reasons. The operation performs a logical
 * deletion by marking the deleted_at timestamp, preserving auditability and
 * GDPR/CCPA compliance.
 *
 * This operation is used for customer-driven unlink/revoke workflows (e.g.,
 * unlinking Google/Kakao), loss/theft scenarios, or access recovery. It checks
 * for active links before unlinking and prevents deletion of required or
 * system-managed associations. After successful operation, the account remains
 * in the audit history and is excluded from active linkage lists. Forbidden or
 * illegal requests prompt error logging and user-facing feedback.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer requesting to
 *   remove an external association.
 * @param props.externalAccountId Unique identifier of the external account
 *   association to be removed.
 * @path /shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId
 * @accessor api.functional.shoppingMall.customer.customers.externalAccounts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the customer requesting to remove an external
     * association.
     */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the external account association to be removed. */
    externalAccountId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/customers/:customerId/externalAccounts/:externalAccountId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/externalAccounts/${encodeURIComponent(props.externalAccountId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("externalAccountId")(() =>
        typia.assert(props.externalAccountId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
