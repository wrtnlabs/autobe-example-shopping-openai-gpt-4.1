import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallFavoriteAddress } from "../../../../structures/IShoppingMallFavoriteAddress";
import { IPageIShoppingMallFavoriteAddress } from "../../../../structures/IPageIShoppingMallFavoriteAddress";

/**
 * Create a new favorited address for the authenticated customer
 * (shopping_mall_favorite_addresses).
 *
 * This operation allows an authenticated customer to mark one of their
 * addresses as a favorite, creating a record in
 * shopping_mall_favorite_addresses. The request requires the address ID (UUID),
 * optional organization/batch label, and notification preference. Upon
 * creation, a snapshot of the favorited address entity is captured and
 * referenced, ensuring complete evidence for audit, personalization, and
 * notification workflows.
 *
 * Business logic enforces customer authentication, ownership validation (only
 * the customer's own addresses are eligible), and checks for
 * duplicates—rejecting attempts to favorite the same address more than once. If
 * the address is not found or permission is violated, an appropriate error code
 * is returned. All operation steps are logged for compliance. Success returns
 * the created favorite address including metadata and the attached snapshot
 * reference.
 *
 * @param props.connection
 * @param props.body Data to create a new favorite address: address UUID,
 *   organization label (optional), and notification preference.
 * @path /shoppingMall/customer/favoriteAddresses
 * @accessor api.functional.shoppingMall.customer.favoriteAddresses.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data to create a new favorite address: address UUID, organization
     * label (optional), and notification preference.
     */
    body: IShoppingMallFavoriteAddress.ICreate;
  };
  export type Body = IShoppingMallFavoriteAddress.ICreate;
  export type Response = IShoppingMallFavoriteAddress;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/favoriteAddresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/favoriteAddresses";
  export const random = (): IShoppingMallFavoriteAddress =>
    typia.random<IShoppingMallFavoriteAddress>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered and paginated list of favorite addresses for the current
 * customer (shopping_mall_favorite_addresses).
 *
 * Authenticated users may query their favorited addresses using this endpoint,
 * supporting advanced filtering (such as by label/tag/notification state),
 * pagination, and batch-friendly operations for organizing large favorite
 * lists. Each address record is linked to its evidence snapshot at the time of
 * favoriting, fulfilling both personalization input and audit/evidence
 * requirements.
 *
 * The underlying query only returns addresses owned by the authenticated
 * customer; attempting to query the favorites of others is strictly prohibited
 * by permission checks. Full pagination is implemented with configurable page
 * size and sort order. Errors are returned for invalid search parameters or
 * when the user is not authenticated.
 *
 * This operation is based on shopping_mall_favorite_addresses (lookup by
 * customer), and joins with shopping_mall_favorite_snapshots for historical
 * business data. All responses support localization and audit policies, and
 * returned records reflect exact field definitions in the DB schema.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination criteria for retrieving
 *   favorite addresses.
 * @path /shoppingMall/customer/favoriteAddresses
 * @accessor api.functional.shoppingMall.customer.favoriteAddresses.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filtering, and pagination criteria for retrieving favorite
     * addresses.
     */
    body: IShoppingMallFavoriteAddress.IRequest;
  };
  export type Body = IShoppingMallFavoriteAddress.IRequest;
  export type Response = IPageIShoppingMallFavoriteAddress;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/favoriteAddresses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/favoriteAddresses";
  export const random = (): IPageIShoppingMallFavoriteAddress =>
    typia.random<IPageIShoppingMallFavoriteAddress>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific favorited address for the authenticated user, including
 * resolved address snapshot and notification metadata
 * (shopping_mall_favorite_addresses).
 *
 * This operation fetches all available detail about a single entry from the
 * shopping_mall_favorite_addresses table, matching the provided
 * favoriteAddressId. The client must be authenticated as a customer and may
 * only access their own favorited entries (permissions enforced). All address
 * favorite fields—including batch_label, notification_enabled, and links to the
 * immutable snapshot (at time of favorite creation)—are included in the
 * response. The snapshot entity preserves a historical record allowing audit,
 * rollback, or dispute evidence.
 *
 * Security checks ensure only the owning customer can retrieve the favorited
 * address, rejecting attempts to access non-owned or deleted entries. If the
 * favorite is logically deleted (deleted_at not null), the operation returns a
 * not-found error. If permission violation is detected, a 403 Forbidden
 * response is returned.
 *
 * Error handling covers invalid/missing UUID, non-existent resources, or
 * permission failures, returning standardized error codes and clarifying
 * context for the user. Related operations include the ability to list all
 * favorites, create new favorites, update labels/notification, or logically
 * remove favorite addresses; all actions are tracked for compliance and
 * personalization workflows.
 *
 * @param props.connection
 * @param props.favoriteAddressId Unique identifier for the favorite address to
 *   retrieve (UUID from shopping_mall_favorite_addresses.id)
 * @path /shoppingMall/customer/favoriteAddresses/:favoriteAddressId
 * @accessor api.functional.shoppingMall.customer.favoriteAddresses.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the favorite address to retrieve (UUID from
     * shopping_mall_favorite_addresses.id)
     */
    favoriteAddressId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallFavoriteAddress;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/favoriteAddresses/:favoriteAddressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/favoriteAddresses/${encodeURIComponent(props.favoriteAddressId ?? "null")}`;
  export const random = (): IShoppingMallFavoriteAddress =>
    typia.random<IShoppingMallFavoriteAddress>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteAddressId")(() =>
        typia.assert(props.favoriteAddressId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update notification or batch metadata for a specific favorited address
 * (shopping_mall_favorite_addresses).
 *
 * This operation allows an authenticated customer to modify details of their
 * favorited address entry. Supported updates include toggling
 * notification_enabled (for entity change alerts) and editing batch_label (for
 * organizational purposes). The core favorite reference and snapshot state are
 * immutable, preserving audit integrity. Only the user who created the favorite
 * can perform this update; attempts to modify another user's favorite address
 * are denied with a 403 error.
 *
 * Validation enforces that the favoriteAddressId belongs to the authenticated
 * user and is not logically deleted. Changes are persisted, and the response
 * includes the full, now-updated favorite address entity (including snapshot
 * reference). Audit logs are created for evidence traceability, with all
 * modification attempts captured (successful or denied).
 *
 * @param props.connection
 * @param props.favoriteAddressId Unique identifier of the favorited address to
 *   update (UUID from shopping_mall_favorite_addresses.id)
 * @param props.body Payload including updatable fields for a favorited address:
 *   notification_enabled and batch_label.
 * @path /shoppingMall/customer/favoriteAddresses/:favoriteAddressId
 * @accessor api.functional.shoppingMall.customer.favoriteAddresses.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the favorited address to update (UUID from
     * shopping_mall_favorite_addresses.id)
     */
    favoriteAddressId: string & tags.Format<"uuid">;

    /**
     * Payload including updatable fields for a favorited address:
     * notification_enabled and batch_label.
     */
    body: IShoppingMallFavoriteAddress.IUpdate;
  };
  export type Body = IShoppingMallFavoriteAddress.IUpdate;
  export type Response = IShoppingMallFavoriteAddress;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/favoriteAddresses/:favoriteAddressId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/favoriteAddresses/${encodeURIComponent(props.favoriteAddressId ?? "null")}`;
  export const random = (): IShoppingMallFavoriteAddress =>
    typia.random<IShoppingMallFavoriteAddress>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteAddressId")(() =>
        typia.assert(props.favoriteAddressId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) a favorited address for the authenticated customer
 * (shopping_mall_favorite_addresses).
 *
 * This operation marks a favorited address for the currently authenticated
 * customer as deleted, performing a soft delete by setting the deleted_at field
 * in shopping_mall_favorite_addresses. After this operation, the favorite is no
 * longer shown in get/list operations or included in notifications, but the
 * full audit/snapshot history is preserved for compliance, export, and dispute
 * resolution. Attempts to remove a favorite belonging to another user or an
 * already-removed entry result in an error.
 *
 * Security controls strictly enforce ownership; unauthorized delete requests
 * receive a 403 Forbidden response. Deleted favorites remain present for legal
 * retention but are hidden from user-facing APIs. All soft-delete actions are
 * tracked in the audit log. This endpoint supports user-driven address list
 * organization and privacy management in compliance with regulations.
 *
 * @param props.connection
 * @param props.favoriteAddressId Unique identifier of the favorite address to
 *   remove (UUID from shopping_mall_favorite_addresses.id)
 * @path /shoppingMall/customer/favoriteAddresses/:favoriteAddressId
 * @accessor api.functional.shoppingMall.customer.favoriteAddresses.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the favorite address to remove (UUID from
     * shopping_mall_favorite_addresses.id)
     */
    favoriteAddressId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/favoriteAddresses/:favoriteAddressId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/favoriteAddresses/${encodeURIComponent(props.favoriteAddressId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteAddressId")(() =>
        typia.assert(props.favoriteAddressId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
