import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallDonation } from "../../../../structures/IShoppingMallDonation";
import { IPageIShoppingMallDonation } from "../../../../structures/IPageIShoppingMallDonation";

/**
 * Create a new donation (deposit or mileage) to a specified campaign, enforcing
 * validation and audit trail.
 *
 * This operation enables a customer to initiate a new donation using either
 * their deposit balance or mileage points towards a specified campaign. Upon
 * receiving a valid request, the system will validate the donor’s current
 * balance, ensure donation limits or campaign constraints are respected, and
 * record all relevant metadata in the shopping_mall_donations table. Donation
 * creation includes specifying the donation source (deposit or mileage), source
 * account, donation target campaign code, and the intended donation amount.
 *
 * Security and compliance checks are enforced. Only authenticated customers may
 * use this endpoint, and they may only donate from balances belonging to their
 * own account. Business logic validates availability of funds, campaign
 * eligibility, anti-fraud, and that the target campaign code is active if
 * business policies require. On success, the donation is recorded and can be
 * traced for dashboard, historical, or investigative purposes. Errors include
 * insufficient balance, invalid campaign, or fraud detection triggers.
 * Administrative operations for reviewing or analyzing donations are provided
 * separately.
 *
 * @param props.connection
 * @param props.body Donation details: source (deposit or mileage), source
 *   account, target campaign, and amount.
 * @path /shoppingMall/customer/donations
 * @accessor api.functional.shoppingMall.customer.donations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Donation details: source (deposit or mileage), source account, target
     * campaign, and amount.
     */
    body: IShoppingMallDonation.ICreate;
  };
  export type Body = IShoppingMallDonation.ICreate;
  export type Response = IShoppingMallDonation;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/donations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/donations";
  export const random = (): IShoppingMallDonation =>
    typia.random<IShoppingMallDonation>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filtered list of donation records.
 *
 * Retrieve a filtered, paginated list of donation records from the
 * shopping_mall_donations table. This operation allows both users and
 * administrators to view donation transactions based on various criteria,
 * including customer identity, donation source type (deposit or mileage),
 * campaign code, and status. Pagination parameters ensure efficient navigation
 * through potentially large result sets. Administrators can view system-wide or
 * filtered analytics; customers can view their personal donation history.
 * Search parameters may include time range, amount range, campaign, and
 * transaction status. The operation ensures sensitive information is properly
 * masked for non-admin users, and permission checks prevent cross-user data
 * access. The response contains a paginated summary of donation transactions
 * and relevant statistics.
 *
 * @param props.connection
 * @param props.body Search and pagination parameters for donation filtering,
 *   defined by IShoppingMallDonation.IRequest. Supports filtering by customer,
 *   campaign code, amount, date range, and status.
 * @path /shoppingMall/customer/donations
 * @accessor api.functional.shoppingMall.customer.donations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination parameters for donation filtering, defined by
     * IShoppingMallDonation.IRequest. Supports filtering by customer,
     * campaign code, amount, date range, and status.
     */
    body: IShoppingMallDonation.IRequest;
  };
  export type Body = IShoppingMallDonation.IRequest;
  export type Response = IPageIShoppingMallDonation.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/donations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/customer/donations";
  export const random = (): IPageIShoppingMallDonation.ISummary =>
    typia.random<IPageIShoppingMallDonation.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific donation by its UUID from the
 * shopping_mall_donations table.
 *
 * This operation retrieves a detailed donation record for a given donation
 * identified by its unique UUID in the shopping_mall_donations table. The
 * donation record includes the donating customer, source type (deposit or
 * mileage), related campaign/event code, transferred amount, donation status
 * (pending, confirmed, failed, refunded, etc.), and full timestamp/audit
 * metadata.
 *
 * The endpoint is designed for auditability—enabling compliant review of
 * donation evidence, transparency for analytics, and support for legal
 * inquiries. Only authorized users may access donation records. Customers may
 * request their own information; administrators can access records for
 * compliance, fraud tracking, or dispute resolution.
 *
 * Validation enforces that donationId matches an extant record and that access
 * controls are respected. Errors may occur if the donation is missing, deleted,
 * or if the caller lacks permission. Related endpoints include donation
 * creation, update, and logical deletion.
 *
 * @param props.connection
 * @param props.donationId The unique identifier (UUID) of the donation to
 *   retrieve.
 * @path /shoppingMall/customer/donations/:donationId
 * @accessor api.functional.shoppingMall.customer.donations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier (UUID) of the donation to retrieve. */
    donationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallDonation;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/donations/:donationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/donations/${encodeURIComponent(props.donationId ?? "null")}`;
  export const random = (): IShoppingMallDonation =>
    typia.random<IShoppingMallDonation>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("donationId")(() => typia.assert(props.donationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (soft remove) a donation by its UUID, retaining data for
 * evidence and compliance.
 *
 * This operation performs logical deletion (soft delete) of the specified
 * donation, referenced by donationId. Rather than removing the record from the
 * database, it sets the deleted_at timestamp to guarantee regulatory evidence
 * retention, auditability, and rollback capabilities. The deletion is only
 * permitted if the donation is not in a finalized or protected state (e.g.,
 * after refund/settlement for certain jurisdictions per business logic), and
 * enforces authorization so only the owner or an admin may remove the record.
 *
 * This operation complies with data governance requirements, snapshot/evidence
 * retention policies, and ensures consistency with the system’s commitment to
 * non-destructive removal. Attempting to delete a protected, non-existent, or
 * unauthorized donation results in a clear error, with all actions logged for
 * compliance. Use corresponding endpoints for read/recovery as needed.
 *
 * @param props.connection
 * @param props.donationId The UUID of the donation to logically delete (soft
 *   remove).
 * @path /shoppingMall/customer/donations/:donationId
 * @accessor api.functional.shoppingMall.customer.donations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the donation to logically delete (soft remove). */
    donationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/donations/:donationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/donations/${encodeURIComponent(props.donationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("donationId")(() => typia.assert(props.donationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
