import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAfterSaleService } from "../../../../../structures/IShoppingMallAfterSaleService";
import { IPageIShoppingMallAfterSaleService } from "../../../../../structures/IPageIShoppingMallAfterSaleService";

/**
 * Create a new after-sales service record for a specific order
 * (shopping_mall_after_sale_services).
 *
 * Initiate a new after-sales service process attached to a particular order.
 * This operation enables customers (buyers) to file return/exchange/refund or
 * other after-sales requests against their orders, referencing necessary
 * evidence snapshots and business context. The endpoint accepts comprehensive
 * creation data as mandated by the IShoppingMallAfterSaleService.ICreate DTO,
 * including case type, status, reason, and optional evidence linkages.
 *
 * Business logic enforces eligibility checks: only orders eligible within the
 * after-sales window and matching business rules can trigger a request. If the
 * service is requested by a seller (e.g., for recall), seller audit linkage and
 * escalation apply. The record creation is snapshotted for audit, and
 * notifications are issued to all stakeholders.
 *
 * Responses provide the freshly created after-sale service record. Security and
 * data integrity are enforced according to the roles and the actor's
 * relationship with the order and service.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order for which the after-sales
 *   service is being initiated.
 * @param props.body Fields required to create a new after-sales service record
 *   aligned to the provided order, based on business and compliance rules.
 * @path /shoppingMall/customer/orders/:orderId/afterSaleServices
 * @accessor api.functional.shoppingMall.customer.orders.afterSaleServices.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the order for which the after-sales service is
     * being initiated.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Fields required to create a new after-sales service record aligned to
     * the provided order, based on business and compliance rules.
     */
    body: IShoppingMallAfterSaleService.ICreate;
  };
  export type Body = IShoppingMallAfterSaleService.ICreate;
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/customer/orders/:orderId/afterSaleServices",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search after-sales service records for a specific order
 * (ShoppingMallAfterSaleServices table).
 *
 * Query and retrieve a paginated, filtered list of after-sales service cases
 * (returns, exchanges, refunds, etc.) linked to a specific order. The operation
 * supports complex filtering (by case type, status, created date, etc.),
 * sorting, and pagination parameters, making it practical for UI listings and
 * detailed business analytics.
 *
 * Security and business logic enforce that only customers who placed the order,
 * authorized staff, or administrators can query after-sale cases. System checks
 * ensure that the referenced order exists and that the requesting user has
 * legitimate access rights before results are returned.
 *
 * This endpoint supports audit evidence requirements by including meta on each
 * after-sales request, and may be chained with detail view or create operations
 * on after-sale records. Error scenarios handle invalid order references,
 * unauthorized access, and malformed query parameters.
 *
 * @param props.connection
 * @param props.orderId Target order's ID for which after-sales cases are being
 *   searched.
 * @param props.body After-sales case search/filter parameters (caseType,
 *   status, date range, etc.)
 * @path /shoppingMall/customer/orders/:orderId/afterSaleServices
 * @accessor api.functional.shoppingMall.customer.orders.afterSaleServices.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target order's ID for which after-sales cases are being searched. */
    orderId: string & tags.Format<"uuid">;

    /**
     * After-sales case search/filter parameters (caseType, status, date
     * range, etc.)
     */
    body: IShoppingMallAfterSaleService.IRequest;
  };
  export type Body = IShoppingMallAfterSaleService.IRequest;
  export type Response = IPageIShoppingMallAfterSaleService.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/customer/orders/:orderId/afterSaleServices",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices`;
  export const random = (): IPageIShoppingMallAfterSaleService.ISummary =>
    typia.random<IPageIShoppingMallAfterSaleService.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details for a specific after-sales service case by order and
 * afterSaleServiceId (shopping_mall_after_sale_services).
 *
 * Retrieve comprehensive details about a single after-sales service case for a
 * specific order. The operation fetches all relevant business data fields,
 * including the associated order ID, after-sale service case type (such as
 * return, exchange, or refund), status, user-provided reasons, linked evidence
 * snapshots, and resolution messaging.
 *
 * Authorization and visibility are enforced based on the user's relationship to
 * the order or their platform role: customers can view their own after-sales
 * records, sellers can view only after-sales records linked to their
 * orders/products, and admins can view all.
 *
 * This retrieval operation references the shopping_mall_after_sale_services
 * table and pulls all fields defined therein, aligning with audit and legal
 * evidence needs. Error handling ensures that non-existent or unauthorized
 * queries result in clear, actionable errors.
 *
 * Related operations include list/search for all after-sale cases and update or
 * delete operations for authorized users.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order whose after-sales
 *   service is being queried.
 * @param props.afterSaleServiceId Unique identifier of the target after-sales
 *   service case within the order.
 * @path /shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.customer.orders.afterSaleServices.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the target order whose after-sales service is
     * being queried.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the target after-sales service case within the
     * order.
     */
    afterSaleServiceId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an after-sales service record for a specific order
 * (shopping_mall_after_sale_services).
 *
 * Update the information for a specific after-sales service case within an
 * order. Permitted updates include status transitions (such as processing,
 * approved, or denied), updated resolution messages, and changes to
 * user-submitted reasons or evidence reference fields as permitted by business
 * logic and authorization.
 *
 * The endpoint consumes data per the IShoppingMallAfterSaleService.IUpdate DTO
 * and validates that all updates comply with business rules and eligibility
 * (e.g., certain statuses can only transition in allowed ways; after-sales
 * services may be locked after resolution or escalation). All updates are
 * snapshotted for compliance, and notification flows may be triggered depending
 * on the update.
 *
 * Only authorized actors can perform updates: requesting customers for their
 * own cases (with constraints), sellers for seller-side workflow, and admins
 * for oversight and dispute scenarios. Unauthorized updates yield clear,
 * actionable errors.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to which this after-sales
 *   service belongs.
 * @param props.afterSaleServiceId Unique identifier of the after-sales service
 *   case being updated.
 * @param props.body Fields required to update the after-sales service record,
 *   following business rules and compliance.
 * @path /shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.customer.orders.afterSaleServices.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the order to which this after-sales service
     * belongs.
     */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the after-sales service case being updated. */
    afterSaleServiceId: string & tags.Format<"uuid">;

    /**
     * Fields required to update the after-sales service record, following
     * business rules and compliance.
     */
    body: IShoppingMallAfterSaleService.IUpdate;
  };
  export type Body = IShoppingMallAfterSaleService.IUpdate;
  export type Response = IShoppingMallAfterSaleService;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): IShoppingMallAfterSaleService =>
    typia.random<IShoppingMallAfterSaleService>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (logically remove) an after-sales service record for a specific
 * order (shopping_mall_after_sale_services).
 *
 * Logically remove an after-sales service case by marking it as deleted—setting
 * its deleted_at field—rather than removing the record from the database. This
 * implements a soft deletion, retaining the full evidence trail for compliance
 * and dispute requirements.
 *
 * Actors authorized to perform this operation include the requester for their
 * own after-sales cases (within permissions), the responsible seller in
 * specific after-sales flows, and administrators with audit privileges. If
 * attempted on an already resolved, locked, or escalated after-sales case, the
 * operation will block with an error explaining required next steps or stating
 * compliance lock-out.
 *
 * This operation ensures that no actual data is lost (just flagged as deleted),
 * which is critical for audit/legal compliance in regulated e-commerce. All
 * deletions are snapshotted, and audit/deletion event logs are created.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order related to the
 *   after-sales service being deleted.
 * @param props.afterSaleServiceId Unique identifier of the after-sales service
 *   case to be logically deleted.
 * @path /shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId
 * @accessor api.functional.shoppingMall.customer.orders.afterSaleServices.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the order related to the after-sales service
     * being deleted.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the after-sales service case to be logically
     * deleted.
     */
    afterSaleServiceId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/customer/orders/:orderId/afterSaleServices/:afterSaleServiceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/afterSaleServices/${encodeURIComponent(props.afterSaleServiceId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("afterSaleServiceId")(() =>
        typia.assert(props.afterSaleServiceId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
