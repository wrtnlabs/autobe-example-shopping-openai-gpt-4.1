import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomerIdentity } from "../../../../../structures/IShoppingMallCustomerIdentity";
import { IPageIShoppingMallCustomerIdentity } from "../../../../../structures/IPageIShoppingMallCustomerIdentity";

/**
 * Search and retrieve all identity verification records (KYC) linked to a
 * customer.
 *
 * This operation allows querying all identity verification entries tied to a
 * specific customer within the shopping mall platform. It directly interfaces
 * with the shopping_mall_customer_identities table, letting authorized users
 * perform advanced searches on identity records such as government ID,
 * passport, or driver's license information. The search allows filtering by
 * identity type, status, verification date, and issuer, supporting regulatory,
 * support, and audit functions.
 *
 * Access to this endpoint must be restricted to authorized roles (such as
 * admins and potentially the customer themselves for their own records) due to
 * the presence of sensitive PII. Business logic must enforce the customerId
 * path parameter strictly matches the referenced customer, with validation on
 * privacy and access rights. Search results are paginated by default for
 * scalability.
 *
 * Error scenarios include invalid customer ID (404), unauthorized access (403),
 * input validation errors (400), and rate limitation (429). Only non-deleted
 * identities are returned unless specifically requested for audit/compliance
 * scenarios.
 *
 * The request body supports advanced search and pagination parameters aligning
 * with expected fields such as identity_type, status, and verification dates.
 * The response includes summaries of matching identity records.
 *
 * This endpoint is related to identity detail retrieval (GET
 * /customers/{customerId}/identities/{identityId}) and update (PUT), forming
 * the read portion of customer KYC workflows.
 *
 * @param props.connection
 * @param props.customerId Unique identifier for the customer whose identities
 *   are being queried.
 * @param props.body Search and pagination criteria for customer identity
 *   records. Supports fields such as identity_type, status, issuer, and
 *   verification date ranges.
 * @path /shoppingMall/admin/customers/:customerId/identities
 * @accessor api.functional.shoppingMall.admin.customers.identities.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier for the customer whose identities are being
     * queried.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Search and pagination criteria for customer identity records.
     * Supports fields such as identity_type, status, issuer, and
     * verification date ranges.
     */
    body: IShoppingMallCustomerIdentity.IRequest;
  };
  export type Body = IShoppingMallCustomerIdentity.IRequest;
  export type Response = IPageIShoppingMallCustomerIdentity.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/customers/:customerId/identities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}/identities`;
  export const random = (): IPageIShoppingMallCustomerIdentity.ISummary =>
    typia.random<IPageIShoppingMallCustomerIdentity.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific customer identity verification
 * record.
 *
 * This operation fetches the complete details for a single identity
 * verification (KYC) record for a customer. It is used by administrators or
 * compliance officers to view sensitive personal information submitted for
 * identity validation including document type, status, issue date, issuer, and
 * verification status. The endpoint references
 * shopping_mall_customer_identities, cross-validating customerId and identityId
 * to ensure correct linkage and data access.
 *
 * Security is paramount: only authorized roles (admins, the customer for their
 * own identities) may access this data, and all accesses must be logged for
 * audit. Attempting to access a non-existent or mismatched record results in
 * 404 or 403 errors. Sensitive fields must be masked or redacted as per
 * business and legal requirements depending on the role making the request.
 *
 * This endpoint is typically used in conjunction with list/search and update
 * (PUT) operations. It does not expose underlying audit/snapshot tables, but
 * may reference them if legally required for dispute or compliance.
 *
 * Other error conditions include invalid parameters (400), unauthorized access
 * (403), and unexpected system errors (500).
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer whose identity
 *   record is being retrieved.
 * @param props.identityId Unique identifier of the identity verification record
 *   being retrieved.
 * @path /shoppingMall/admin/customers/:customerId/identities/:identityId
 * @accessor api.functional.shoppingMall.admin.customers.identities.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the customer whose identity record is being
     * retrieved.
     */
    customerId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the identity verification record being
     * retrieved.
     */
    identityId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomerIdentity;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/customers/:customerId/identities/:identityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}/identities/${encodeURIComponent(props.identityId ?? "null")}`;
  export const random = (): IShoppingMallCustomerIdentity =>
    typia.random<IShoppingMallCustomerIdentity>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("identityId")(() => typia.assert(props.identityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific customer identity verification record (KYC info).
 *
 * This operation enables authorized administrators to update a particular
 * customer identity verification (KYC) record. It interacts with the
 * shopping_mall_customer_identities table to modify fields such as identity
 * type, status, issue/verification date, issuer, or associated meta when
 * required for business/support/compliance corrections. Both customerId and
 * identityId parameters are required and strictly validated; the system ensures
 * only administrators (or the customer for limited self-service, if permitted)
 * can perform sensitive updates.
 *
 * The request body must provide a full or partial update adhering to validation
 * rules (e.g., valid status values, ISO date formats). Business rules may
 * enforce status transitions (e.g., pending→verified) and trigger audit
 * snapshots for compliance. All updates are logged with before/after state to
 * meet regulatory requirements.
 *
 * If either customer or identity record does not exist, a 404 error is
 * returned; permission violations return 403, and validation errors produce 400
 * responses. Unauthorized fields or transitions are blocked by business logic.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer.
 * @param props.identityId Unique identifier of the identity verification record
 *   to update.
 * @param props.body Update data for the customer identity record, such as
 *   status or verification details.
 * @path /shoppingMall/admin/customers/:customerId/identities/:identityId
 * @accessor api.functional.shoppingMall.admin.customers.identities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the customer. */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the identity verification record to update. */
    identityId: string & tags.Format<"uuid">;

    /**
     * Update data for the customer identity record, such as status or
     * verification details.
     */
    body: IShoppingMallCustomerIdentity.IUpdate;
  };
  export type Body = IShoppingMallCustomerIdentity.IUpdate;
  export type Response = IShoppingMallCustomerIdentity;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/customers/:customerId/identities/:identityId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}/identities/${encodeURIComponent(props.identityId ?? "null")}`;
  export const random = (): IShoppingMallCustomerIdentity =>
    typia.random<IShoppingMallCustomerIdentity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("identityId")(() => typia.assert(props.identityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a customer identity verification record.
 *
 * This operation performs a logical (soft) delete on a customer's identity
 * verification record. It sets the deleted_at field for the specified record in
 * shopping_mall_customer_identities, preventing further use but retaining the
 * record for audit, rollback, and legal evidence. The operation validates both
 * customerId and identityId path parameters, ensuring that only authorized
 * administrative roles can perform deletion.
 *
 * Soft-deleted records are excluded from normal queries but may be referenced
 * for regulatory compliance, dispute resolution, or explicit audit export. The
 * system logs the delete event including actor, timestamp, and business context
 * for evidence preservation. Attempting to delete a non-existent or already
 * deleted record results in 404 errors; unauthorized attempts return 403.
 *
 * There is no response body for this operation—confirmation is via status code
 * and audit log entry. Other error scenarios include validation errors (400),
 * permission failure (403), and system errors (500).
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer.
 * @param props.identityId Unique identifier of the identity verification record
 *   to delete.
 * @path /shoppingMall/admin/customers/:customerId/identities/:identityId
 * @accessor api.functional.shoppingMall.admin.customers.identities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer. */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier of the identity verification record to delete. */
    identityId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/customers/:customerId/identities/:identityId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}/identities/${encodeURIComponent(props.identityId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("identityId")(() => typia.assert(props.identityId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
