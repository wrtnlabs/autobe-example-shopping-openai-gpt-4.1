import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallCustomer } from "../../../../structures/IShoppingMallCustomer";
import { IPageIShoppingMallCustomer } from "../../../../structures/IPageIShoppingMallCustomer";
export * as identities from "./identities/index";

/**
 * Search and retrieve a filtered, paginated list of customer accounts from
 * shopping_mall_customers.
 *
 * Retrieve a filtered and paginated list of customer accounts stored in the
 * shopping_mall_customers table. This operation allows administrators to view
 * and manage customer information and profiles; it provides search, sort, and
 * pagination functions to help efficiently handle high-volume customer
 * records.
 *
 * This endpoint enables searching by channel, account status, KYC status,
 * email, name, and other metadata such as registration, deletion, and update
 * timestamps. Admin users can use this operation to identify customer segments,
 * monitor onboarding, process compliance requirements, or prepare data for
 * analytics.
 *
 * Security is enforced using the admin role, and business logic will implement
 * rate limiting and sensitive field masking as appropriate for compliance. This
 * is a critical operation for platform control, account lifecycle oversight,
 * and regulatory audit. Error handling includes proper messaging for invalid
 * query parameters or access denial if roles are not sufficient.
 *
 * @param props.connection
 * @param props.body Search and pagination criteria for retrieving customer
 *   accounts.
 * @path /shoppingMall/admin/customers
 * @accessor api.functional.shoppingMall.admin.customers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and pagination criteria for retrieving customer accounts. */
    body: IShoppingMallCustomer.IRequest;
  };
  export type Body = IShoppingMallCustomer.IRequest;
  export type Response = IPageIShoppingMallCustomer.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/customers";
  export const random = (): IPageIShoppingMallCustomer.ISummary =>
    typia.random<IPageIShoppingMallCustomer.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific customer by ID from
 * shopping_mall_customers.
 *
 * Retrieve full detailed information for an individual customer account by
 * specifying the customerId path parameter. Uses the shopping_mall_customers
 * table as the main resource, returning all relevant fields including channel,
 * email, phone, name, account status, KYC status, and audit timestamps.
 *
 * Administrators will use this endpoint to review or update (in a separate
 * operation) customer status, verify compliance (KYC), or analyze account
 * history. Sensitive PII is only accessible to authorized admin roles, and
 * business logic will ensure data masking and compliance with privacy law.
 *
 * If a customer with the provided ID does not exist or access is attempted by
 * an unauthorized role, the system will return appropriate error messaging.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the target customer account.
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target customer account. */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific customer account by ID in the shopping_mall_customers
 * table.
 *
 * Update the profile and metadata for an individual customer in the
 * shopping_mall_customers table. This is an admin-only operation that supports
 * modification to key fields such as email, phone, name, status, or KYC state.
 * The customerId path parameter specifies the record to update.
 *
 * Business logic will enforce field validation (for unique emails, channel
 * constraints, KYC/business status, etc.) and preserve audit history of changes
 * for compliance. Only administrators may use this operation to ensure
 * sensitive account changes are traced and authorized.
 *
 * If the supplied customerId does not reference an existing account, or if
 * update constraints are violated (duplicate email, invalid status), the
 * operation will return an error.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to update.
 * @param props.body Updated profile and meta information to apply to the
 *   selected customer account.
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the customer to update. */
    customerId: string & tags.Format<"uuid">;

    /**
     * Updated profile and meta information to apply to the selected
     * customer account.
     */
    body: IShoppingMallCustomer.IUpdate;
  };
  export type Body = IShoppingMallCustomer.IUpdate;
  export type Response = IShoppingMallCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallCustomer =>
    typia.random<IShoppingMallCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a specific customer account by setting deleted_at based on
 * customerId.
 *
 * Soft delete a customer account from the shopping_mall_customers table by
 * setting the deleted_at timestamp for the provided customerId. This action
 * does not remove the record from the database but instead marks it as deleted
 * for regulatory, legal, or compliance reasons. All previous history and audit
 * trails are retained.
 *
 * This operation is restricted to the admin role and should trigger business
 * logic for data masking, account access prevention, and detailed audit chain
 * recording. Customers marked as deleted are excluded from most standard
 * queries and are not accessible by regular users or via the main
 * customer-facing features.
 *
 * If the targeted customer record does not exist, or if the action is attempted
 * without administrative privileges, the system will return an error.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer account to be soft
 *   deleted.
 * @path /shoppingMall/admin/customers/:customerId
 * @accessor api.functional.shoppingMall.admin.customers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer account to be soft deleted. */
    customerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
