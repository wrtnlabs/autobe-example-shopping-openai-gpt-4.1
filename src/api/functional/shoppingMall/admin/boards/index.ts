import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallBoard } from "../../../../structures/IShoppingMallBoard";
export * as posts from "./posts/index";

/**
 * Create a new bulletin board with full configuration and access settings.
 *
 * This operation allows administrators or authorized users to register a new
 * board in the shopping mall backend, specifying parameters such as channel ID,
 * section ID, title, description, visibility (public, channel, or
 * section-restricted), whether moderation is required, and optional post expiry
 * policy. All required business fields are validated for uniqueness and
 * compliance with naming/policy guidelines (e.g., within-channel title
 * uniqueness).
 *
 * Security controls require authenticated users with board management rights;
 * all actions are audited for compliance. Invalid, duplicate, or unauthorized
 * board creation attempts result in reasoned error responses.
 *
 * Upon creation, the endpoint returns the complete configuration of the new
 * board per shopping_mall_boards schema, for immediate UI reflection or rule
 * engine integration.
 *
 * @param props.connection
 * @param props.body Board creation data including channel/section assignment,
 *   display and access configuration.
 * @path /shoppingMall/admin/boards
 * @accessor api.functional.shoppingMall.admin.boards.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Board creation data including channel/section assignment, display and
     * access configuration.
     */
    body: IShoppingMallBoard.ICreate;
  };
  export type Body = IShoppingMallBoard.ICreate;
  export type Response = IShoppingMallBoard;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/boards",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/boards";
  export const random = (): IShoppingMallBoard =>
    typia.random<IShoppingMallBoard>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update configuration, visibility, or moderation rules for a bulletin board.
 *
 * This operation updates properties of a specified board, such as channel and
 * section linkage, display title, description, visibility, moderation
 * requirement, and policy settings (e.g., post expiry). All changes are
 * strictly controlled by business rules, and uniqueness/authorization (e.g.,
 * only one 'main' board per channel) is enforced.
 *
 * Only users with board management/administrative rights can perform these
 * updates; actions are fully audited. Attempts to update non-existent, deleted,
 * or unauthorized boards yield error responses with feedback for correction.
 *
 * Response returns the updated board metadata, directly reflecting storage in
 * the shopping_mall_boards schema, for UI and configuration management
 * integration.
 *
 * @param props.connection
 * @param props.boardId Identifier of the bulletin board to update.
 * @param props.body Board update fields: display, business, moderation, or
 *   policy changes.
 * @path /shoppingMall/admin/boards/:boardId
 * @accessor api.functional.shoppingMall.admin.boards.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the bulletin board to update. */
    boardId: string & tags.Format<"uuid">;

    /**
     * Board update fields: display, business, moderation, or policy
     * changes.
     */
    body: IShoppingMallBoard.IUpdate;
  };
  export type Body = IShoppingMallBoard.IUpdate;
  export type Response = IShoppingMallBoard;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/boards/:boardId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/boards/${encodeURIComponent(props.boardId ?? "null")}`;
  export const random = (): IShoppingMallBoard =>
    typia.random<IShoppingMallBoard>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("boardId")(() => typia.assert(props.boardId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a board by its ID in the shopping_mall_boards table.
 *
 * The delete board operation enables privileged roles, typically
 * administrators, to remove a board entity from the system. This operation
 * targets the 'shopping_mall_boards' table and sets the 'deleted_at' field with
 * the current timestamp, enforcing a logical (soft) deletion policy. All posts
 * and content associated with the board will become inaccessible and preserved
 * for audit and compliance purposes as per system rules.
 *
 * Security is paramount: only roles with elevated permission, such as 'admin',
 * can call this endpoint. When invoked, dependent business logic is responsible
 * for handling cascading effects on child posts or metadata, as well as
 * triggering compliance or notification workflows.
 *
 * The endpoint will validate that the specified board exists and isn't already
 * deleted; non-existent IDs or already-deleted boards yield a business error.
 * The deletion event will be audit-logged for compliance, with downstream
 * moderation and evidence logic triggered where required by business or
 * regulatory rules.
 *
 * @param props.connection
 * @param props.boardId The unique identifier of the board to be deleted.
 * @path /shoppingMall/admin/boards/:boardId
 * @accessor api.functional.shoppingMall.admin.boards.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the board to be deleted. */
    boardId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/boards/:boardId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/boards/${encodeURIComponent(props.boardId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("boardId")(() => typia.assert(props.boardId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
