import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallDonation } from "../../../../structures/IShoppingMallDonation";
import { IPageIShoppingMallDonation } from "../../../../structures/IPageIShoppingMallDonation";

/**
 * Search and retrieve a paginated, filtered list of donation records.
 *
 * Retrieve a filtered, paginated list of donation records from the
 * shopping_mall_donations table. This operation allows both users and
 * administrators to view donation transactions based on various criteria,
 * including customer identity, donation source type (deposit or mileage),
 * campaign code, and status. Pagination parameters ensure efficient navigation
 * through potentially large result sets. Administrators can view system-wide or
 * filtered analytics; customers can view their personal donation history.
 * Search parameters may include time range, amount range, campaign, and
 * transaction status. The operation ensures sensitive information is properly
 * masked for non-admin users, and permission checks prevent cross-user data
 * access. The response contains a paginated summary of donation transactions
 * and relevant statistics.
 *
 * @param props.connection
 * @param props.body Search and pagination parameters for donation filtering,
 *   defined by IShoppingMallDonation.IRequest. Supports filtering by customer,
 *   campaign code, amount, date range, and status.
 * @path /shoppingMall/admin/donations
 * @accessor api.functional.shoppingMall.admin.donations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination parameters for donation filtering, defined by
     * IShoppingMallDonation.IRequest. Supports filtering by customer,
     * campaign code, amount, date range, and status.
     */
    body: IShoppingMallDonation.IRequest;
  };
  export type Body = IShoppingMallDonation.IRequest;
  export type Response = IPageIShoppingMallDonation.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/donations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/donations";
  export const random = (): IPageIShoppingMallDonation.ISummary =>
    typia.random<IPageIShoppingMallDonation.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific donation by its UUID from the
 * shopping_mall_donations table.
 *
 * This operation retrieves a detailed donation record for a given donation
 * identified by its unique UUID in the shopping_mall_donations table. The
 * donation record includes the donating customer, source type (deposit or
 * mileage), related campaign/event code, transferred amount, donation status
 * (pending, confirmed, failed, refunded, etc.), and full timestamp/audit
 * metadata.
 *
 * The endpoint is designed for auditability—enabling compliant review of
 * donation evidence, transparency for analytics, and support for legal
 * inquiries. Only authorized users may access donation records. Customers may
 * request their own information; administrators can access records for
 * compliance, fraud tracking, or dispute resolution.
 *
 * Validation enforces that donationId matches an extant record and that access
 * controls are respected. Errors may occur if the donation is missing, deleted,
 * or if the caller lacks permission. Related endpoints include donation
 * creation, update, and logical deletion.
 *
 * @param props.connection
 * @param props.donationId The unique identifier (UUID) of the donation to
 *   retrieve.
 * @path /shoppingMall/admin/donations/:donationId
 * @accessor api.functional.shoppingMall.admin.donations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The unique identifier (UUID) of the donation to retrieve. */
    donationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallDonation;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/donations/:donationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/donations/${encodeURIComponent(props.donationId ?? "null")}`;
  export const random = (): IShoppingMallDonation =>
    typia.random<IShoppingMallDonation>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("donationId")(() => typia.assert(props.donationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing donation entry’s allowed fields (status, evidence, notes)
 * by its UUID.
 *
 * This operation allows the update of a donation record, identified by
 * donationId, in the shopping_mall_donations table. Typically used for
 * administrative or support-driven interventions—such as marking a donation as
 * confirmed, failed, refunded, or associating an updated evidence reference or
 * compliance note. For customers, access is strictly limited to their own
 * donations and is only allowed while the donation remains pending, not after
 * finalization.
 *
 * Validation rules ensure only eligible status transitions or field updates are
 * allowed per business policy and compliance. All update events generate new
 * audit logs, preserving traceability for legal and regulatory needs. The
 * update endpoint does not permit modifying the core donation actor, amount, or
 * target campaign; it is reserved for non-destructive mutations related to
 * status and evidence. Attempts to update finalized, deleted, or unauthorized
 * donations are rejected with a clear error message.
 *
 * @param props.connection
 * @param props.donationId The unique identifier (UUID) of the donation to
 *   update.
 * @param props.body Allowed update info: new status (pending, confirmed,
 *   failed, refunded), evidence link, or compliance note, subject to business
 *   policy.
 * @path /shoppingMall/admin/donations/:donationId
 * @accessor api.functional.shoppingMall.admin.donations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier (UUID) of the donation to update. */
    donationId: string & tags.Format<"uuid">;

    /**
     * Allowed update info: new status (pending, confirmed, failed,
     * refunded), evidence link, or compliance note, subject to business
     * policy.
     */
    body: IShoppingMallDonation.IUpdate;
  };
  export type Body = IShoppingMallDonation.IUpdate;
  export type Response = IShoppingMallDonation;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/donations/:donationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/donations/${encodeURIComponent(props.donationId ?? "null")}`;
  export const random = (): IShoppingMallDonation =>
    typia.random<IShoppingMallDonation>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("donationId")(() => typia.assert(props.donationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (soft remove) a donation by its UUID, retaining data for
 * evidence and compliance.
 *
 * This operation performs logical deletion (soft delete) of the specified
 * donation, referenced by donationId. Rather than removing the record from the
 * database, it sets the deleted_at timestamp to guarantee regulatory evidence
 * retention, auditability, and rollback capabilities. The deletion is only
 * permitted if the donation is not in a finalized or protected state (e.g.,
 * after refund/settlement for certain jurisdictions per business logic), and
 * enforces authorization so only the owner or an admin may remove the record.
 *
 * This operation complies with data governance requirements, snapshot/evidence
 * retention policies, and ensures consistency with the system’s commitment to
 * non-destructive removal. Attempting to delete a protected, non-existent, or
 * unauthorized donation results in a clear error, with all actions logged for
 * compliance. Use corresponding endpoints for read/recovery as needed.
 *
 * @param props.connection
 * @param props.donationId The UUID of the donation to logically delete (soft
 *   remove).
 * @path /shoppingMall/admin/donations/:donationId
 * @accessor api.functional.shoppingMall.admin.donations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the donation to logically delete (soft remove). */
    donationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/donations/:donationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/donations/${encodeURIComponent(props.donationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("donationId")(() => typia.assert(props.donationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
