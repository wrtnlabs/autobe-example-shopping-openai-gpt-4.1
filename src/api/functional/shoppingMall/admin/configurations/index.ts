import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallConfiguration } from "../../../../structures/IShoppingMallConfiguration";
import { IPageIShoppingMallConfiguration } from "../../../../structures/IPageIShoppingMallConfiguration";

/**
 * Create a new business or system configuration (shopping_mall_configurations
 * table).
 *
 * This operation creates a new configuration entity in the shopping mall
 * backend, supporting both global and channel-specific system configuration
 * settings. Configurations are used for feature enablement, legal/compliance
 * presentation, social link settings, and application parameterization. All
 * business key/values, revision numbers, and descriptions are validated for
 * duplication, length, and policy-fit against the schema (see
 * shopping_mall_configurations table and comments).
 *
 * Security: Only system administrators (and optionally senior compliance or
 * technical operations) may invoke this endpoint, as unauthorized creation of
 * configuration values could undermine business rules or platform integrity.
 * All creation events are auditable, trigger snapshot/audit-logging, and tie
 * into configuration snapshot/recovery automation.
 *
 * Related operations include listing/search of configurations and update/put,
 * used for ongoing lifecycle management. Common errors include key duplication,
 * invalid input, or insufficient privileges. On success, the operation returns
 * the full configuration record as persisted.
 *
 * @param props.connection
 * @param props.body Information required to create a new configuration
 *   resource, matching configuration table columns including optional or
 *   business-mandated fields.
 * @path /shoppingMall/admin/configurations
 * @accessor api.functional.shoppingMall.admin.configurations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create a new configuration resource, matching
     * configuration table columns including optional or business-mandated
     * fields.
     */
    body: IShoppingMallConfiguration.ICreate;
  };
  export type Body = IShoppingMallConfiguration.ICreate;
  export type Response = IShoppingMallConfiguration;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/configurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/configurations";
  export const random = (): IShoppingMallConfiguration =>
    typia.random<IShoppingMallConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate shopping mall configuration records
 * (shopping_mall_configurations).
 *
 * Allows administrators to retrieve a filtered and paginated list of
 * configuration records for shopping mall channels or global settings,
 * facilitating effective management of feature flags, business rules, legal
 * disclosures, and other operational policies. The endpoint enables complex
 * filtering by key, channel association, revision, and creation/update time,
 * supporting scenario-based queries and configuration audits.
 *
 * Only administrators have access due to the sensitivity of configuration
 * records. Searches should be efficient, with support for advanced filtering
 * (e.g., partial key match, channel-specific queries, date range selection) and
 * paginated response structures for scalability. Returned data includes
 * detailed field values, revision metadata, and references to any related
 * snapshots for historical context.
 *
 * Business logic should ensure that deleted configuration records are excluded
 * by default unless explicitly queried. Errors in query parameters or excessive
 * request volume should yield informative error messages and may involve
 * throttling for large searches. Related endpoints include configuration get,
 * update, create, and configuration version history retrieval.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination criteria for configuration
 *   records.
 * @path /shoppingMall/admin/configurations
 * @accessor api.functional.shoppingMall.admin.configurations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination criteria for configuration records. */
    body: IShoppingMallConfiguration.IRequest;
  };
  export type Body = IShoppingMallConfiguration.IRequest;
  export type Response = IPageIShoppingMallConfiguration;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/configurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/configurations";
  export const random = (): IPageIShoppingMallConfiguration =>
    typia.random<IPageIShoppingMallConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get configuration detail for a specific configuration row by its ID
 * (shopping_mall_configurations table).
 *
 * This operation retrieves the details of a specific configuration object by
 * its unique identifier (UUID). It supports system-wide or channel-specific
 * configuration records managed via the shopping_mall_configurations table. The
 * endpoint ensures traceability, allowing authorized users (primarily
 * administrators) to audit or manage system-wide or per-channel business logic,
 * legal policies, or feature flags.
 *
 * Security: Only highly privileged admin roles or compliance-authorized staff
 * should access this operation, as configuration values may contain sensitive
 * business logic or control platform-wide behaviors. Access is strictly
 * limited, and all events should be logged for compliance/audit.
 *
 * The operation performs no mutation or modification of the database, but
 * ensures full visibility of all configuration properties, including
 * revision/version metadata. It is related to list/search (index) and update
 * operations, enabling lifecycle management and detailed audit of configuration
 * changes. Errors include not found, forbidden, or access denied responses,
 * with business error codes for invalid UUID or unauthorized access.
 *
 * @param props.connection
 * @param props.configurationId Unique identifier of the configuration resource
 *   to retrieve (UUID format).
 * @path /shoppingMall/admin/configurations/:configurationId
 * @accessor api.functional.shoppingMall.admin.configurations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the configuration resource to retrieve (UUID
     * format).
     */
    configurationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallConfiguration;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/configurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/configurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): IShoppingMallConfiguration =>
    typia.random<IShoppingMallConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing configuration resource by ID (shopping_mall_configurations
 * table).
 *
 * Updates the details of an existing configuration setting, which may control
 * global or channel-specific business logic, feature enablement, or legal
 * compliance artifacts. Uses the configurationId in the path to identify the
 * target record (see shopping_mall_configurations table comment for detailed
 * field semantics).
 *
 * All input is validated for business key, duplication, constraint rules, and
 * value format or size. Updates may include changes to the key, value, revision
 * incrementing, and description fields. Upon success, the updated configuration
 * is returned (including all audit metadata). The endpoint is strictly
 * admin-only due to security/compliance ramifications.
 *
 * All updates trigger audit/snapshot logic for regulatory traceability and
 * rollback. Related operations include get, list, and create. Errors may
 * include not found (invalid/conflicting configurationId), forbidden, invalid
 * request body, or business validation error codes.
 *
 * @param props.connection
 * @param props.configurationId Unique identifier of the configuration resource
 *   to update (UUID format).
 * @param props.body Updated configuration parameters, supporting full/partial
 *   upsert of business, logic, and display fields.
 * @path /shoppingMall/admin/configurations/:configurationId
 * @accessor api.functional.shoppingMall.admin.configurations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the configuration resource to update (UUID
     * format).
     */
    configurationId: string & tags.Format<"uuid">;

    /**
     * Updated configuration parameters, supporting full/partial upsert of
     * business, logic, and display fields.
     */
    body: IShoppingMallConfiguration.IUpdate;
  };
  export type Body = IShoppingMallConfiguration.IUpdate;
  export type Response = IShoppingMallConfiguration;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/configurations/:configurationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/configurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): IShoppingMallConfiguration =>
    typia.random<IShoppingMallConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete a configuration (soft delete) for system/audit compliance
 * (shopping_mall_configurations table).
 *
 * Marks the configuration object identified by configurationId as deleted,
 * setting its deleted_at field per compliance/audit rules. This is a logical
 * (soft) deletion as required for regulatory evidence retention; configuration
 * rows are never permanently removed from the system. Deletion triggers an
 * audit event, records pre/post-state snapshots, and restricts further use of
 * configuration values in downstream business logic.
 *
 * Administrators may use this to deprecate old, superseded, or errant
 * configuration records, ensuring traceability and compliance with policy.
 * Access is strictly limited to admin roles, and all actions are auditable.
 * Operation returns no content beyond operation success/error status.
 *
 * @param props.connection
 * @param props.configurationId Unique identifier of the configuration resource
 *   to delete (UUID format).
 * @path /shoppingMall/admin/configurations/:configurationId
 * @accessor api.functional.shoppingMall.admin.configurations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the configuration resource to delete (UUID
     * format).
     */
    configurationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/configurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/configurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
