import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallUserAgreement } from "../../../../structures/IShoppingMallUserAgreement";
import { IPageIShoppingMallUserAgreement } from "../../../../structures/IPageIShoppingMallUserAgreement";

/**
 * Search and filter user agreement records for compliance/audit
 * (shopping_mall_user_agreements).
 *
 * Retrieve a paginated and filterable list of user agreement entities from the
 * system for compliance, auditing, or policy management purposes. This endpoint
 * supports advanced filtering on agreement type, version, actor type, user
 * identity, acceptance/withdrawal timestamps, and more. Multiple agreements per
 * user and version are allowed per regulatory standards.
 *
 * This API is only accessible to platform administrators or roles with
 * audit/audit-log viewing permissions. Output includes masked or minimum
 * required PII depending on actor type and system configuration. Results are
 * paginated and sorted, and implementation should ensure fast index-based query
 * performance for large datasets.
 *
 * Related operations include GET/PUT for agreement detail and update, as well
 * as DELETE for removing agreement records in the case of error corrections or
 * privacy/withdrawal enforcement. Not to be used for self-service user privacy
 * consent flows.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for user
 *   agreement query.
 * @path /shoppingMall/admin/userAgreements
 * @accessor api.functional.shoppingMall.admin.userAgreements.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination parameters for user agreement query. */
    body: IShoppingMallUserAgreement.IRequest;
  };
  export type Body = IShoppingMallUserAgreement.IRequest;
  export type Response = IPageIShoppingMallUserAgreement.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/userAgreements",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/userAgreements";
  export const random = (): IPageIShoppingMallUserAgreement.ISummary =>
    typia.random<IPageIShoppingMallUserAgreement.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific user agreement record
 * (shopping_mall_user_agreements).
 *
 * Fetch a single user agreement record by its unique identifier for the
 * purposes of compliance, legal audit, or platform administration. The response
 * includes all core agreement fields: actor ID and type
 * (customer/seller/admin), agreement type (e.g., Terms, Privacy), document
 * version, acceptance and withdrawal timestamps, and unique constraints. Actor
 * information is revealed according to system policy and only for authorized
 * roles. Intended for deep-dive investigations of specific agreements or user
 * consent episodes, not bulk export or user self-service.
 *
 * Related operations include PATCH for indexed search, PUT for updating
 * agreement status or correcting administrative errors, and DELETE for removing
 * mistaken or legacy records, each subject to strict auditing. Improper or
 * unauthorized access triggers security logging and potential investigation.
 *
 * @param props.connection
 * @param props.userAgreementId Unique identifier of the target user agreement
 *   record.
 * @path /shoppingMall/admin/userAgreements/:userAgreementId
 * @accessor api.functional.shoppingMall.admin.userAgreements.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target user agreement record. */
    userAgreementId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallUserAgreement;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/userAgreements/:userAgreementId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/userAgreements/${encodeURIComponent(props.userAgreementId ?? "null")}`;
  export const random = (): IShoppingMallUserAgreement =>
    typia.random<IShoppingMallUserAgreement>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userAgreementId")(() =>
        typia.assert(props.userAgreementId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details or status of a user agreement record
 * (shopping_mall_user_agreements).
 *
 * Modify the details of a user agreement record, including setting or updating
 * the acceptance timestamp, withdrawal timestamp, or correcting version/type
 * fields as permitted by business policy and compliance regulation. PATCH/PUT
 * history is tracked for audit, and all updates require reason/context for the
 * change. Sensitive to role; only administrators or compliance operators may
 * perform updates. Any modification contrary to regulatory retention or user
 * privacy rules must be strictly blocked and logged for security. Updates are
 * subject to validation that agreement type/version match current policy
 * standards.
 *
 * Related API operations are GET to view user agreement detail, DELETE to
 * remove records for error correction or privacy withdrawal, and PATCH for
 * search/filtering in bulk audit scenarios. Errors return explicit reason codes
 * for business rules, retention limitations, or role violations.
 *
 * @param props.connection
 * @param props.userAgreementId Unique identifier of the user agreement to
 *   update.
 * @param props.body Fields to update in the user agreement record, such as
 *   acceptance/withdrawal date or agreement version/type. All fields are
 *   strictly validated for business/policy correctness.
 * @path /shoppingMall/admin/userAgreements/:userAgreementId
 * @accessor api.functional.shoppingMall.admin.userAgreements.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the user agreement to update. */
    userAgreementId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the user agreement record, such as
     * acceptance/withdrawal date or agreement version/type. All fields are
     * strictly validated for business/policy correctness.
     */
    body: IShoppingMallUserAgreement.IUpdate;
  };
  export type Body = IShoppingMallUserAgreement.IUpdate;
  export type Response = IShoppingMallUserAgreement;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/userAgreements/:userAgreementId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/userAgreements/${encodeURIComponent(props.userAgreementId ?? "null")}`;
  export const random = (): IShoppingMallUserAgreement =>
    typia.random<IShoppingMallUserAgreement>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userAgreementId")(() =>
        typia.assert(props.userAgreementId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (soft delete) a specific user agreement record for compliance or
 * correction (shopping_mall_user_agreements).
 *
 * Marks a user agreement record as deleted, making it logically removed from
 * standard query results but still available for audit and compliance as
 * required by regulatory and retention standards. This operation is strictly
 * limited to administrator or compliance roles, and is tracked with reason and
 * snapshot. Soft deletions ensure no permanent data removal occurs, only
 * legal/compliance-mandated logical removal. This endpoint must not permit
 * physical delete to meet compliance and audit requirements for user consents.
 * Attempts to delete non-existent or non-removable records result in clear
 * error messages and audit log entries for traceability.
 *
 * Typically used for correcting entries mistakenly created, fulfilling
 * GDPR/CCPA erasure requests, or maintaining retention/expunge policies.
 * Associated audit and entity snapshots are referenced for downstream
 * evidence.
 *
 * @param props.connection
 * @param props.userAgreementId Unique identifier of the target user agreement
 *   record to remove.
 * @path /shoppingMall/admin/userAgreements/:userAgreementId
 * @accessor api.functional.shoppingMall.admin.userAgreements.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target user agreement record to remove. */
    userAgreementId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/userAgreements/:userAgreementId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/userAgreements/${encodeURIComponent(props.userAgreementId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userAgreementId")(() =>
        typia.assert(props.userAgreementId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
