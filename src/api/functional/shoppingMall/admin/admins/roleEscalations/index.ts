import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAdminRoleEscalation } from "../../../../../structures/IShoppingMallAdminRoleEscalation";
import { IPageIShoppingMallAdminRoleEscalation } from "../../../../../structures/IPageIShoppingMallAdminRoleEscalation";

/**
 * List and search role escalation requests for a given admin
 * (shopping_mall_admin_role_escalations).
 *
 * Retrieve a paginated and filterable list of all role escalation requests
 * (such as customer→admin or seller→admin privilege changes) that are
 * associated with a target administrator. Each result includes status,
 * escalation type, reviewer, reasons, and relevant timestamps for audit and
 * compliance, leveraging the structure of the
 * shopping_mall_admin_role_escalations table.
 *
 * This operation is primarily used by administrators to manage and review
 * workflow status, approval/rejection history, and review escalation evidence.
 * Role-based security ensures only properly privileged admins can access the
 * escalation queue. Filtering may be done by requestor, escalation type,
 * status, or time range to facilitate rapid investigation or compliance
 * review.
 *
 * Pagination, search, and sorting are available; responses present summary
 * information suitable for list or dashboard views and are linked to full
 * escalation records. This endpoint supports regulatory compliance, audit
 * trails, and helps prevent privilege escalation abuse within the mall
 * platform.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin user to query role
 *   escalations for
 * @param props.body Request parameters for escalation list search, filters, and
 *   pagination options
 * @path /shoppingMall/admin/admins/:adminId/roleEscalations
 * @accessor api.functional.shoppingMall.admin.admins.roleEscalations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the admin user to query role escalations for */
    adminId: string & tags.Format<"uuid">;

    /**
     * Request parameters for escalation list search, filters, and
     * pagination options
     */
    body: IShoppingMallAdminRoleEscalation.IRequest;
  };
  export type Body = IShoppingMallAdminRoleEscalation.IRequest;
  export type Response = IPageIShoppingMallAdminRoleEscalation.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/admins/:adminId/roleEscalations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/roleEscalations`;
  export const random = (): IPageIShoppingMallAdminRoleEscalation.ISummary =>
    typia.random<IPageIShoppingMallAdminRoleEscalation.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information about a specific admin role escalation request
 * (shopping_mall_admin_role_escalations).
 *
 * Retrieve full, detailed information about a specific role escalation request
 * by its unique identifier for a given administrator. The response includes all
 * major columns and context from the shopping_mall_admin_role_escalations
 * entity, such as actors, workflow status, reviewer, reason codes, timestamps,
 * and references to any supporting evidence or snapshots.
 *
 * Use this operation to support detailed step-through auditing, compliance
 * traceability, or business rule enforcement regarding admin privilege
 * escalation. Only administrators or privileged reviewers can access detailed
 * escalation data, ensuring sensitive escalation audit trails remain protected
 * from unauthorized access. Related operations may include POST/PUT for
 * escalation review or status update, and DELETE for log/audit retention.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin user (context of the
 *   escalation)
 * @param props.escalationId Unique identifier for the specific role escalation
 *   request
 * @path /shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.admins.roleEscalations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the admin user (context of the escalation) */
    adminId: string & tags.Format<"uuid">;

    /** Unique identifier for the specific role escalation request */
    escalationId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAdminRoleEscalation;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/roleEscalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): IShoppingMallAdminRoleEscalation =>
    typia.random<IShoppingMallAdminRoleEscalation>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.param("escalationId")(() => typia.assert(props.escalationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update information or status of an admin role escalation request
 * (shopping_mall_admin_role_escalations).
 *
 * Update the workflow status, add comments, assign a reviewer, or modify other
 * business logic fields of a specific admin role escalation request. This
 * operation allows administrators to review, approve, reject, or cancel
 * escalation requests, recording the action and context for compliance.
 *
 * All changes are subject to audit logging and may require supporting
 * commentary or reference to evidence. Authorization is strictly enforced, so
 * only privileged admin users may update escalation records. Updates support
 * granular traceability for regulatory and internal policy compliance.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin user (context for
 *   escalation modification)
 * @param props.escalationId Unique identifier for the role escalation request
 *   to update
 * @param props.body Fields to update for the target escalation (status, review
 *   reason, evidence refs, reviewer, etc)
 * @path /shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.admins.roleEscalations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the admin user (context for escalation
     * modification)
     */
    adminId: string & tags.Format<"uuid">;

    /** Unique identifier for the role escalation request to update */
    escalationId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the target escalation (status, review reason,
     * evidence refs, reviewer, etc)
     */
    body: IShoppingMallAdminRoleEscalation.IUpdate;
  };
  export type Body = IShoppingMallAdminRoleEscalation.IUpdate;
  export type Response = IShoppingMallAdminRoleEscalation;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/roleEscalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): IShoppingMallAdminRoleEscalation =>
    typia.random<IShoppingMallAdminRoleEscalation>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.param("escalationId")(() => typia.assert(props.escalationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific admin role escalation request
 * (shopping_mall_admin_role_escalations).
 *
 * Permanently remove a role escalation request from the
 * shopping_mall_admin_role_escalations table. This operation executes a hard
 * delete, completely removing the record from the database. The deletion is
 * irreversible and should only be performed by administrators in accordance
 * with business policy or error correction needs.
 *
 * Appropriate audit logging and authorization are required. Usage of this
 * endpoint should comply with internal and regulatory requirements for entity
 * removal and is intended only for exceptional cases where true deletion is
 * authorized. No response body is returned for this operation.
 *
 * @param props.connection
 * @param props.adminId Unique identifier of the admin user (who owns or manages
 *   the escalation)
 * @param props.escalationId Unique identifier for the role escalation request
 *   to permanently remove
 * @path /shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId
 * @accessor api.functional.shoppingMall.admin.admins.roleEscalations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the admin user (who owns or manages the
     * escalation)
     */
    adminId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the role escalation request to permanently
     * remove
     */
    escalationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/admins/:adminId/roleEscalations/:escalationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/admins/${encodeURIComponent(props.adminId ?? "null")}/roleEscalations/${encodeURIComponent(props.escalationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("adminId")(() => typia.assert(props.adminId));
      assert.param("escalationId")(() => typia.assert(props.escalationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
