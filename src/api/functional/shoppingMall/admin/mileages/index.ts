import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallMileage } from "../../../../structures/IShoppingMallMileage";
import { IPageIShoppingMallMileage } from "../../../../structures/IPageIShoppingMallMileage";
export * as transactions from "./transactions/index";

/**
 * Create a new shopping mall mileage (loyalty/point) account entity for a user
 * or campaign.
 *
 * Creates a new mileage (loyalty/point system) account within the shopping mall
 * platform. The shopping_mall_mileages entity captures per-user loyalty point
 * balances and audit meta for all active mileage/point use. This endpoint can
 * be used to initialize a default mileage account for new customers or issue a
 * special loyalty account for bonus campaigns. Permissions are restricted to
 * administrators or business automation modules to maintain regulatory and
 * business integrity.
 *
 * All input values are validated per schema and business logic before record
 * creation—duplicate mileage accounts for a user are not allowed, and
 * status/expiry fields are checked for compliance. Success returns the full
 * mileage entity. Related endpoints include retrieval (GET), search (PATCH),
 * and transaction management. Error scenarios provide clear business rationales
 * (e.g., already initialized, bad status value, insufficient permission).
 *
 * @param props.connection
 * @param props.body Payload for new mileage (loyalty point) account creation;
 *   must match schema and business rules for initial status, balance, customer
 *   link, etc.
 * @path /shoppingMall/admin/mileages
 * @accessor api.functional.shoppingMall.admin.mileages.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Payload for new mileage (loyalty point) account creation; must match
     * schema and business rules for initial status, balance, customer link,
     * etc.
     */
    body: IShoppingMallMileage.ICreate;
  };
  export type Body = IShoppingMallMileage.ICreate;
  export type Response = IShoppingMallMileage;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/mileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/mileages";
  export const random = (): IShoppingMallMileage =>
    typia.random<IShoppingMallMileage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of shopping mall mileage/point
 * accounts for administrative use.
 *
 * Fetches a list of all mileage (loyalty/point) accounts in the system
 * according to search, filter, and pagination parameters. The
 * shopping_mall_mileages table models each user's mileage/point balance
 * account, used for rewards, campaigns, and compliance audit. This endpoint
 * supports complex request bodies for multifaceted filter/search/sort; it
 * returns a paginated summary suitable for admin analytics dash boards and
 * operational view. Searchable fields typically include account status (active,
 * expired, frozen), expiry date, balance thresholds, and per-user scoping. Only
 * admin users can access all mileage accounts; this operation never exposes raw
 * PII, linking only on business identifiers. Related endpoints include single
 * account detail queries (GET), creation (POST), and mileage transaction
 * history (PATCH/GET on transactions).
 *
 * @param props.connection
 * @param props.body Complex search/filter/sort parameters for mileage (loyalty
 *   point) account retrieval and pagination; supports status, balance, and
 *   user-based filtering.
 * @path /shoppingMall/admin/mileages
 * @accessor api.functional.shoppingMall.admin.mileages.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Complex search/filter/sort parameters for mileage (loyalty point)
     * account retrieval and pagination; supports status, balance, and
     * user-based filtering.
     */
    body: IShoppingMallMileage.IRequest;
  };
  export type Body = IShoppingMallMileage.IRequest;
  export type Response = IPageIShoppingMallMileage.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/mileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/mileages";
  export const random = (): IPageIShoppingMallMileage.ISummary =>
    typia.random<IPageIShoppingMallMileage.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the detailed information of a specific mileage (loyalty point)
 * account by its ID.
 *
 * Fetches a detailed, non-editable view of a particular mileage (loyalty/point
 * system) account using its unique mileageId (UUID). The shopping_mall_mileages
 * entity provides per-user point balances, status, and expiry/creation metadata
 * for loyalty programs. This operation is important for admin audit/compliance,
 * support review, or before taking further action on the account. Authorization
 * is limited to administrative/business users; personal account viewing for end
 * customers is handled through user-specific endpoints.
 *
 * If the account is not found (invalid or deleted ID) or user lacks permission,
 * the operation returns a clear error code and no account data. Related
 * endpoints include account searching (PATCH /mileages), creation (POST), and
 * transaction viewing. This operation enforces all business security policies,
 * masking or excluding sensitive data as per role and context.
 *
 * @param props.connection
 * @param props.mileageId Unique identifier for the mileage account record; must
 *   be a valid UUID as per shopping_mall_mileages.id.
 * @path /shoppingMall/admin/mileages/:mileageId
 * @accessor api.functional.shoppingMall.admin.mileages.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the mileage account record; must be a valid
     * UUID as per shopping_mall_mileages.id.
     */
    mileageId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallMileage;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/mileages/:mileageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/mileages/${encodeURIComponent(props.mileageId ?? "null")}`;
  export const random = (): IShoppingMallMileage =>
    typia.random<IShoppingMallMileage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the details of a mileage (loyalty/point) account in the
 * shopping_mall_mileages table.
 *
 * Update a specific mileage record by its UUID from the shopping_mall_mileages
 * table. This operation is used for administrative or customer self-service
 * adjustments to a user's mileage (loyalty point) account, such as balance
 * corrections, status changes (active, expired, frozen), or setting of
 * expiration dates.
 *
 * This API requires careful handling of concurrency and security, as altering
 * mileage balances can affect user experience and financial reconciliation.
 * Business rules may restrict who can update which fields, and all actions are
 * typically logged for compliance. The operation also checks the validity of
 * mileage status, ensures non-negative balances, and handles expiration fields
 * as defined in the schema.
 *
 * Authorization is enforced based on role: only account owners or
 * administrators may update their mileage. All updates are versioned and may be
 * snapshotted for audit and rollback. Related operations include retrieving a
 * mileage account, paging through transaction history, and account creation or
 * logical deletion. Validation errors should be explicitly communicated, and
 * all field changes require strict audit logging and, where applicable, consent
 * for critical changes (such as balance adjustment).
 *
 * @param props.connection
 * @param props.mileageId The unique identifier of the mileage account to
 *   update.
 * @param props.body Updated mileage account information, including fields such
 *   as balance, status, and expiration as defined by the schema.
 * @path /shoppingMall/admin/mileages/:mileageId
 * @accessor api.functional.shoppingMall.admin.mileages.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the mileage account to update. */
    mileageId: string & tags.Format<"uuid">;

    /**
     * Updated mileage account information, including fields such as
     * balance, status, and expiration as defined by the schema.
     */
    body: IShoppingMallMileage.IUpdate;
  };
  export type Body = IShoppingMallMileage.IUpdate;
  export type Response = IShoppingMallMileage;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/mileages/:mileageId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/mileages/${encodeURIComponent(props.mileageId ?? "null")}`;
  export const random = (): IShoppingMallMileage =>
    typia.random<IShoppingMallMileage>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (logically remove) a mileage account by marking deleted_at in
 * shopping_mall_mileages table.
 *
 * Soft-delete an existing mileage (loyalty/point) account given its UUID. This
 * operation is intended for either account owners or administrators to
 * deactivate or logically remove a mileage account without losing historical
 * data, as required for legal, financial, or user service reasons.
 *
 * The operation simply marks the deleted_at timestamp in accordance with the
 * schema-defined soft delete design. No data is permanently erased, ensuring
 * full audit trails and recoverability for regulatory compliance (such as
 * GDPR/CCPA erasure on proper approval). Only authorized users—typically the
 * owner of the mileage or administrators—may trigger this operation. Coupled
 * with business logic and permission checks, the API ensures no active balance
 * is lost or misaccounted. Related operations include restoring a logically
 * deleted mileage, listing active/inactive accounts, or querying snapshot
 * evidence for disputes.
 *
 * Implementation MUST NOT physically remove the record or affect associated
 * mileage transactions and analytics. All actions are strictly logged for
 * compliance.
 *
 * @param props.connection
 * @param props.mileageId The unique identifier of the mileage account to
 *   soft-delete.
 * @path /shoppingMall/admin/mileages/:mileageId
 * @accessor api.functional.shoppingMall.admin.mileages.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the mileage account to soft-delete. */
    mileageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/mileages/:mileageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/mileages/${encodeURIComponent(props.mileageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
