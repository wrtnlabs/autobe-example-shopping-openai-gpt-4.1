import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallPayment } from "../../../../../structures/IShoppingMallPayment";
import { IPageIShoppingMallPayment } from "../../../../../structures/IPageIShoppingMallPayment";
export * as snapshots from "./snapshots/index";

/**
 * Create a new payment for an order (shopping_mall_payments) with full business
 * rule validation.
 *
 * This endpoint allows authorized users to initiate a new payment against an
 * order, specifying all required details such as payment type, amount, customer
 * identity, and optional external references. The system performs validation on
 * payment rules: matching allowed payment methods, checking maximum/minimum
 * values, and ensuring no redundant or conflicting payments for the order.
 *
 * Upon success, creates a payment record in shopping_mall_payments, links it to
 * the order, and returns the created payment with full business context. Async
 * and external (e.g., virtual account) payments must be correctly flagged and
 * all evidence chains preserved. Audit and PCI compliance apply to the request
 * and response bodies.
 *
 * Security and permission checks ensure this operation can only be performed by
 * authorized roles (e.g., customer placing the order, system admin, possibly
 * seller in limited contexts).
 *
 * In the event of validation or business rule failure, returns a clear,
 * actionable 400 or 422 error with specific reason and remediation options.
 *
 * @param props.connection
 * @param props.orderId UUID of the order for which payment is being initiated.
 * @param props.body Payment creation details: type, amount, customer,
 *   settlement data, etc.
 * @path /shoppingMall/admin/orders/:orderId/payments
 * @accessor api.functional.shoppingMall.admin.orders.payments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the order for which payment is being initiated. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Payment creation details: type, amount, customer, settlement data,
     * etc.
     */
    body: IShoppingMallPayment.ICreate;
  };
  export type Body = IShoppingMallPayment.ICreate;
  export type Response = IShoppingMallPayment;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/orders/:orderId/payments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments`;
  export const random = (): IShoppingMallPayment =>
    typia.random<IShoppingMallPayment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search all payment records associated with a specific order
 * (shopping_mall_payments) with pagination and filtering.
 *
 * Allows authorized users to retrieve a paginated, filtered list of all
 * payments linked to a specific order. Query can include filters for payment
 * status, type, date ranges, or other payment-specific attributes as defined in
 * the request body DTO.
 *
 * Supports business operations such as viewing all payment attempts,
 * reconciling refunds, and tracking multi-method settlements for complex order
 * flows. Pagination parameters control result size and sorting, adhering to
 * standard patterns for performance and usability.
 *
 * DB integration: Uses shopping_mall_payments filtered by the given orderId,
 * with possible joins to orders and customers for additional context. Only
 * users with access to the order (customer, related seller, or admin) can use
 * this endpoint. Permission and data masking apply for privacy compliance.
 *
 * The response structure includes a list of payment summaries, paginated, and
 * metadata for total count, pages, etc. All returned records are mapped and
 * masked according to user permissions.
 *
 * @param props.connection
 * @param props.orderId UUID of the target order to fetch payments for.
 * @param props.body Search and filter criteria for payments, including date
 *   range, status, payment type, and pagination parameters.
 * @path /shoppingMall/admin/orders/:orderId/payments
 * @accessor api.functional.shoppingMall.admin.orders.payments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the target order to fetch payments for. */
    orderId: string & tags.Format<"uuid">;

    /**
     * Search and filter criteria for payments, including date range,
     * status, payment type, and pagination parameters.
     */
    body: IShoppingMallPayment.IRequest;
  };
  export type Body = IShoppingMallPayment.IRequest;
  export type Response = IPageIShoppingMallPayment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orders/:orderId/payments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments`;
  export const random = (): IPageIShoppingMallPayment.ISummary =>
    typia.random<IPageIShoppingMallPayment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail of a single payment under a specific order
 * (shopping_mall_payments).
 *
 * Fetches a single payment instance linked to a given order, returning full
 * details for reconciliation, business audit, or customer service inquiries.
 * Enforces both orderId and paymentId as mandatory UUID parameters, verifying
 * that the payment belongs to the specified order and is accessible by the
 * requesting user.
 *
 * Typical use cases include analytics of split payments, audit of refunds or
 * failed attempts, and programmatic lookup for order history screens. Only
 * users affiliated to the order (such as admins, the ordering customer, or
 * responsible seller) may access this endpoint; permission checks must be
 * strictly enforced.
 *
 * Response includes all available details of the payment (amount, status, type,
 * settlement references, timestamps, failure/cancellation info where relevant),
 * as held in the shopping_mall_payments table and related entities.
 *
 * @param props.connection
 * @param props.orderId UUID of the referenced order for context and permission
 *   checks.
 * @param props.paymentId UUID of the payment record to fetch; must belong to
 *   the given order.
 * @path /shoppingMall/admin/orders/:orderId/payments/:paymentId
 * @accessor api.functional.shoppingMall.admin.orders.payments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the referenced order for context and permission checks. */
    orderId: string & tags.Format<"uuid">;

    /** UUID of the payment record to fetch; must belong to the given order. */
    paymentId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallPayment;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orders/:orderId/payments/:paymentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments/${encodeURIComponent(props.paymentId ?? "null")}`;
  export const random = (): IShoppingMallPayment =>
    typia.random<IShoppingMallPayment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("paymentId")(() => typia.assert(props.paymentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific payment record under an order (shopping_mall_payments).
 *
 * This operation is used to update all mutable fields of a specific payment
 * (referenced by paymentId) belonging to an order (referenced by orderId) in
 * the shopping mall backend. The 'shopping_mall_payments' entity supports
 * business flows such as confirming payments, marking them as refunded or
 * cancelled, updating payment type, or altering reference fields for
 * asynchronous/external settlements.
 *
 * Updates are restricted to valid status transitions, and permission checks
 * must ensure only authorized roles (admin, finance) can perform these
 * modifications. All operations are logged for auditability, and a payment
 * snapshot may be created after the update for compliance. The system will
 * reject updates that attempt to modify immutable fields or transition the
 * payment to illegal states (e.g., marking already settled payments as
 * pending).
 *
 * The underlying schema ensures payment records have strong referential binding
 * to orders and customers. Related endpoints allow for payment state
 * transitions, snapshot retrievals, and audit trail inspection. Clients must
 * provide a well-formed update body according to payment business rules and
 * data type constraints.
 *
 * Related operations include retrieving specific payments (GET), listing all
 * payments for an order, or creating payment snapshots to preserve history.
 * Errors may occur if referenced orderId/paymentId are not found, or if
 * business rule validation fails.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order containing the payment to
 *   update.
 * @param props.paymentId Unique identifier of the payment to be updated.
 * @param props.body Properties to update for the specified payment record. Only
 *   mutable fields are accepted.
 * @path /shoppingMall/admin/orders/:orderId/payments/:paymentId
 * @accessor api.functional.shoppingMall.admin.orders.payments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the order containing the payment to update. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the payment to be updated. */
    paymentId: string & tags.Format<"uuid">;

    /**
     * Properties to update for the specified payment record. Only mutable
     * fields are accepted.
     */
    body: IShoppingMallPayment.IUpdate;
  };
  export type Body = IShoppingMallPayment.IUpdate;
  export type Response = IShoppingMallPayment;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/orders/:orderId/payments/:paymentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments/${encodeURIComponent(props.paymentId ?? "null")}`;
  export const random = (): IShoppingMallPayment =>
    typia.random<IShoppingMallPayment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("paymentId")(() => typia.assert(props.paymentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a specific payment in an order (sets deleted_at on
 * shopping_mall_payments).
 *
 * This endpoint soft-deletes a specific payment record (by paymentId)
 * associated with a given order (by orderId) in the shopping mall backend.
 * Payment records are never physically destroyed; instead, the 'deleted_at'
 * timestamp is set for regulatory compliance and audit trail preservation. Only
 * users with administrative permissions may access this operation, and all
 * actions are fully auditable.
 *
 * Business rules ensure that only payments that are not fully reconciled or
 * settled may be logically deleted; otherwise, an error is returned. The system
 * maintains references to related audit/snapshot records and updates payment
 * status upon soft deletion. This operation is critical for compliance
 * environments where financial records cannot be hard deleted.
 *
 * If either the payment or the order is not found, or if the payment is locked
 * from deletion due to settlement or ongoing dispute, the request fails and an
 * error describing the problem is provided.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order containing the payment to
 *   delete.
 * @param props.paymentId Unique identifier of the payment to be soft-deleted.
 * @path /shoppingMall/admin/orders/:orderId/payments/:paymentId
 * @accessor api.functional.shoppingMall.admin.orders.payments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the order containing the payment to delete. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the payment to be soft-deleted. */
    paymentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/orders/:orderId/payments/:paymentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments/${encodeURIComponent(props.paymentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("paymentId")(() => typia.assert(props.paymentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
