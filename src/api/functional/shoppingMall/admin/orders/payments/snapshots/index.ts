import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallPaymentSnapshot } from "../../../../../../structures/IShoppingMallPaymentSnapshot";
import { IPageIShoppingMallPaymentSnapshot } from "../../../../../../structures/IPageIShoppingMallPaymentSnapshot";

/**
 * Search payment snapshot history for a payment under an order
 * (shopping_mall_payment_snapshots).
 *
 * This endpoint provides a filtered and paginated collection of all historical
 * snapshots for a particular payment (paymentId), under a specific order
 * (orderId). The underlying table, 'shopping_mall_payment_snapshots', stores
 * complete, immutable records of payment states at each significant
 * eventâ€”creation, processing, confirmation, update, or deletion. Used for
 * audit, compliance, and dispute investigation.
 *
 * Supports advanced search by snapshot timestamp, event type (if referenced in
 * the data), and free-text filtering where implemented. Pagination options
 * prevent overload from large audit histories. Only admin roles may access
 * detailed payment snapshots due to sensitive business and personal data.
 * Typical usage scenarios include financial audit, compliance reviews, fraud
 * investigations, and operational support. Related endpoints allow access to
 * the current payment record, as well as creation and update flows for payment
 * entries.
 *
 * Errors result from missing payment references, invalid order/payment IDs, or
 * out-of-bounds pagination parameters. Output includes all key business/archive
 * fields for reconstructing payment history as required by regulatory or
 * dispute processes.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order containing the referenced
 *   payment.
 * @param props.paymentId Unique identifier of the payment whose snapshots are
 *   being queried.
 * @param props.body Search criteria and pagination parameters for payment
 *   snapshot filtering.
 * @path /shoppingMall/admin/orders/:orderId/payments/:paymentId/snapshots
 * @accessor api.functional.shoppingMall.admin.orders.payments.snapshots.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the order containing the referenced payment. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the payment whose snapshots are being queried. */
    paymentId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for payment snapshot
     * filtering.
     */
    body: IShoppingMallPaymentSnapshot.IRequest;
  };
  export type Body = IShoppingMallPaymentSnapshot.IRequest;
  export type Response = IPageIShoppingMallPaymentSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orders/:orderId/payments/:paymentId/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments/${encodeURIComponent(props.paymentId ?? "null")}/snapshots`;
  export const random = (): IPageIShoppingMallPaymentSnapshot =>
    typia.random<IPageIShoppingMallPaymentSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("paymentId")(() => typia.assert(props.paymentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific payment snapshot for a payment in an order
 * (shopping_mall_payment_snapshots).
 *
 * This endpoint allows an authorized admin to fetch all information about one
 * specific payment snapshot, designated by snapshotId, for a payment (by
 * paymentId) within an order (by orderId). Payment snapshots capture full
 * immutable records of the payment at each critical state transition for
 * evidence and compliance, such as payment request, confirmation, cancellation,
 * or refund events.
 *
 * The result includes all business fields and compliance/audit meta as
 * serialized at the time the snapshot was created. Typical scenarios include
 * dispute resolution, audit export, and compliance reporting. Appropriate error
 * messages are returned if any referenced record is not found, or if
 * authorization rules are not met. Related endpoints enable listing all
 * snapshots or retrieving the latest active payment record.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order containing the referenced
 *   payment.
 * @param props.paymentId Unique identifier of the payment whose snapshot is
 *   being retrieved.
 * @param props.snapshotId Unique identifier of the payment snapshot record to
 *   retrieve.
 * @path /shoppingMall/admin/orders/:orderId/payments/:paymentId/snapshots/:snapshotId
 * @accessor api.functional.shoppingMall.admin.orders.payments.snapshots.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the order containing the referenced payment. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the payment whose snapshot is being retrieved. */
    paymentId: string & tags.Format<"uuid">;

    /** Unique identifier of the payment snapshot record to retrieve. */
    snapshotId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallPaymentSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orders/:orderId/payments/:paymentId/snapshots/:snapshotId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/payments/${encodeURIComponent(props.paymentId ?? "null")}/snapshots/${encodeURIComponent(props.snapshotId ?? "null")}`;
  export const random = (): IShoppingMallPaymentSnapshot =>
    typia.random<IShoppingMallPaymentSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("paymentId")(() => typia.assert(props.paymentId));
      assert.param("snapshotId")(() => typia.assert(props.snapshotId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
