import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallShipmentItem } from "../../../../../../structures/IShoppingMallShipmentItem";
import { IPageIShoppingMallShipmentItem } from "../../../../../../structures/IPageIShoppingMallShipmentItem";

/**
 * Add a new shipment item to a specific shipment within an order. Associated
 * with shopping_mall_shipment_items.
 *
 * This API operation creates and adds a new shipment item to the specified
 * shipment of an order. Shipment items represent the discrete quantities of
 * ordered products that are included in a shipment batch and are crucial for
 * supporting complex shipment, tracking, and fulfillment business flows common
 * in large e-commerce platforms.
 *
 * The request body must include the required details matching the
 * IShoppingMallShipmentItem.ICreate contract (including which order item is to
 * be marked as shipped, the quantity, and associated product/variant
 * references). Business validation ensures the item is part of the referenced
 * order, is not already fully shipped, and the addition does not violate
 * inventory or order integrity constraints. Errors are returned for attempts to
 * over-ship items, reference non-existent entities, or business rule
 * violations.
 *
 * Authorization is restricted to sellers handling fulfillment and system
 * administrators. Upon success, the created shipment item record is returned
 * for UI updating, downstream automation, and audit history. Audit and
 * compliance are ensured by recording all event metadata and linking to
 * relevant order/shipment/fulfillment chains.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the target order under which the
 *   shipment is being managed.
 * @param props.shipmentId Unique identifier for the parent shipment to which
 *   the item will be added.
 * @param props.body Creation request with order item reference, product/variant
 *   info, and shipped quantity.
 * @path /shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items
 * @accessor api.functional.shoppingMall.admin.orders.shipments.items.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier for the target order under which the shipment is
     * being managed.
     */
    orderId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the parent shipment to which the item will be
     * added.
     */
    shipmentId: string & tags.Format<"uuid">;

    /**
     * Creation request with order item reference, product/variant info, and
     * shipped quantity.
     */
    body: IShoppingMallShipmentItem.ICreate;
  };
  export type Body = IShoppingMallShipmentItem.ICreate;
  export type Response = IShoppingMallShipmentItem;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/shipments/${encodeURIComponent(props.shipmentId ?? "null")}/items`;
  export const random = (): IShoppingMallShipmentItem =>
    typia.random<IShoppingMallShipmentItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("shipmentId")(() => typia.assert(props.shipmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Filter and retrieve a paginated list of shipment items for a specific order
 * shipment. Associated with shopping_mall_shipment_items.
 *
 * This API allows users to retrieve a filtered, paginated list of shipment
 * items associated with a specific order and shipment. The operation supports
 * advanced search and filtering, taking advantage of the
 * shopping_mall_shipment_items schema's structure—for example, filtering by
 * referenced order items, quantity, shipment batch, or item creation date. It
 * is optimized for large-scale batch shipments as common in enterprise commerce
 * flows.
 *
 * Authorization is required; typically, sellers responsible for the shipment,
 * order owners, or admins may invoke this endpoint. Pagination parameters,
 * complex filters, and sorting options (by created_at, product, fulfillment
 * state) are supported via the request body. The response returns a paginated
 * list including details for each shipment item, supporting business process
 * integration and audit/compliance review.
 *
 * Security considerations include ensuring that only actors linked to the
 * relevant order, shipment, or fulfillment process can access this list.
 * Related endpoints include the ability to retrieve a single item, add shipment
 * items, update shipment item quantities, or remove shipment items from a
 * batch.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the order containing the shipment.
 * @param props.shipmentId Unique identifier for the shipment whose items are
 *   being listed.
 * @param props.body Advanced filter, pagination, and sorting criteria for
 *   searching shipment items of a shipment.
 * @path /shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items
 * @accessor api.functional.shoppingMall.admin.orders.shipments.items.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the order containing the shipment. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier for the shipment whose items are being listed. */
    shipmentId: string & tags.Format<"uuid">;

    /**
     * Advanced filter, pagination, and sorting criteria for searching
     * shipment items of a shipment.
     */
    body: IShoppingMallShipmentItem.IRequest;
  };
  export type Body = IShoppingMallShipmentItem.IRequest;
  export type Response = IPageIShoppingMallShipmentItem;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/shipments/${encodeURIComponent(props.shipmentId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallShipmentItem =>
    typia.random<IPageIShoppingMallShipmentItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("shipmentId")(() => typia.assert(props.shipmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details for a specific shipment item within an order's
 * shipment. Associated with shopping_mall_shipment_items.
 *
 * This API returns the complete detailed information of a shipment item given
 * its identifier, enforcing that the requested item exists under the specified
 * order and shipment through strict referential checks. Shipment items
 * (shopping_mall_shipment_items) track the number of units shipped for an order
 * item in a specific shipment batch and are critical for batch fulfillment and
 * downstream tracking. This operation supports operational, fulfillment,
 * customer service, and compliance use cases.
 *
 * Permission checks are enforced: only sellers fulfilling the order, associated
 * admins, or order owners can access the full shipment item details. The
 * response structure includes all relevant attributes as described in the
 * Prisma schema: shipped_quantity, references to shipments and order items,
 * audit metadata (created_at/updated_at), etc. Error handling returns clear
 * responses for missing items, misreferenced shipments, or unauthorized
 * access.
 *
 * Commonly paired with the shipment items list endpoint, as well as
 * create/update operations for batch shipment management and fulfillment
 * control.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the related order.
 * @param props.shipmentId Unique identifier for the targeted shipment.
 * @param props.shipmentItemId Unique identifier for the shipment item within
 *   the batch.
 * @path /shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId
 * @accessor api.functional.shoppingMall.admin.orders.shipments.items.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the related order. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier for the targeted shipment. */
    shipmentId: string & tags.Format<"uuid">;

    /** Unique identifier for the shipment item within the batch. */
    shipmentItemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallShipmentItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/shipments/${encodeURIComponent(props.shipmentId ?? "null")}/items/${encodeURIComponent(props.shipmentItemId ?? "null")}`;
  export const random = (): IShoppingMallShipmentItem =>
    typia.random<IShoppingMallShipmentItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("shipmentId")(() => typia.assert(props.shipmentId));
      assert.param("shipmentItemId")(() => typia.assert(props.shipmentItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a shipment item for a specific order and shipment
 * (shopping_mall_shipment_items table).
 *
 * Update a shipment item—a specific item within an order's shipment batch. This
 * enables correcting quantities, handling partial/shipping errors, or
 * administrative adjustments. Shipment items link shipment batches to order
 * items and are fundamental for partial and multi-shipment workflows.
 *
 * This operation requires role-based authorization (seller who owns the
 * shipment's items, or admin). Only items in non-finalized shipments (e.g., not
 * yet fully delivered) are editable; once delivered, shipment items are
 * immutable. All quantity updates are validated against ordered and previously
 * shipped amounts, and negative/inconsistent updates are rejected with a
 * detailed error.
 *
 * Updates are auditable: on each mutation, a snapshot or audit event is
 * recorded, preserving the before/after states. Related APIs include shipment
 * state transitions (e.g., marking as shipped or delivered), and shipment item
 * creation/cancellation (as supported by business rules). Errors are raised for
 * invalid shipment IDs/order IDs or lack of permission.
 *
 * Role checks are enforced at the endpoint level. Sellers may only update
 * shipment items for their own goods and only within allowed states; admins may
 * override. All responses include the updated shipment item state for UI
 * confirmation.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order containing the shipment
 *   and shipment item.
 * @param props.shipmentId Unique identifier of the shipment batch for the
 *   order.
 * @param props.shipmentItemId Unique identifier of the shipment item being
 *   updated within the shipment batch.
 * @param props.body Updated information of the shipment item, such as
 *   shipped_quantity and any allowed editable fields.
 * @path /shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId
 * @accessor api.functional.shoppingMall.admin.orders.shipments.items.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the order containing the shipment and shipment
     * item.
     */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the shipment batch for the order. */
    shipmentId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the shipment item being updated within the
     * shipment batch.
     */
    shipmentItemId: string & tags.Format<"uuid">;

    /**
     * Updated information of the shipment item, such as shipped_quantity
     * and any allowed editable fields.
     */
    body: IShoppingMallShipmentItem.IUpdate;
  };
  export type Body = IShoppingMallShipmentItem.IUpdate;
  export type Response = IShoppingMallShipmentItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/shipments/${encodeURIComponent(props.shipmentId ?? "null")}/items/${encodeURIComponent(props.shipmentItemId ?? "null")}`;
  export const random = (): IShoppingMallShipmentItem =>
    typia.random<IShoppingMallShipmentItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("shipmentId")(() => typia.assert(props.shipmentId));
      assert.param("shipmentItemId")(() => typia.assert(props.shipmentItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (logically delete) a shipment item by orderId, shipmentId, and
 * shipmentItemId (shopping_mall_shipment_items table).
 *
 * Erase a shipment item (row) from a shipment batch within an order. This
 * supports workflows such as cancelling a scheduled shipment item, correcting
 * an incorrectly included item before fulfillment, or handling pre-shipment
 * administrative errors.
 *
 * Only authorized users—sellers responsible for the shipment or system
 * administrators—can perform this action. Logical (soft) deletion is applied by
 * setting the deleted_at field, ensuring traceability and compliance with
 * business/audit requirements. The operation is restricted: only shipment items
 * in shipments that are not yet finalized or shipped can be deleted. Any
 * attempt to "erase" after shipping will cause security and business validation
 * errors.
 *
 * All deletion events are logged for compliance, referencing the snapshot of
 * the shipment item prior to deletion. Related APIs include updating shipment
 * items, shipment batch status transitions, and the parent order management
 * endpoints. Users will receive either a confirmation of successful erasure or
 * an error indicating the operation was not permissible (due to shipment state,
 * insufficient permission, or invalid IDs).
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the related order.
 * @param props.shipmentId Unique identifier of the shipment batch.
 * @param props.shipmentItemId Unique identifier of the shipment item to erase.
 * @path /shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId
 * @accessor api.functional.shoppingMall.admin.orders.shipments.items.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the related order. */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier of the shipment batch. */
    shipmentId: string & tags.Format<"uuid">;

    /** Unique identifier of the shipment item to erase. */
    shipmentItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/orders/:orderId/shipments/:shipmentId/items/:shipmentItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/shipments/${encodeURIComponent(props.shipmentId ?? "null")}/items/${encodeURIComponent(props.shipmentItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("shipmentId")(() => typia.assert(props.shipmentId));
      assert.param("shipmentItemId")(() => typia.assert(props.shipmentItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
