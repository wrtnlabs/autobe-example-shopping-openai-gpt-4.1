import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallOrder } from "../../../../structures/IShoppingMallOrder";
import { IPageIShoppingMallOrder } from "../../../../structures/IPageIShoppingMallOrder";
export * as items from "./items/index";
export * as snapshots from "./snapshots/index";
export * as payments from "./payments/index";
export * as shipments from "./shipments/index";
export * as deliveries from "./deliveries/index";
export * as afterSaleServices from "./afterSaleServices/index";

/**
 * Create a new order based on an application (cart, user input), validating all
 * business rules, and returning the full created order record. Uses
 * shopping_mall_orders.
 *
 * This API operation creates a new order in the business catalog, transforming
 * an application cart or direct input into a live shopping order. The endpoint
 * enforces all validation: product availability checks, inventory application,
 * option/value validation, coupon code/promotion handling, and eligibility
 * (minimum/maximum amounts, currency, etc.). If all checks pass, an order
 * record is created along with order items, snapshot events, and payment
 * initializations.
 *
 * Applicable business rules for stacking/exclusion, segmentation, fulfillment
 * batching, and logistics routing are processed in this operation. The
 * operation is comprehensive: side-effects may include triggering rule engine
 * events, initiating payment and shipment, generating audit trails, and
 * notifying relevant parties. The endpoint is suitable for both authenticated
 * and guest orders as system configuration permits.
 *
 * Authorization covers all customers (or public/guest if permitted) with
 * detailed validation error returns for any business rule failure
 * (out-of-stock, eligibility, price change, etc.). It is idempotent against
 * duplicate cart conversion; duplicate submissions with the same
 * cart/application are handled gracefully with an appropriate error or
 * retrieval of the existing order. Success returns the complete created order
 * and all related sub-entities.
 *
 * @param props.connection
 * @param props.body Order application details: source cart reference,
 *   fulfillment instructions, payment method, options, user data, and any
 *   coupons applied. Must follow IShoppingMallOrder.ICreate structure.
 * @path /shoppingMall/admin/orders
 * @accessor api.functional.shoppingMall.admin.orders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Order application details: source cart reference, fulfillment
     * instructions, payment method, options, user data, and any coupons
     * applied. Must follow IShoppingMallOrder.ICreate structure.
     */
    body: IShoppingMallOrder.ICreate;
  };
  export type Body = IShoppingMallOrder.ICreate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/orders";
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of orders across all states
 * for CRM, analytics, and reporting. Uses shopping_mall_orders.
 *
 * This API operation provides advanced search and pagination over the order
 * database, allowing users to filter by customer, channel, section, status
 * (applied, paid, shipping, delivered, completed, cancelled, etc.), date
 * ranges, amounts, and other key criteria defined in
 * IShoppingMallOrder.IRequest.
 *
 * Each search result returns a summary list or full order details as required,
 * supporting business workflows, customer inquiry handling, fraud analysis, and
 * operational reporting. The endpoint is compatible with CRM dashboards and
 * data export needs, incorporating both user-facing and administrative
 * use-cases. Standard pagination parameters (page, size), multi-level sorting,
 * and advanced filter operators are supported for flexible querying.
 *
 * Authorization is required and enforced by business role and segmentation
 * policy: customers only see their own orders, sellers see their own, and
 * admins have global access. Error scenarios provide actionable messages and
 * support high parallel query loads for analytics.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination criteria for advanced
 *   order retrieval. Supports complex multi-field queries across date, status,
 *   customer, channel, etc.
 * @path /shoppingMall/admin/orders
 * @accessor api.functional.shoppingMall.admin.orders.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filtering, and pagination criteria for advanced order
     * retrieval. Supports complex multi-field queries across date, status,
     * customer, channel, etc.
     */
    body: IShoppingMallOrder.IRequest;
  };
  export type Body = IShoppingMallOrder.IRequest;
  export type Response = IPageIShoppingMallOrder;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/orders";
  export const random = (): IPageIShoppingMallOrder =>
    typia.random<IPageIShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the full details of a single order by its ID, including all items,
 * status, and linked data. Uses shopping_mall_orders.
 *
 * This API operation retrieves a complete view of a business order as
 * identified by the unique order ID (UUID). It returns the main order record
 * along with all major related sub-entities (items, fulfillment status,
 * payment, shipment, audit snapshots, and linked customer/seller).
 *
 * Typical applications include customer order history screens, seller
 * dashboards, after-sales workflow handling, customer service, fraud
 * investigation, and compliance export. The endpoint utilizes strict
 * authorization logic: customers and sellers are segmented by their own
 * records, while admins have full access. Complete error and existence checks
 * are performed, and sensitive data is filtered appropriately per requesting
 * role.
 *
 * The operation allows for extension via includes/expansions where necessary
 * (e.g., related shipment, payment), and is the canonical entrypoint for all
 * business rule engines requiring full order context. Includes full audit
 * coverage of all access attempts and provides granular error messages if order
 * is missing or access is denied.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the order to retrieve (UUID).
 * @path /shoppingMall/admin/orders/:orderId
 * @accessor api.functional.shoppingMall.admin.orders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the order to retrieve (UUID). */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing shopping mall order by ID.
 *
 * This API allows for the update of an order record by order ID. Orders in the
 * shoppingMall system represent the core business transaction structure and
 * include customer linkage, channel/section context, order status, payment
 * details, and audit data. Updates are restricted to appropriate roles and only
 * permitted when the order is not finalized, cancelled, or deleted.
 *
 * The update process must enforce all relevant business logic, such as checking
 * for illegal state transitions (e.g., cannot move from delivered to applied),
 * and prevent updates to orders marked deleted. All modifications will trigger
 * storage of a pre-update snapshot in accordance with compliance requirements,
 * ensuring full traceability for disputes and audit. Attempts to update locked,
 * deleted, or read-only orders will result in clear, actionable error
 * messages.
 *
 * This operation interacts with the shopping_mall_orders table, referencing
 * comments in the schema regarding state transition, multi-seller support, and
 * evidence retention. It is designed to be used by users with order management
 * privileges and returns the updated order record.
 *
 * @param props.connection
 * @param props.orderId Order ID to update. Must be a valid UUID representing an
 *   order in the shopping_mall_orders table.
 * @param props.body Update information for the target shopping mall order.
 * @path /shoppingMall/admin/orders/:orderId
 * @accessor api.functional.shoppingMall.admin.orders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Order ID to update. Must be a valid UUID representing an order in the
     * shopping_mall_orders table.
     */
    orderId: string & tags.Format<"uuid">;

    /** Update information for the target shopping mall order. */
    body: IShoppingMallOrder.IUpdate;
  };
  export type Body = IShoppingMallOrder.IUpdate;
  export type Response = IShoppingMallOrder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallOrder =>
    typia.random<IShoppingMallOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an existing shopping mall order by order ID.
 *
 * This API marks an order as deleted, enabling soft-delete functionality as
 * required for compliance and audit. Instead of removing the order data, the
 * system sets the deleted_at timestamp, ensuring the record remains accessible
 * for regulatory recovery and historical analysis.
 *
 * Deletion is only allowed when the order is in a deletable state as per
 * business rules — for example, not finalized, not associated with ongoing
 * shipments, or after permitted cancellation windows. Upon invocation, a
 * snapshot of the order will be saved for evidence, and deletion actions will
 * be logged in the audit trail.
 *
 * Attempts to delete orders in restricted or non-deletable states will result
 * in clear error messages. The endpoint enforces robust permission and status
 * logic based on schema comments for status and deletion fields.
 *
 * @param props.connection
 * @param props.orderId Order ID to soft delete. Must be a valid UUID of an
 *   existing order in shopping_mall_orders.
 * @path /shoppingMall/admin/orders/:orderId
 * @accessor api.functional.shoppingMall.admin.orders.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Order ID to soft delete. Must be a valid UUID of an existing order in
     * shopping_mall_orders.
     */
    orderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
