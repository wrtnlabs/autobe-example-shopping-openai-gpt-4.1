import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProduct } from "../../../../structures/IShoppingMallProduct";
export * as options from "./options/index";
export * as variants from "./variants/index";
export * as bundles from "./bundles/index";
export * as tags from "./tags/index";
export * as seo from "./seo/index";
export * as content from "./content/index";
export * as attachments from "./attachments/index";
export * as inquiries from "./inquiries/index";

/**
 * Register a new product to the shopping mall catalog.
 * (shopping_mall_products).
 *
 * Create a new product entry in the shopping mall catalog by providing all
 * required business fields including seller, channel, section, category, code,
 * name, status, and business workflow state. Validates the payload against
 * business constraints (uniqueness, completeness, status rules) and sets up
 * initial state for product lifecycle management.
 *
 * Additional content, options, variants, bundles, tagging, and attachments can
 * be specified in compliant structures, ensuring modular expansion and rich
 * catalog presentation. Automatically creates a product snapshot for evidence
 * and audit at creation. Only authorized roles (seller for their
 * section/channel, admin for global scopes) may invoke this operation;
 * customers cannot register products. Comprehensive error handling for
 * validation failures, permission denials, or business rule violations aligns
 * with shopping_mall_products Prisma schema and associated relationships.
 *
 * Returns the full detail of the created product, suitable for immediate use in
 * listing, editing, or management workflows.
 *
 * @param props.connection
 * @param props.body All primary and supplementary information for registering
 *   the new product, including seller, catalog scope, product data, and
 *   attachment references.
 * @path /shoppingMall/admin/products
 * @accessor api.functional.shoppingMall.admin.products.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * All primary and supplementary information for registering the new
     * product, including seller, catalog scope, product data, and
     * attachment references.
     */
    body: IShoppingMallProduct.ICreate;
  };
  export type Body = IShoppingMallProduct.ICreate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/products";
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update information for an existing product by productId.
 * (shopping_mall_products).
 *
 * Update the attributes of an existing product specified by productId, with
 * changeable fields including core attributes (code, name, status, category,
 * section, etc.) and related catalog relationships. Supports business workflow
 * controls for pausing, activating, discontinuing, or modifying eligibility for
 * display/order. Permissions restrict seller updates to their own
 * products/sections, while admins have global update access. Validation ensures
 * compliance with workflow rules, uniqueness, and completeness, performing all
 * error handling on rejection or rule violation.
 *
 * Automatically generates a product snapshot for evidence, versioning, and
 * compliance needs. Integration of content, variant, bundle, and tag changes
 * are governed by sub-schemas and can be included in update input. Returns the
 * updated product object reflecting all changes. Strictly aligned with the
 * field and relationship definitions in shopping_mall_products Prisma schema,
 * with robust audit trail and error explanations as needed.
 *
 * Non-authorized or invalid updates (e.g., for deleted, expired, or restricted
 * products) are rejected with clear exception messages.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to update in the
 *   catalog.
 * @param props.body Fields to update for the product identified by productId,
 *   with structures matching updatable business data per product schema.
 * @path /shoppingMall/admin/products/:productId
 * @accessor api.functional.shoppingMall.admin.products.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the product to update in the catalog. */
    productId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the product identified by productId, with
     * structures matching updatable business data per product schema.
     */
    body: IShoppingMallProduct.IUpdate;
  };
  export type Body = IShoppingMallProduct.IUpdate;
  export type Response = IShoppingMallProduct;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMall/admin/products/:productId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallProduct =>
    typia.random<IShoppingMallProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a product identified by productId (shopping_mall_products table).
 *
 * Allows an authorized seller or admin to remove a product from active listings
 * without permanently erasing the record, complying with audit and evidence
 * policies. Soft deletion is achieved by updating the 'deleted_at' field,
 * preserving product data, options, variants, and all historical snapshots.
 * This approach supports regulatory requirements and dispute resolution by
 * retaining all product-related evidence and relationships.
 *
 * Role-based authorization ensures that only the product owner (seller) or an
 * administrator can delete a product. Attempts by unauthorized users will be
 * rejected with a clear, actionable error. The operation also checks that the
 * product is not part of active orders or reserved inventoryâ€”if it is, deletion
 * will be blocked and a descriptive business error is returned. Related
 * snapshots in shopping_mall_product_snapshots ensure the deleted state is
 * fully traceable.
 *
 * This API should be paired with product listing and recovery endpoints to
 * enable batch operations or accidental deletion recovery, and must log all
 * delete attempts in system audit trails for compliance. If a product is
 * already soft-deleted or does not exist, an error will be returned indicating
 * its status.
 *
 * @param props.connection
 * @param props.productId UUID identifier of the product to remove.
 * @path /shoppingMall/admin/products/:productId
 * @accessor api.functional.shoppingMall.admin.products.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID identifier of the product to remove. */
    productId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
