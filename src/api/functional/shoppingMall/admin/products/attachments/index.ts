import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallProductAttachmentLink } from "../../../../../structures/IShoppingMallProductAttachmentLink";
import { IPageIShoppingMallProductAttachmentLink } from "../../../../../structures/IPageIShoppingMallProductAttachmentLink";

/**
 * Add a new attachment link (image, gallery, or file) to a shoppingMall product
 * by productId.
 *
 * Create a new association between an existing file attachment and a product.
 * The endpoint requires the caller to specify the productId, attachmentId,
 * usage context (purpose), and position/order. The underlying Prisma schema
 * ensures referential integrity to both product and attachment and enforces
 * uniqueness for each attachment-per-purpose combination.
 *
 * Permission logic ensures that only the product's seller or administrators may
 * add attachment links to a product. The request body is validated against the
 * IShoppingMallProductAttachmentLink.ICreate DTO, including checks that the
 * product exists, the attachment is valid, and that no conflicting links for
 * the same purpose exist for the target product. Upon success, the response
 * contains the newly created attachment link metadata, referencing both the
 * product and the attachment details.
 *
 * If any referenced entity does not exist, or permission is insufficient, a
 * comprehensive error message is returned. This does NOT upload the file
 * itself; it only establishes linkage between product and an already registered
 * attachment file.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to which the
 *   attachment will be linked.
 * @param props.body Attachment link creation data for associating existing
 *   attachments to a product as gallery, spec sheet, etc.
 * @path /shoppingMall/admin/products/:productId/attachments
 * @accessor api.functional.shoppingMall.admin.products.attachments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier for the product to which the attachment will be
     * linked.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Attachment link creation data for associating existing attachments to
     * a product as gallery, spec sheet, etc.
     */
    body: IShoppingMallProductAttachmentLink.ICreate;
  };
  export type Body = IShoppingMallProductAttachmentLink.ICreate;
  export type Response = IShoppingMallProductAttachmentLink;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMall/admin/products/:productId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/attachments`;
  export const random = (): IShoppingMallProductAttachmentLink =>
    typia.random<IShoppingMallProductAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List file attachment links for a shoppingMall product by productId with
 * pagination and search.
 *
 * Returns a structured list of all file attachment links belonging to a product
 * identified by productId. This endpoint allows querying, searching by usage
 * context (purpose), sorting (e.g., by display order or created_at), and
 * supporting pagination parameters (such as page size, offset). Returned data
 * includes all relevant attachment metadata, position/order for gallery usage,
 * and URI for secure access.
 *
 * Security checks restrict access to attachments on unpublished or restricted
 * products—authorization roles (seller/admin) are validated against the
 * product's seller ownership or platform administration. Read-only
 * operation—does not allow modification or upload of new files.
 *
 * The results conform to the IPageIShoppingMallProductAttachmentLink summary
 * DTO, ensuring compatibility with standardized response containers. Error
 * responses are returned when the product is not found, access is denied, or
 * query parameters are invalid.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose attachments are
 *   to be listed.
 * @param props.body Query and pagination options for listing product
 *   attachments (filter by purpose, pagination, sort, etc.).
 * @path /shoppingMall/admin/products/:productId/attachments
 * @accessor api.functional.shoppingMall.admin.products.attachments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the product whose attachments are to be listed. */
    productId: string & tags.Format<"uuid">;

    /**
     * Query and pagination options for listing product attachments (filter
     * by purpose, pagination, sort, etc.).
     */
    body: IShoppingMallProductAttachmentLink.IRequest;
  };
  export type Body = IShoppingMallProductAttachmentLink.IRequest;
  export type Response = IPageIShoppingMallProductAttachmentLink.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/products/:productId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/attachments`;
  export const random = (): IPageIShoppingMallProductAttachmentLink.ISummary =>
    typia.random<IPageIShoppingMallProductAttachmentLink.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get metadata for a specific product attachment link for a shoppingMall
 * product by productId and attachmentLinkId.
 *
 * Retrieve the detailed metadata for a specific product attachment link,
 * including file purpose (e.g., main_image, gallery), order, relation to the
 * product, and secure file reference. This endpoint enforces permission checks,
 * allowing only the product's seller or administrators to access this
 * information. The Prisma schema ensures that each attachment link record is
 * associated with a product and contains metadata for the file, including
 * reference to the underlying attachment.
 *
 * Security checks confirm the existence of both the product and attachment
 * link, enforcing error returns for unauthorized access, non-existent IDs, or
 * attempts to access attachments on deleted/discontinued products. Related
 * endpoints allow batch listing or modification of attachment links per
 * product. No file content is returned—this endpoint is purely for metadata and
 * linkage info.
 *
 * If the specified attachment link does not exist, an appropriate error message
 * and code are returned. Use this operation to display detailed info in
 * admin/product management screens or prepare for file delete/update actions.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product whose attachment is
 *   being accessed.
 * @param props.attachmentLinkId Unique identifier of the attachment link to
 *   retrieve.
 * @path /shoppingMall/admin/products/:productId/attachments/:attachmentLinkId
 * @accessor api.functional.shoppingMall.admin.products.attachments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product whose attachment is being accessed. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the attachment link to retrieve. */
    attachmentLinkId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallProductAttachmentLink;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/products/:productId/attachments/:attachmentLinkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/attachments/${encodeURIComponent(props.attachmentLinkId ?? "null")}`;
  export const random = (): IShoppingMallProductAttachmentLink =>
    typia.random<IShoppingMallProductAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("attachmentLinkId")(() =>
        typia.assert(props.attachmentLinkId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific product-attachment link for a product
 * (shopping_mall_product_attachment_links table).
 *
 * This endpoint provides the ability to sever the association between a
 * specific product and an attachment by deleting a row from the
 * shopping_mall_product_attachment_links table. Consistent with business rules,
 * this deletion is limited to authorized actors: product owners (sellers) of
 * the relevant product or administrators with suitable privileges.
 *
 * Security and audit are critical: each action is logged for compliance, and
 * attempts by unauthorized actors are denied with actionable error messages.
 * The operation does not affect the underlying attachment file, nor does it
 * alter or remove the product entity—only the join link between them is
 * targeted. Requests must supply both a valid productId and an attachmentLinkId
 * as path parameters, both in UUID format.
 *
 * There is no soft-delete for links in the schema, so this operation performs a
 * permanent removal. Since the action potentially affects evidence
 * preservation, downstream Audit and Snapshot workflows must be considered for
 * compliance. Related operations include adding new product/attachment links or
 * listing current attachments for a product, which allow users to manage media
 * associations effectively. In case of database integrity or constraint errors,
 * appropriate error messages are surfaced, and no partial deletions are
 * performed.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product from which to remove
 *   the attachment link.
 * @param props.attachmentLinkId Unique identifier of the attachment link to be
 *   deleted.
 * @path /shoppingMall/admin/products/:productId/attachments/:attachmentLinkId
 * @accessor api.functional.shoppingMall.admin.products.attachments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the product from which to remove the attachment
     * link.
     */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the attachment link to be deleted. */
    attachmentLinkId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMall/admin/products/:productId/attachments/:attachmentLinkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/products/${encodeURIComponent(props.productId ?? "null")}/attachments/${encodeURIComponent(props.attachmentLinkId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("attachmentLinkId")(() =>
        typia.assert(props.attachmentLinkId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
