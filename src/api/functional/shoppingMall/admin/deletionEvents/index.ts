import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallDeletionEvent } from "../../../../structures/IShoppingMallDeletionEvent";
import { IPageIShoppingMallDeletionEvent } from "../../../../structures/IPageIShoppingMallDeletionEvent";

/**
 * Search and retrieve a filtered, paginated list of entity deletion events
 * (shopping_mall_deletion_events) for compliance and audit.
 *
 * Retrieve a filtered and paginated list of deletion events from the shopping
 * mall's system-wide audit trail. This operation allows administrators to query
 * logical deletions across all managed business entities, supporting advanced
 * search criteria such as entity type (e.g., product, order, review), deletion
 * reason, deleted_by_id, date ranges, and linkage to entity snapshots.
 *
 * The operation returns results in a paginated format, including relevant
 * metadata and references to snapshots for evidence or rollback scenarios. It
 * is intended for use by compliance and audit personnel to ensure data removal
 * actions are legitimate and traceable according to legal and business
 * policies.
 *
 * Security considerations require that this operation is restricted to
 * administrators with proper audit or data governance roles, preventing
 * unauthorized access to sensitive deletion records. Rate limiting, data
 * masking (where necessary for privacy), and full query audit logging are
 * recommended when implementing this API.
 *
 * This endpoint is directly backed by the shopping_mall_deletion_events Prisma
 * schema table, capturing all key fields for traceability, including
 * entity_type, entity_id, deleted_by_id, deletion_reason, snapshot_id, and
 * timestamps. The response structure mirrors the compliance and governance
 * needs defined in requirements, enabling legal export and robust analysis.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination criteria for deletion event
 *   retrieval.
 * @path /shoppingMall/admin/deletionEvents
 * @accessor api.functional.shoppingMall.admin.deletionEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination criteria for deletion event retrieval. */
    body: IShoppingMallDeletionEvent.IRequest;
  };
  export type Body = IShoppingMallDeletionEvent.IRequest;
  export type Response = IPageIShoppingMallDeletionEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMall/admin/deletionEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMall/admin/deletionEvents";
  export const random = (): IPageIShoppingMallDeletionEvent =>
    typia.random<IPageIShoppingMallDeletionEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific deletion event
 * (shopping_mall_deletion_events) for audit and compliance review.
 *
 * Returns the full details of a single deletion event from the shopping mall's
 * data deletion audit log, based on the unique deletionEventId. This operation
 * is used by compliance, audit, or admin personnel to investigate entity
 * removals, including the type of entity affected, deleted_by_id (actor),
 * deletion_reason, and any related snapshot evidence.
 *
 * The operation strictly enforces admin-level access and is logged for
 * compliance traceability. Sensitive data may be masked if entity_type warrants
 * additional privacy measures (e.g., user accounts).
 *
 * This API is critical for fulfilling regulatory requirements and enabling
 * legal or governance queries about all logical removals. It is directly based
 * on the shopping_mall_deletion_events table schema with all corresponding
 * fields and relationships, providing an immutable record for system-integrity
 * and audit workflows.
 *
 * @param props.connection
 * @param props.deletionEventId Unique identifier of the target deletion event
 *   to be retrieved for audit or compliance review.
 * @path /shoppingMall/admin/deletionEvents/:deletionEventId
 * @accessor api.functional.shoppingMall.admin.deletionEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the target deletion event to be retrieved for
     * audit or compliance review.
     */
    deletionEventId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallDeletionEvent;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMall/admin/deletionEvents/:deletionEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMall/admin/deletionEvents/${encodeURIComponent(props.deletionEventId ?? "null")}`;
  export const random = (): IShoppingMallDeletionEvent =>
    typia.random<IShoppingMallDeletionEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("deletionEventId")(() =>
        typia.assert(props.deletionEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
