import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFraudCheck } from "../../structures/IFraudCheck";
import { IPageIFraudCheck } from "../../structures/IPageIFraudCheck";

/**
 * Create new fraud check record (table: fraud_check).
 *
 * A backend, compliance system, or AI microservice uses this API to log a new
 * fraud check event. The client must provide user, target entity, target type,
 * AI provider, risk score, explanation text, and timestamp. The endpoint
 * enforces integrity (referenced user and AI provider exist), privilege checks,
 * and audit-logs the request. Typical use: during checkout/transaction, the
 * engine validates and returns the fraud check. Returns the created record with
 * all fields. Fails on missing/invalid references or permissions. Used for
 * compliance, security analytics, and continuous improvement auditing.
 *
 * @param props.body Fraud check event creation details.
 * @path /fraudCheck
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Fraud check event creation details. */
    body: IFraudCheck.ICreate;
  };
  export type Body = IFraudCheck.ICreate;
  export type Response = IFraudCheck;

  export const METADATA = {
    method: "POST",
    path: "/fraudCheck",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/fraudCheck";
  export const random = (g?: Partial<typia.IRandomGenerator>): IFraudCheck =>
    typia.random<IFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search fraud checks with advanced filters/pagination (table:
 * fraud_check).
 *
 * Returns a paginated and optionally filtered set of fraud check records from
 * the 'fraud_check' table. Filtering can be on user, target_type, target_id, AI
 * provider, risk_score, etc. Pagination and sorting supported for large result
 * sets. Only users with explicit privileges (admin, auditor, compliance
 * manager) can access this endpoint. Results include full metadata and
 * explainability strings. Used for compliance auditing, model quality review,
 * or real-time fraud monitoring dashboards.
 *
 * @param props.body Filter, sorting, and pagination inputs for fraud check
 *   listing.
 * @path /fraudCheck
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter, sorting, and pagination inputs for fraud check listing. */
    body: IFraudCheck.IRequest;
  };
  export type Body = IFraudCheck.IRequest;
  export type Response = IPageIFraudCheck;

  export const METADATA = {
    method: "PATCH",
    path: "/fraudCheck",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/fraudCheck";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIFraudCheck => typia.random<IPageIFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch fraud check record by ID (table: fraud_check).
 *
 * Fetches a single fraud check record by its unique ID. Only privileged users,
 * model owners, or compliance staff have access. Returns the full fraud check
 * including model/output details, user and entity references, scores, and audit
 * metadata. If not found or not allowed, returns an error. Used in fraud
 * compliance dashboards, explainability panels, or for customer service
 * auditing.
 *
 * @param props.id Target fraud check record's ID.
 * @path /fraudCheck/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target fraud check record's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IFraudCheck;

  export const METADATA = {
    method: "GET",
    path: "/fraudCheck/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/fraudCheck/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IFraudCheck =>
    typia.random<IFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update fraud check explanation/metadata by ID (table: fraud_check).
 *
 * Updates mutable fields (explanation/metadata) of a fraud check record
 * identified by its ID. The endpoint ensures existence and RBAC, permits only
 * annotated field updates, not core business data. Changes are always
 * audit-logged. Used to add explainability, correct annotations, or update
 * metadata post-inference. Errors for forbidden/invalid/missing records. Used
 * by compliance or ML ops dashboards.
 *
 * @param props.id Target fraud check record's ID.
 * @param props.body Updated fraud check explanation/metadata.
 * @path /fraudCheck/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target fraud check record's ID. */
    id: string & tags.Format<"uuid">;

    /** Updated fraud check explanation/metadata. */
    body: IFraudCheck.IUpdate;
  };
  export type Body = IFraudCheck.IUpdate;
  export type Response = IFraudCheck;

  export const METADATA = {
    method: "PUT",
    path: "/fraudCheck/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/fraudCheck/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IFraudCheck =>
    typia.random<IFraudCheck>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-deletes a fraud_check record by ID (AnalyticsAI.fraud_check table).
 *
 * This operation enables system or compliance administrators to delete a
 * fraud_check record, representing an AI/ML-powered transactional risk
 * assessment. Deletion here refers to soft-deletion (setting a deleted_at
 * timestamp) and is mandatory to comply with regulatory requirements for data
 * traceability and non-destructive audit trails, as described in section 9 of
 * the requirements.
 *
 * Fraud checks are crucial for monitoring order, cart, or refund activity and
 * are referenced by coupon_redemptions, payments, and order logs for auditing
 * and explainable outcomes. This endpoint must enforce RBAC so only actors with
 * required permission levels can delete records, and all deletion actions are
 * stored in the audit log for security and compliance.
 *
 * Edge cases, such as the attempted deletion of an already-deleted
 * (soft-deleted) or non-existent record, must return detailed error messages
 * and should not trigger cascading deletes to related records. API consumers
 * should handle these gracefully. This API follows strict immutability for
 * analytics and legal complianceâ€”records are never physically erased.
 *
 * Dependency: Only system administrators or compliance roles should be granted
 * this operation. Use together with /fraudCheck (GET, PATCH, POST, PUT) for
 * full fraud check management.
 *
 * @param props.id Target fraud check's ID to delete (UUID).
 * @path /fraudCheck/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target fraud check's ID to delete (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/fraudCheck/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/fraudCheck/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
