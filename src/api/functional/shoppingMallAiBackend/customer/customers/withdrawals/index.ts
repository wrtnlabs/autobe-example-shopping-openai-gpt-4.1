import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCustomerWithdrawal } from "../../../../../structures/IShoppingMallAiBackendCustomerWithdrawal";
import { IPageIShoppingMallAiBackendCustomerWithdrawal } from "../../../../../structures/IPageIShoppingMallAiBackendCustomerWithdrawal";

/**
 * Retrieve paginated withdrawal history for a customer account.
 *
 * This API lists all withdrawal snapshots (account deactivations or removals)
 * performed on a user account, with full audit evidence (reason, withdrawn_at,
 * created_at). Useful for reviewing past deactivation events, onboarding
 * audits, or regulatory requests. The user (or admin) may filter by dates,
 * reason, or other criteria provided by
 * IShoppingMallAiBackendCustomerWithdrawal.IRequest.
 *
 * Typical use includes customer self-review, admin compliance checks, or
 * processing data export/archival requests after withdrawal. All records are
 * returned in chronological order and paginated for large event history.
 *
 * @param props.connection
 * @param props.customerId Unique identifier (UUID) of the customer whose
 *   withdrawal records are being retrieved.
 * @param props.body Filter criteria and pagination info for withdrawal history
 *   search.
 * @path /shoppingMallAiBackend/customer/customers/:customerId/withdrawals
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier (UUID) of the customer whose withdrawal records are
     * being retrieved.
     */
    customerId: string & tags.Format<"uuid">;

    /** Filter criteria and pagination info for withdrawal history search. */
    body: IShoppingMallAiBackendCustomerWithdrawal.IRequest;
  };
  export type Body = IShoppingMallAiBackendCustomerWithdrawal.IRequest;
  export type Response = IPageIShoppingMallAiBackendCustomerWithdrawal.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/customers/:customerId/withdrawals",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/withdrawals`;
  export const random =
    (): IPageIShoppingMallAiBackendCustomerWithdrawal.ISummary =>
      typia.random<IPageIShoppingMallAiBackendCustomerWithdrawal.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific customer withdrawal record for audit or
 * evidence.
 *
 * This operation retrieves all evidence and detail for a single customer
 * withdrawal (account deactivation) event. Auditable details include the
 * business reason, withdrawal date, and evidence timestamp. It is typically
 * called by the customer reviewing their own history or an admin for compliance
 * reporting. Both the customerId and withdrawalId are required as UUIDs.
 * Attempts to access withdrawals not owned by the customer are forbidden.
 *
 * This API supports regulatory audit operations, evidence review, and customer
 * post-withdrawal requests. Actions are logged for compliance.
 *
 * @param props.connection
 * @param props.customerId Unique identifier (UUID) of the customer whose
 *   withdrawal record is being retrieved.
 * @param props.withdrawalId Unique identifier (UUID) of the specific withdrawal
 *   record.
 * @path /shoppingMallAiBackend/customer/customers/:customerId/withdrawals/:withdrawalId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) of the customer whose withdrawal record is
     * being retrieved.
     */
    customerId: string & tags.Format<"uuid">;

    /** Unique identifier (UUID) of the specific withdrawal record. */
    withdrawalId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCustomerWithdrawal;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/customers/:customerId/withdrawals/:withdrawalId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/customers/${encodeURIComponent(props.customerId ?? "null")}/withdrawals/${encodeURIComponent(props.withdrawalId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCustomerWithdrawal =>
    typia.random<IShoppingMallAiBackendCustomerWithdrawal>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.param("withdrawalId")(() => typia.assert(props.withdrawalId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
