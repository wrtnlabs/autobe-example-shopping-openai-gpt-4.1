import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendDepositTransaction } from "../../../../../structures/IShoppingMallAiBackendDepositTransaction";
import { IPageIShoppingMallAiBackendDepositTransaction } from "../../../../../structures/IPageIShoppingMallAiBackendDepositTransaction";

/**
 * List all transactions for a deposit ledger (with filters and pagination).
 *
 * Retrieve an audit trail and full transaction history for a given deposit
 * ledger. This operation provides administrators, deposit holders (customers or
 * sellers) with searchable and paginated access to all events affecting a
 * deposit's balance, including accruals, usage, withdrawals, incidents, and
 * manual adjustments.
 *
 * Resulting data allows users to monitor account activity, confirm business
 * events, or investigate anomalies. The returned list is filtered to include
 * only transactions for which the requester has legitimate access rights per
 * platform policy.
 *
 * Detailed business context—such as change types, amounts, references, and
 * balance before/after—are included. This enables customers, sellers, and staff
 * to ensure ledger consistency, perform monthly reconciliation, and address
 * audit/compliance needs. Authorization checks must validate the user's right
 * to view this deposit's transaction log. Expected errors include not found,
 * forbidden, or unauthorized access for invalid depositId or mismatched roles.
 *
 * @param props.connection
 * @param props.depositId UUID of the deposit ledger to query
 * @param props.body Request body containing filtering, sorting, and pagination
 *   parameters for the deposit transaction log.
 * @path /shoppingMallAiBackend/customer/deposits/:depositId/transactions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the deposit ledger to query */
    depositId: string & tags.Format<"uuid">;

    /**
     * Request body containing filtering, sorting, and pagination parameters
     * for the deposit transaction log.
     */
    body: IShoppingMallAiBackendDepositTransaction.IRequest;
  };
  export type Body = IShoppingMallAiBackendDepositTransaction.IRequest;
  export type Response = IPageIShoppingMallAiBackendDepositTransaction.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/deposits/:depositId/transactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/deposits/${encodeURIComponent(props.depositId ?? "null")}/transactions`;
  export const random =
    (): IPageIShoppingMallAiBackendDepositTransaction.ISummary =>
      typia.random<IPageIShoppingMallAiBackendDepositTransaction.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("depositId")(() => typia.assert(props.depositId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific deposit transaction's detailed audit information.
 *
 * Fetch detailed data for a specific deposit transaction event referenced by
 * its unique transactionId. Provides fields such as change type, amount,
 * balance before and after, audit references, manual/admin reason codes, and
 * timestamps.
 *
 * This endpoint supports both account holders (customer/seller) and authorized
 * administrators in investigating deposit ledger history, responding to
 * disputes, or confirming compliance events. Sensitive data access is governed
 * by strict authorization logic; non-owners or unauthorized requests are
 * forbidden. Expected errors: not found, unauthorized, or forbidden if
 * transaction does not belong to depositId or viewing rights are missing.
 *
 * @param props.connection
 * @param props.depositId UUID of the deposit ledger to which this transaction
 *   belongs
 * @param props.transactionId UUID of the specific transaction record to fetch
 * @path /shoppingMallAiBackend/customer/deposits/:depositId/transactions/:transactionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the deposit ledger to which this transaction belongs */
    depositId: string & tags.Format<"uuid">;

    /** UUID of the specific transaction record to fetch */
    transactionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendDepositTransaction;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/deposits/:depositId/transactions/:transactionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/deposits/${encodeURIComponent(props.depositId ?? "null")}/transactions/${encodeURIComponent(props.transactionId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendDepositTransaction =>
    typia.random<IShoppingMallAiBackendDepositTransaction>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("depositId")(() => typia.assert(props.depositId));
      assert.param("transactionId")(() => typia.assert(props.transactionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
