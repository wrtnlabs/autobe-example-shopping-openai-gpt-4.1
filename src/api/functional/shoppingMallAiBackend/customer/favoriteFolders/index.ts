import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendFavoriteFolder } from "../../../../structures/IShoppingMallAiBackendFavoriteFolder";
import { IPageIShoppingMallAiBackendFavoriteFolder } from "../../../../structures/IPageIShoppingMallAiBackendFavoriteFolder";

/**
 * Create a customer-defined favorite folder/group for improved content
 * organization.
 *
 * Creates a new customer-defined favorite folder for organizing favorite
 * products, addresses, inquiries, or other types of bookmarks. The business
 * logic supports folder naming, optional description, and initializes ownership
 * evidence/audit trail with customer reference and timestamps.
 *
 * The operation is restricted to authenticated customers, ensuring that every
 * folder is uniquely named per customer (no duplicates). Used in content
 * management dashboards, notification configuration, and UX customization. On
 * success, returns the created favorite folder's metadata and configuration for
 * immediate use by client UIs or notification services.
 *
 * @param props.connection
 * @param props.body Properties for the new favorite folder (e.g., name,
 *   optional description).
 * @path /shoppingMallAiBackend/customer/favoriteFolders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createFavoriteFolder(
  connection: IConnection,
  props: createFavoriteFolder.Props,
): Promise<createFavoriteFolder.Response> {
  return true === connection.simulate
    ? createFavoriteFolder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createFavoriteFolder.METADATA,
          path: createFavoriteFolder.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createFavoriteFolder {
  export type Props = {
    /**
     * Properties for the new favorite folder (e.g., name, optional
     * description).
     */
    body: IShoppingMallAiBackendFavoriteFolder.ICreate;
  };
  export type Body = IShoppingMallAiBackendFavoriteFolder.ICreate;
  export type Response = IShoppingMallAiBackendFavoriteFolder;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/favoriteFolders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/favoriteFolders";
  export const random = (): IShoppingMallAiBackendFavoriteFolder =>
    typia.random<IShoppingMallAiBackendFavoriteFolder>();
  export const simulate = (
    connection: IConnection,
    props: createFavoriteFolder.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createFavoriteFolder.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve paginated/searchable list of a customer's favorite folders.
 *
 * Enables customers to retrieve a paginated, filtered list of all favorite
 * folders currently associated with their account. This supports
 * folder/grouping UI, improved notification management, and better organization
 * of bookmarks (products, addresses, inquiries, etc).
 *
 * The underlying model is 'shopping_mall_ai_backend_favorite_folders', which
 * stores folder names, descriptions, and grouping metadata. Security ensures
 * only the owner may view their own folders, with business logic for evidence,
 * audit, and UI integration. Pagination and filter options allow for custom
 * folder searches, such as by partial name, creation date, or custom tags.
 *
 * The response provides a list of folder summaries with essential properties,
 * supporting folder selection UIs and notification setup workflows for
 * personalized content.
 *
 * @param props.connection
 * @param props.body Folder search, filtering, and pagination parameters for
 *   folder listing queries.
 * @path /shoppingMallAiBackend/customer/favoriteFolders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexFavoriteFolders(
  connection: IConnection,
  props: indexFavoriteFolders.Props,
): Promise<indexFavoriteFolders.Response> {
  return true === connection.simulate
    ? indexFavoriteFolders.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexFavoriteFolders.METADATA,
          path: indexFavoriteFolders.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexFavoriteFolders {
  export type Props = {
    /**
     * Folder search, filtering, and pagination parameters for folder
     * listing queries.
     */
    body: IShoppingMallAiBackendFavoriteFolder.IRequest;
  };
  export type Body = IShoppingMallAiBackendFavoriteFolder.IRequest;
  export type Response = IPageIShoppingMallAiBackendFavoriteFolder.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/favoriteFolders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/favoriteFolders";
  export const random =
    (): IPageIShoppingMallAiBackendFavoriteFolder.ISummary =>
      typia.random<IPageIShoppingMallAiBackendFavoriteFolder.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexFavoriteFolders.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexFavoriteFolders.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get properties/metadata for a specific favorite folder owned by the customer.
 *
 * Fetches metadata and configuration details for a specific favorite folder
 * using its unique folder ID. Returns summary information such as name,
 * description, associated customer, creation/update times, and deletion status
 * (for evidence/audit). Only the folder's owner may retrieve its details;
 * security and evidence logic are enforced for compliance.
 *
 * Used by UIs for folder editing, notification channel management, and
 * organizing grouped favorites such as products, addresses, or inquiries.
 * Folders are central to personalized content and notification management
 * flows, supporting higher engagement and content discoverability.
 *
 * @param props.connection
 * @param props.favoriteFolderId The unique identifier of the favorite folder to
 *   retrieve.
 * @path /shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atFavoriteFolder(
  connection: IConnection,
  props: atFavoriteFolder.Props,
): Promise<atFavoriteFolder.Response> {
  return true === connection.simulate
    ? atFavoriteFolder.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atFavoriteFolder.METADATA,
          path: atFavoriteFolder.path(props),
          status: null,
        },
      );
}
export namespace atFavoriteFolder {
  export type Props = {
    /** The unique identifier of the favorite folder to retrieve. */
    favoriteFolderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendFavoriteFolder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favoriteFolders/${encodeURIComponent(props.favoriteFolderId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavoriteFolder =>
    typia.random<IShoppingMallAiBackendFavoriteFolder>();
  export const simulate = (
    connection: IConnection,
    props: atFavoriteFolder.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atFavoriteFolder.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteFolderId")(() =>
        typia.assert(props.favoriteFolderId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a customer's favorite folder for personalized organization needs.
 *
 * This API endpoint allows an authenticated customer to update the name or
 * description of a specific favorite folder they own. The operation verifies
 * folder existence, customer ownership, and ensures that folder names remain
 * unique per customer. If unauthorized or attempting to update a deleted
 * folder, a descriptive error is returned.
 *
 * Updating a favorite folder improves user experience by allowing better
 * organization and group-based notification for favorites. The system tracks
 * update timestamps, and changes are included in the business evidence trail.
 * This endpoint is not available to other customers or administrators unless
 * acting on behalf of the owner in exceptional cases.
 *
 * Folder updates are used primarily by customers who wish to rename, clarify,
 * or reorganize their collection folders for favorites. The API will validate
 * that the new folder name, if changed, does not conflict with another folder
 * under the same customer. Attempts to update non-owned folder IDs are denied.
 *
 * @param props.connection
 * @param props.favoriteFolderId The unique identifier of the favorite folder to
 *   update
 * @param props.body Data to update for the favorite folder, including the new
 *   name or description
 * @path /shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the favorite folder to update */
    favoriteFolderId: string & tags.Format<"uuid">;

    /**
     * Data to update for the favorite folder, including the new name or
     * description
     */
    body: IShoppingMallAiBackendFavoriteFolder.IUpdate;
  };
  export type Body = IShoppingMallAiBackendFavoriteFolder.IUpdate;
  export type Response = IShoppingMallAiBackendFavoriteFolder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/favoriteFolders/${encodeURIComponent(props.favoriteFolderId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavoriteFolder =>
    typia.random<IShoppingMallAiBackendFavoriteFolder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteFolderId")(() =>
        typia.assert(props.favoriteFolderId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (logical removal) of a customer's favorite folder by marking
 * deleted_at.
 *
 * This API enables an authenticated customer to logically delete their own
 * favorite folder, facilitating personalized organization without actual data
 * removal. It sets the deleted_at timestamp as evidence for audit and
 * compliance. The endpoint ensures that only folders owned by the customer and
 * not already deleted can be targeted. Linked favorites will remain accessible,
 * preserving evidence and notification history. This operation supports
 * recoverability for compliance but prevents further use for organization or
 * grouping.
 *
 * Soft deletion is critical for user-centric data retention and audit trails.
 * The system will block operations if the folder does not belong to the
 * requester or is already deleted, preventing unauthorized access. All such
 * actions are logged for future review.
 *
 * @param props.connection
 * @param props.favoriteFolderId The unique identifier of the favorite folder to
 *   delete
 * @path /shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the favorite folder to delete */
    favoriteFolderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/favoriteFolders/:favoriteFolderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favoriteFolders/${encodeURIComponent(props.favoriteFolderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteFolderId")(() =>
        typia.assert(props.favoriteFolderId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
