import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendFavoriteInquiry } from "../../../../../structures/IShoppingMallAiBackendFavoriteInquiry";
import { IPageIShoppingMallAiBackendFavoriteInquiry } from "../../../../../structures/IPageIShoppingMallAiBackendFavoriteInquiry";

/**
 * Add an inquiry to the customer's favorites list for Q&A/bookmarking purposes.
 *
 * Creates a new mapping between a customer's favorite group/folder and an
 * inquiry (Q&A or support thread), allowing the customer to bookmark or track
 * specific support interactions, product Q&As, or helpdesk tickets for later
 * reference.
 *
 * The 'shopping_mall_ai_backend_favorite_inquiries' entity records the
 * association, captures a business snapshot of the inquiry at time of
 * favoriting, and is critical for audit, personalized dashboard experience, and
 * compliance notification. The business logic enforces authentication, input
 * validation, and ownership restrictions, ensuring that only the customer can
 * create favorites for their own account.
 *
 * Postconditions include successful favoriting reflected in notification
 * queues, dashboard updates, and evidence audit logs. Attempts to favorite an
 * already-favorited inquiry within the same favorite group yield an error,
 * while successful creation returns the created favorite-inquiry mapping with
 * current snapshot.
 *
 * @param props.connection
 * @param props.favoriteId The ID of the favorite entity/folder for associating
 *   the inquiry as a favorite.
 * @param props.body Inquiry association information for favoriting a Q&A;
 *   includes the inquiryId and optional tagging or folder metadata.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createFavoriteInquiry(
  connection: IConnection,
  props: createFavoriteInquiry.Props,
): Promise<createFavoriteInquiry.Response> {
  return true === connection.simulate
    ? createFavoriteInquiry.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createFavoriteInquiry.METADATA,
          path: createFavoriteInquiry.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createFavoriteInquiry {
  export type Props = {
    /**
     * The ID of the favorite entity/folder for associating the inquiry as a
     * favorite.
     */
    favoriteId: string & tags.Format<"uuid">;

    /**
     * Inquiry association information for favoriting a Q&A; includes the
     * inquiryId and optional tagging or folder metadata.
     */
    body: IShoppingMallAiBackendFavoriteInquiry.ICreate;
  };
  export type Body = IShoppingMallAiBackendFavoriteInquiry.ICreate;
  export type Response = IShoppingMallAiBackendFavoriteInquiry;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/inquiries`;
  export const random = (): IShoppingMallAiBackendFavoriteInquiry =>
    typia.random<IShoppingMallAiBackendFavoriteInquiry>();
  export const simulate = (
    connection: IConnection,
    props: createFavoriteInquiry.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createFavoriteInquiry.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and filter among a customer's favorite inquiries (Q&A/bookmarked
 * threads).
 *
 * Enables customers to search through their favorited inquiries (Q&A threads)
 * using filtering, sorting, and pagination parameters. Supports complex
 * business queries, such as filtering by status, date, content keyword, or
 * folder/tags association.
 *
 * Reference is to the 'shopping_mall_ai_backend_favorite_inquiries' model,
 * which links favorites to inquiries and caches inquiry status for notification
 * and evidence. Only authenticated customers can access their own favorited
 * inquiries, with business logic enforcing row-level ownership checks.
 *
 * The response provides paginated summary information about each favorited
 * inquiry, including key metadata, favorited snapshot details, and optional
 * updates or notifications triggered by inquiry changes. Supports use cases
 * such as after-sales support follow-up, helpdesk ticket review, and personal
 * Q&A curation. Integrates with customer dashboard UI for improved service
 * personalization and retention.
 *
 * @param props.connection
 * @param props.favoriteId The UUID of the parent favorite entity
 *   (bookmark/folder) to search within.
 * @param props.body Filtering, search, sort, and pagination options for
 *   searching favorite inquiries.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexFavoriteInquiries(
  connection: IConnection,
  props: indexFavoriteInquiries.Props,
): Promise<indexFavoriteInquiries.Response> {
  return true === connection.simulate
    ? indexFavoriteInquiries.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexFavoriteInquiries.METADATA,
          path: indexFavoriteInquiries.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexFavoriteInquiries {
  export type Props = {
    /**
     * The UUID of the parent favorite entity (bookmark/folder) to search
     * within.
     */
    favoriteId: string & tags.Format<"uuid">;

    /**
     * Filtering, search, sort, and pagination options for searching
     * favorite inquiries.
     */
    body: IShoppingMallAiBackendFavoriteInquiry.IRequest;
  };
  export type Body = IShoppingMallAiBackendFavoriteInquiry.IRequest;
  export type Response = IPageIShoppingMallAiBackendFavoriteInquiry.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/inquiries`;
  export const random =
    (): IPageIShoppingMallAiBackendFavoriteInquiry.ISummary =>
      typia.random<IPageIShoppingMallAiBackendFavoriteInquiry.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexFavoriteInquiries.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexFavoriteInquiries.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single favorited inquiry in customer's favorites by inquiryId.
 *
 * Fetches the latest snapshot and status of a customer's favorited inquiry,
 * identified by favoriteId (the bookmark context) and inquiryId (the inquiry
 * itself). Returns business evidence such as inquiry title, cached content,
 * favorited timestamp, and update status relative to the original inquiry.
 *
 * The operation leverages the 'shopping_mall_ai_backend_favorite_inquiries'
 * mapping entity, ensuring that only authenticated customers may access their
 * own favorited Q&A/support content. The business logic ensures compliance and
 * proper evidence for dispute or service audit scenarios.
 *
 * An error is returned if the specified favorite-inquiry relation does not
 * exist, isn't owned by the customer, or has been logically deleted. Success
 * returns a current snapshot of the favorited inquiry, suitable for detail
 * pages, notification preview, or evidence retrieval.
 *
 * @param props.connection
 * @param props.favoriteId The ID of the favorite entity (bookmark or folder).
 * @param props.inquiryId The ID of the inquiry associated with the favorite
 *   record to retrieve.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries/:inquiryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atFavoriteInquiry(
  connection: IConnection,
  props: atFavoriteInquiry.Props,
): Promise<atFavoriteInquiry.Response> {
  return true === connection.simulate
    ? atFavoriteInquiry.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atFavoriteInquiry.METADATA,
          path: atFavoriteInquiry.path(props),
          status: null,
        },
      );
}
export namespace atFavoriteInquiry {
  export type Props = {
    /** The ID of the favorite entity (bookmark or folder). */
    favoriteId: string & tags.Format<"uuid">;

    /**
     * The ID of the inquiry associated with the favorite record to
     * retrieve.
     */
    inquiryId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendFavoriteInquiry;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries/:inquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavoriteInquiry =>
    typia.random<IShoppingMallAiBackendFavoriteInquiry>();
  export const simulate = (
    connection: IConnection,
    props: atFavoriteInquiry.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atFavoriteInquiry.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove an inquiry from the customer's bookmarked favorites folder/group.
 *
 * Deletes a single inquiry association from a customer's favorites group or
 * folder, removing only the bookmark/reference and leaving the original inquiry
 * intact. This operation leverages the composite (favoriteId, inquiryId) key to
 * uniquely identify the favorite-inquiry record.
 *
 * Business workflow ensures only the authenticated owner may delete their
 * favorites, and triggers audit trail update and evidence preservation. Upon
 * successful deletion, no response body is returned. If the mapping does not
 * exist, or is not owned by the current customer, an error is raised. Used for
 * managing support Q&A bookmarks, personal dashboard hygiene, and notification
 * curation.
 *
 * Deletion is logical (soft) and remains in evidence logs for compliance as
 * required.
 *
 * @param props.connection
 * @param props.favoriteId Unique identifier for the customer's favorite entity
 *   or group where the inquiry is bookmarked.
 * @param props.inquiryId Unique identifier for the inquiry being removed from
 *   favorites.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries/:inquiryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseFavoriteInquiry(
  connection: IConnection,
  props: eraseFavoriteInquiry.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseFavoriteInquiry.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseFavoriteInquiry.METADATA,
          path: eraseFavoriteInquiry.path(props),
          status: null,
        },
      );
}
export namespace eraseFavoriteInquiry {
  export type Props = {
    /**
     * Unique identifier for the customer's favorite entity or group where
     * the inquiry is bookmarked.
     */
    favoriteId: string & tags.Format<"uuid">;

    /** Unique identifier for the inquiry being removed from favorites. */
    inquiryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/inquiries/:inquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseFavoriteInquiry.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseFavoriteInquiry.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
