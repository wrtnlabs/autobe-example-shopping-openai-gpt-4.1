import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendFavoriteProduct } from "../../../../../structures/IShoppingMallAiBackendFavoriteProduct";
import { IPageIShoppingMallAiBackendFavoriteProduct } from "../../../../../structures/IPageIShoppingMallAiBackendFavoriteProduct";

/**
 * Add a product to a customer's favorited products under a given favoriteId.
 *
 * Adds a product to the set of favorited products under a given favorite
 * folder/group for the customer. The API enforces uniqueness so that the same
 * product is favorited only once per favorite group. If already present, this
 * is a no-op. Returns the newly created (or existing) favorite product link
 * record. Authorization is enforced to ensure only the owner can create
 * favorite links in their favorited group.
 *
 * @param props.connection
 * @param props.favoriteId Globally unique identifier for the favorite
 *   group/folder to which the product will be added.
 * @param props.body Favorite product creation info, must include productId.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Globally unique identifier for the favorite group/folder to which the
     * product will be added.
     */
    favoriteId: string & tags.Format<"uuid">;

    /** Favorite product creation info, must include productId. */
    body: IShoppingMallAiBackendFavoriteProduct.ICreate;
  };
  export type Body = IShoppingMallAiBackendFavoriteProduct.ICreate;
  export type Response = IShoppingMallAiBackendFavoriteProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/products`;
  export const random = (): IShoppingMallAiBackendFavoriteProduct =>
    typia.random<IShoppingMallAiBackendFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get paginated, filtered list of products favorited by the customer under a
 * given favoriteId.
 *
 * Retrieves a paginated, filterable list of products that have been favorited
 * by the customer under a specific favorite folder or group. The list is
 * customized to the session and selection context identified by favoriteId.
 * Pagination and sorting parameters are accepted in the request body,
 * supporting UI scalability. The operation checks the favorite's existence and
 * ownership before listing entries.
 *
 * @param props.connection
 * @param props.favoriteId Globally unique identifier of the parent favorite
 *   group or folder
 * @param props.body Filtering, sorting, and pagination parameters for searching
 *   favorites.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Globally unique identifier of the parent favorite group or folder */
    favoriteId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination parameters for searching
     * favorites.
     */
    body: IShoppingMallAiBackendFavoriteProduct.IRequest;
  };
  export type Body = IShoppingMallAiBackendFavoriteProduct.IRequest;
  export type Response = IPageIShoppingMallAiBackendFavoriteProduct.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/products`;
  export const random =
    (): IPageIShoppingMallAiBackendFavoriteProduct.ISummary =>
      typia.random<IPageIShoppingMallAiBackendFavoriteProduct.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed info for a favorited product under a favorite folder by
 * productId.
 *
 * Retrieves details for a specific favorited product under the given favorite
 * folder or group. Validates that the requesting customer owns the favorite and
 * that the productId is actually linked. Returns detailed summary including
 * favorited timestamp and product info. If the favorite or product link does
 * not exist or permission is denied, returns an appropriate error.
 *
 * @param props.connection
 * @param props.favoriteId Globally unique identifier of the parent favorite
 *   group/folder.
 * @param props.productId Globally unique identifier of the favorited product.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Globally unique identifier of the parent favorite group/folder. */
    favoriteId: string & tags.Format<"uuid">;

    /** Globally unique identifier of the favorited product. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendFavoriteProduct;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavoriteProduct =>
    typia.random<IShoppingMallAiBackendFavoriteProduct>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Unfavorite a product in a customer's favorite group by deleting the mapping.
 *
 * Removes the favorite-mark from a product in the customer's specified favorite
 * group/folder. This deletes the link record, i.e., the product is no longer
 * shown in the customer's favorites for the folder. If the mapping does not
 * exist or is already deleted, returns success (idempotency guaranteed). Only
 * the owner can perform this operation, enforcing correct authorization.
 *
 * @param props.connection
 * @param props.favoriteId Globally unique identifier of the parent favorite
 *   group/folder.
 * @param props.productId Globally unique identifier of product to unfavorite.
 * @path /shoppingMallAiBackend/customer/favorites/:favoriteId/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Globally unique identifier of the parent favorite group/folder. */
    favoriteId: string & tags.Format<"uuid">;

    /** Globally unique identifier of product to unfavorite. */
    productId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/favorites/:favoriteId/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/favorites/${encodeURIComponent(props.favoriteId ?? "null")}/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
