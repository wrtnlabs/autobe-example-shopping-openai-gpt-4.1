import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendOrder } from "../../../../structures/IShoppingMallAiBackendOrder";
import { IPageIShoppingMallAiBackendOrder } from "../../../../structures/IPageIShoppingMallAiBackendOrder";
export * as items from "./items";
export * as payments from "./payments";
export * as deliveries from "./deliveries";
export * as exchanges from "./exchanges";
export * as refunds from "./refunds";
export * as incidents from "./incidents";

/**
 * Creates a new order with customer, seller, channel, and line item data.
 * (shopping_mall_ai_backend_orders).
 *
 * Creates a new commercial order for a customer, seller, or channel context.
 * The request must include line items and contextual business data (cart
 * reference, channel, seller, currency, amount, etc.). Business logic validates
 * each input element for eligibility, inventory, and compliance. Policy may
 * restrict simultaneously open or overlapping orders for a customer to avoid
 * conflicts. Sensitive business evidence fields (codes, amounts) are
 * auto-managed, and downstream workflow (e.g., payment, fulfillment) is
 * triggered as per order policy. Failures are returned with clear error
 * explanations.
 *
 * @param props.connection
 * @param props.body Order creation data, including customer, channel, items,
 *   and payment context.
 * @path /shoppingMallAiBackend/customer/orders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Order creation data, including customer, channel, items, and payment
     * context.
     */
    body: IShoppingMallAiBackendOrder.ICreate;
  };
  export type Body = IShoppingMallAiBackendOrder.ICreate;
  export type Response = IShoppingMallAiBackendOrder;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/orders";
  export const random = (): IShoppingMallAiBackendOrder =>
    typia.random<IShoppingMallAiBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieves a paginated, filtered list of orders with advanced search.
 * (shopping_mall_ai_backend_orders).
 *
 * Search for and retrieve a filtered, paginated list of orders across customer
 * or seller context. This operation enables complex queries by status, channel,
 * currency, customer/seller, date range, and amount. Pagination and sorting is
 * provided, and the response includes summary details for each order. Access
 * control is enforced based on the user's role and ownership context. Sensitive
 * details are masked for non-owner queries unless policy grants full access
 * (e.g., seller or admin cases).
 *
 * @param props.connection
 * @param props.body Search and filter parameters for order search and
 *   pagination.
 * @path /shoppingMallAiBackend/customer/orders
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and filter parameters for order search and pagination. */
    body: IShoppingMallAiBackendOrder.IRequest;
  };
  export type Body = IShoppingMallAiBackendOrder.IRequest;
  export type Response = IPageIShoppingMallAiBackendOrder.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/orders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/orders";
  export const random = (): IPageIShoppingMallAiBackendOrder.ISummary =>
    typia.random<IPageIShoppingMallAiBackendOrder.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieves detailed information for an order by orderId.
 * (shopping_mall_ai_backend_orders).
 *
 * Retrieve complete detailed information about an order, including line items,
 * status, timeline, fulfillment, payment, and evidence snapshots where
 * permitted. The endpoint enforces access control; only the order's owner
 * (customer/seller) or admins with business need can access full details.
 * Partial masking is applied for sensitive data depending on user permissions.
 * Used by customer (order tracking), seller (fulfillment), and admin
 * (audit/helpdesk) flows.
 *
 * @param props.connection
 * @param props.orderId Unique identifier for the order (UUID) to retrieve.
 * @path /shoppingMallAiBackend/customer/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the order (UUID) to retrieve. */
    orderId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendOrder;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendOrder =>
    typia.random<IShoppingMallAiBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Updates permitted fields on an existing order identified by orderId.
 * (shopping_mall_ai_backend_orders).
 *
 * Update order details for a specific order, identified by orderId. The fields
 * permitted for update are defined by business rules and may include status
 * changes, contact details, fulfillment instructions, or buyer/seller notes.
 * Data validation applies according to the orderâ€™s current state and role
 * context. Only the order's owner, assigned seller, or admin may perform
 * updates. Immutable audit histories are recorded for each update. Operations
 * failing validation return descriptive business error codes/messages.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order to update (UUID).
 * @param props.body Permitted order fields for update (status, delivery,
 *   contact, notes, etc.).
 * @path /shoppingMallAiBackend/customer/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the order to update (UUID). */
    orderId: string & tags.Format<"uuid">;

    /**
     * Permitted order fields for update (status, delivery, contact, notes,
     * etc.).
     */
    body: IShoppingMallAiBackendOrder.IUpdate;
  };
  export type Body = IShoppingMallAiBackendOrder.IUpdate;
  export type Response = IShoppingMallAiBackendOrder;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/customer/orders/:orderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendOrder =>
    typia.random<IShoppingMallAiBackendOrder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Performs a soft delete of an order identified by orderId.
 * (shopping_mall_ai_backend_orders).
 *
 * Soft deletes an order with the specified orderId by setting the deleted_at
 * timestamp. The record is preserved for audit and legal compliance per
 * business policy. Order deletion is only allowed when business rules permit
 * (not finalized or legally required to retain). Permission is required (order
 * owner, assigned seller, or admin). Errors provide clear, actionable feedback
 * when operation is not permitted by policy.
 *
 * @param props.connection
 * @param props.orderId Order's unique identifier (UUID) to be soft deleted.
 * @path /shoppingMallAiBackend/customer/orders/:orderId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Order's unique identifier (UUID) to be soft deleted. */
    orderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/orders/:orderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/orders/${encodeURIComponent(props.orderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
