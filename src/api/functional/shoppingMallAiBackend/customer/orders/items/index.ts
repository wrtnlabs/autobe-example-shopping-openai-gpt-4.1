import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendOrderItem } from "../../../../../structures/IShoppingMallAiBackendOrderItem";
import { IPageIShoppingMallAiBackendOrderItem } from "../../../../../structures/IPageIShoppingMallAiBackendOrderItem";

/**
 * Retrieve a paginated, filterable list of items within a specific order for
 * review or fulfillment. Referenced table:
 * shopping_mall_ai_backend_order_items.
 *
 * This endpoint retrieves the set of items for a specific order, offering
 * advanced search, pagination, and filtering by attributes such as product,
 * bundle, or options. Order items include detailed product references,
 * quantity, pricing, discounts, and provide the basis for returns, exchanges,
 * or fulfilment events. Only users with appropriate authorization (the
 * purchasing customer, assigned seller, or admin) may access this resource, and
 * RBAC is enforced in the service logic. Pagination is required for large
 * orders to ensure efficiency. Error handling includes access denial for
 * unauthorized users or invalid order references.
 *
 * Order items are modeled in the Prisma DB as
 * shopping_mall_ai_backend_order_items, each referencing its parent order,
 * associated products/bundles, and snapshotting product details for compliance.
 * Results may include summary info or full detail depending on roles and query
 * parameters.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the target order (UUID format).
 * @param props.body Parameters for searching, filtering, and paginating order
 *   items for this order.
 * @path /shoppingMallAiBackend/customer/orders/:orderId/items
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target order (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /**
     * Parameters for searching, filtering, and paginating order items for
     * this order.
     */
    body: IShoppingMallAiBackendOrderItem.IRequest;
  };
  export type Body = IShoppingMallAiBackendOrderItem.IRequest;
  export type Response = IPageIShoppingMallAiBackendOrderItem.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/orders/:orderId/items",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/items`;
  export const random = (): IPageIShoppingMallAiBackendOrderItem.ISummary =>
    typia.random<IPageIShoppingMallAiBackendOrderItem.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed data for a specific order item by order and item ID. Prisma
 * table: shopping_mall_ai_backend_order_items.
 *
 * Fetches comprehensive details about a single order item for a given order and
 * item ID. Includes all business attributes such as quantity, unit/final price,
 * selected bundle or options, discounts, and product snapshot at order time.
 * Security logic ensures only authorized party (order owner, seller, admin) can
 * view details; the endpoint is used for order tracking, review processing,
 * returns/exchange initiation, or support inquiries. If the item does not exist
 * within the referenced order or the requester lacks authorization, an error is
 * returned.
 *
 * The endpoint strictly follows the structure of
 * shopping_mall_ai_backend_order_items from the schema, supporting cross-entity
 * validation (orderâ†”item). Useful for audit trail purposes and business
 * workflow automation.
 *
 * @param props.connection
 * @param props.orderId Unique identifier of the order (UUID format).
 * @param props.itemId Identifier for the specific item within the order (UUID
 *   format).
 * @path /shoppingMallAiBackend/customer/orders/:orderId/items/:itemId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the order (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /** Identifier for the specific item within the order (UUID format). */
    itemId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendOrderItem;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendOrderItem =>
    typia.random<IShoppingMallAiBackendOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
