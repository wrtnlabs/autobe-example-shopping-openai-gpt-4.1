import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendInquiry } from "../../../../structures/IShoppingMallAiBackendInquiry";
import { IPageIShoppingMallAiBackendInquiry } from "../../../../structures/IPageIShoppingMallAiBackendInquiry";
export * as replies from "./replies";

/**
 * Create a new inquiry (QnA/support ticket) for a customer or seller.
 *
 * This endpoint registers a new inquiry on behalf of a customer or seller. The
 * request body contains all necessary info: the user making the inquiry (as
 * customer_id or seller_id), the related product or order (optional), the
 * inquiry title, content, privacy status (public/private), and any initial
 * workflow status.
 *
 * Submission creates a new inquiry row, triggers relevant events or
 * notifications, and returns the persisted inquiry object. Security and
 * business rules require authentication (typically as customer or seller),
 * blocking creation for anonymous/unverified users.
 *
 * Input validation ensures required fields (e.g., title, body, private flag)
 * are provided and comply with business constraints (e.g., length, product
 * reference if required by category).
 *
 * @param props.connection
 * @param props.body Inquiry creation payload: owner, title, content, privacy,
 *   target entities.
 * @path /shoppingMallAiBackend/customer/inquiries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Inquiry creation payload: owner, title, content, privacy, target
     * entities.
     */
    body: IShoppingMallAiBackendInquiry.ICreate;
  };
  export type Body = IShoppingMallAiBackendInquiry.ICreate;
  export type Response = IShoppingMallAiBackendInquiry;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/inquiries";
  export const random = (): IShoppingMallAiBackendInquiry =>
    typia.random<IShoppingMallAiBackendInquiry>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate user inquiries/QnA tickets with advanced filtering.
 *
 * This endpoint retrieves a paginated and filtered list of user inquiries
 * (questions, support threads, or tickets) from across the shopping mall
 * platform. The inquiries can have relationships with customer, seller,
 * product, order, and can be filtered by query parameters such as title,
 * status, privacy flag, and date ranges for created/closed timestamps.
 *
 * Search can be conducted by end-users (for their own inquiries) or by
 * authorized admins (across all). Only non-deleted inquiries are included
 * unless an admin filters for deleted entries as part of compliance or evidence
 * reviews. Results include essential fields like inquiry type, target
 * product/order, status, and whether the inquiry is private.
 *
 * Common use: review of customer's support history, seller's Q&A lists, or
 * admin oversight for moderation and compliance. Pagination and sorting are
 * standard for result efficiency.
 *
 * @param props.connection
 * @param props.body Filter, sort, and pagination settings applied to inquiries
 *   search.
 * @path /shoppingMallAiBackend/customer/inquiries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, sort, and pagination settings applied to inquiries search. */
    body: IShoppingMallAiBackendInquiry.IRequest;
  };
  export type Body = IShoppingMallAiBackendInquiry.IRequest;
  export type Response = IPageIShoppingMallAiBackendInquiry.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/inquiries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/inquiries";
  export const random = (): IPageIShoppingMallAiBackendInquiry.ISummary =>
    typia.random<IPageIShoppingMallAiBackendInquiry.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get the complete details of a specific inquiry by its ID.
 *
 * Allows a user, seller, or admin to load a detailed view of an inquiry by its
 * unique identifier. The inquiry data includes origin (customer or seller),
 * related product, order, title, message content, privacy flag, status, closed
 * time, and full audit trail timestamps.
 *
 * Used when viewing details, responding, handling moderation, or referencing
 * for after-sales operations. Access is generally scoped to the owner
 * (customer/seller) or admin; data is filtered accordingly for privacy and
 * security.
 *
 * Common errors include not found (invalid/nonexistent ID) or access denied
 * (insufficient permission).
 *
 * @param props.connection
 * @param props.inquiryId UUID of the inquiry to retrieve.
 * @path /shoppingMallAiBackend/customer/inquiries/:inquiryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the inquiry to retrieve. */
    inquiryId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendInquiry;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/inquiries/:inquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendInquiry =>
    typia.random<IShoppingMallAiBackendInquiry>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific inquiry by ID (content, status, privacy, etc).
 *
 * Enables authorized users to update the content, metadata, or workflow status
 * of an inquiry. The endpoint only permits modifications by the owner
 * (customer/seller) or an administrator. The request body should encapsulate
 * updatable fields (title, body, privacy, status, workflow data), which are
 * validated per business rules for edit limits and audit requirements. A
 * successful update persists changes to storage and returns the new details for
 * the inquiry.
 *
 * Security: Authorization must validate the updater's ownership or role; audit
 * trails are generated for compliance and evidence. Edits to deleted or
 * finalized inquiries are disallowed. Related endpoints: detail inquiry GET,
 * delete/erase, and moderation logs.
 *
 * @param props.connection
 * @param props.inquiryId UUID of the inquiry to update.
 * @param props.body Fields allowed for update: title/body/privacy/status, etc.
 * @path /shoppingMallAiBackend/customer/inquiries/:inquiryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the inquiry to update. */
    inquiryId: string & tags.Format<"uuid">;

    /** Fields allowed for update: title/body/privacy/status, etc. */
    body: IShoppingMallAiBackendInquiry.IUpdate;
  };
  export type Body = IShoppingMallAiBackendInquiry.IUpdate;
  export type Response = IShoppingMallAiBackendInquiry;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/customer/inquiries/:inquiryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendInquiry =>
    typia.random<IShoppingMallAiBackendInquiry>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (soft delete) an inquiry by ID, preserving evidence.
 *
 * Mark the specified inquiry as logically deleted by setting the deleted_at
 * field to the current timestamp. This operation may only be performed by
 * inquiry owner (customer/seller) or administrators. No data is physically
 * removed, supporting evidence preservation and compliance audits.
 *
 * Once deleted, the inquiry is excluded from normal user access and search
 * results but may remain available to authorized auditors. Attempted deletion
 * of non-existent or already deleted inquiries raises a meaningful business
 * exception for traceability. Success is indicated by void or confirmation
 * response; related endpoints include inquiry update, detail view, and
 * moderation/audit logs.
 *
 * @param props.connection
 * @param props.inquiryId UUID of the inquiry to delete.
 * @path /shoppingMallAiBackend/customer/inquiries/:inquiryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the inquiry to delete. */
    inquiryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/inquiries/:inquiryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
