import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCoin } from "../../../../structures/IShoppingMallAiBackendCoin";
import { IPageIShoppingMallAiBackendCoin } from "../../../../structures/IPageIShoppingMallAiBackendCoin";
export * as transactions from "./transactions";

/**
 * Create a new digital coin ledger for a customer or seller.
 *
 * This endpoint creates a new coin ledger (wallet) for a user or seller in the
 * shopping_mall_ai_backend_coins table. The creation workflow may be triggered
 * automatically during onboarding, account upgrades, or manual admin actions
 * for lost/damaged wallets.
 *
 * Requesting users must be authorized to create ledgers (usually their own or
 * by admin privilege). The request body includes owner (customer or seller),
 * and initial coin amounts (optional, typically zero). All records are
 * initialized with audit timestamps and compliance trace. Duplicate ledgers for
 * the same owner are prevented per schema constraints.
 *
 * If creation is successful, details of the new coin ledger are returned. All
 * actions are logged as business events for legal and system auditability.
 * Errors are raised for duplicate or unauthorized attempts.
 *
 * @param props.connection
 * @param props.body Information about the owner of the new coin ledger, plus
 *   optional initial balances.
 * @path /shoppingMallAiBackend/customer/coins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information about the owner of the new coin ledger, plus optional
     * initial balances.
     */
    body: IShoppingMallAiBackendCoin.ICreate;
  };
  export type Body = IShoppingMallAiBackendCoin.ICreate;
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/coins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/coins";
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list digital coin ledgers for users or sellers with filtering and
 * pagination.
 *
 * This endpoint allows authenticated users (customers or sellers) to search for
 * and retrieve a paginated collection of their own or authorized digital coin
 * ledgers, as stored in the shopping_mall_ai_backend_coins table.
 *
 * It supports advanced search, filtering, and sortingâ€”for example, by coin
 * balance, account status, or creation/update range. Pagination parameters help
 * optimize data usage and interface performance. Only the ledger owner or
 * administrators may access this data; all access and search events are logged
 * for audit compliance.
 *
 * The response provides summary or detail views per required output, and
 * supports both customer and seller coin accounts.
 *
 * @param props.connection
 * @param props.body Filter, search, and sort options for coin ledger search
 *   (owner, balance range, pagination, etc.).
 * @path /shoppingMallAiBackend/customer/coins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, search, and sort options for coin ledger search (owner,
     * balance range, pagination, etc.).
     */
    body: IShoppingMallAiBackendCoin.IRequest;
  };
  export type Body = IShoppingMallAiBackendCoin.IRequest;
  export type Response = IPageIShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/coins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/coins";
  export const random = (): IPageIShoppingMallAiBackendCoin =>
    typia.random<IPageIShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific digital coin ledger by coinId.
 *
 * This operation retrieves the details of a digital coin ledger given its
 * unique coinId. The shopping_mall_ai_backend_coins table contains information
 * such as total accrued coins, available coin balance, expired/lost status, and
 * audit timestamps.
 *
 * Only the owner (customer or seller) and system administrators may access coin
 * ledger information. This endpoint is typically used in personal wallet detail
 * pages, business analytics, and customer support requests.
 *
 * Results include all business and audit fields required for transaction
 * verification, wallet management, or troubleshooting balance anomalies. If the
 * record is missing or restricted, an error is returned.
 *
 * @param props.connection
 * @param props.coinId Unique identifier of the coin ledger to access.
 * @path /shoppingMallAiBackend/customer/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the coin ledger to access. */
    coinId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/coins/:coinId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update digital coin ledger information by coinId.
 *
 * This endpoint allows an authenticated user or admin to update a specific coin
 * ledger, identified by coinId, within the shopping_mall_ai_backend_coins
 * table.
 *
 * Fields eligible for update may include owner (customer or seller), balance
 * adjustments (admin only), reactivation or deactivation, and other business
 * metadata. The operation enforces full audit tracking for compliance and
 * reversibility. Updates must meet validation constraints and cannot circumvent
 * existing schema rules (no ownership conflicts, double spend, etc.).
 *
 * If successful, the API returns the updated coin ledger, including new
 * audit/metadata. Errors return if record or permissions are invalid, or schema
 * validation fails.
 *
 * @param props.connection
 * @param props.coinId Unique identifier for the coin ledger to be updated.
 * @param props.body Fields for update (owner, status, coin adjustments, etc.),
 *   subject to schema validation.
 * @path /shoppingMallAiBackend/customer/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the coin ledger to be updated. */
    coinId: string & tags.Format<"uuid">;

    /**
     * Fields for update (owner, status, coin adjustments, etc.), subject to
     * schema validation.
     */
    body: IShoppingMallAiBackendCoin.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCoin.IUpdate;
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/customer/coins/:coinId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (mark as deleted_at) a coin ledger by coinId for regulatory
 * compliance.
 *
 * This endpoint marks a specified coin ledger (wallet) as deleted by setting
 * the deleted_at timestamp in the shopping_mall_ai_backend_coins table.
 * Soft-deletion ensures records are retained for evidence, regulatory audit,
 * and future recovery in line with business and legal requirements.
 *
 * Only the ledger's owner (customer or seller) or privileged administrators may
 * initiate deletion. Once soft-deleted, the ledger is hidden from general
 * access, and further transactions are blocked.
 *
 * Attempts to delete non-existent or unauthorized coin ledgers result in proper
 * error signaling. Full deletion is intentionally not allowed (preserving
 * audit/evidence).
 *
 * @param props.connection
 * @param props.coinId ID of the coin ledger to be soft-deleted.
 * @path /shoppingMallAiBackend/customer/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the coin ledger to be soft-deleted. */
    coinId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/customer/coins/:coinId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
