import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendMileage } from "../../../../structures/IShoppingMallAiBackendMileage";
import { IPageIShoppingMallAiBackendMileage } from "../../../../structures/IPageIShoppingMallAiBackendMileage";
export * as transactions from "./transactions";

/**
 * Create a new mileage/points ledger for a customer or seller.
 *
 * Creates a new mileage (rewards points) ledger for a specified customer or
 * seller. Typical use cases include welcoming new users to loyalty programs,
 * handling bulk migrations, or granting admin-initiated bonus point accounts.
 *
 * Validates that the referenced customer/seller does not already possess an
 * active mileage ledger (uniqueness enforced per owner). The operation records
 * the initial accrual, status, timestamps, and administrative or system context
 * as appropriate. Response returns the fully-detailed mileage ledger upon
 * creation. Error handling includes duplicate ledger detection, bad input, and
 * insufficient permissions.
 *
 * @param props.connection
 * @param props.body Full data required for new mileage ledger creation (owner
 *   references, initial balance, business rationale).
 * @path /shoppingMallAiBackend/customer/mileages
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Full data required for new mileage ledger creation (owner references,
     * initial balance, business rationale).
     */
    body: IShoppingMallAiBackendMileage.ICreate;
  };
  export type Body = IShoppingMallAiBackendMileage.ICreate;
  export type Response = IShoppingMallAiBackendMileage;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/customer/mileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/mileages";
  export const random = (): IShoppingMallAiBackendMileage =>
    typia.random<IShoppingMallAiBackendMileage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve all mileage ledgers (with search and paging).
 *
 * Search and list available mileage (rewards points) ledgers accessible to the
 * customer, seller, or, with appropriate permissions, as a system
 * administrator/staff. Enables users to view their rewards balances and past
 * accrual, while supporting staff in cross-account audits or loyalty
 * analytics.
 *
 * Supports advanced filtering and search capabilities for auditing, analytics,
 * loyalty program reporting, and compliance. Response includes summary data:
 * balances, expiration info, and user/seller linkage as dictated by the mileage
 * entity.
 *
 * Errors may occur on unauthorized access, forbidden fields, or if search
 * criteria violate business or technical constraints. Filtering and ordering
 * are designed to meet business reporting, audit, and UX requirements for large
 * datasets.
 *
 * @param props.connection
 * @param props.body Request parameters for searching, filtering, and paginating
 *   mileage ledger index.
 * @path /shoppingMallAiBackend/customer/mileages
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Request parameters for searching, filtering, and paginating mileage
     * ledger index.
     */
    body: IShoppingMallAiBackendMileage.IRequest;
  };
  export type Body = IShoppingMallAiBackendMileage.IRequest;
  export type Response = IPageIShoppingMallAiBackendMileage.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/mileages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/customer/mileages";
  export const random = (): IPageIShoppingMallAiBackendMileage.ISummary =>
    typia.random<IPageIShoppingMallAiBackendMileage.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get mileage ledger details by ID (full audit context).
 *
 * Get complete details for a specific mileage/point ledger by identifier. This
 * endpoint provides all business context and evidence—owner, status, audit
 * timestamps, accruals, on-hold and expired values, and cross-linkage to
 * customer/seller accounts—per business compliance rules.
 *
 * Designed for consuming in user dashboards, support operations, and financial
 * or loyalty program audits. Authentication and authorization must ensure only
 * legitimate owners or staff access sensitive mileage records. Returns errors
 * for missing, unauthorized, or forbidden mileageId.
 *
 * @param props.connection
 * @param props.mileageId UUID of the mileage ledger to retrieve.
 * @path /shoppingMallAiBackend/customer/mileages/:mileageId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the mileage ledger to retrieve. */
    mileageId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendMileage;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/mileages/:mileageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/mileages/${encodeURIComponent(props.mileageId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendMileage =>
    typia.random<IShoppingMallAiBackendMileage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
