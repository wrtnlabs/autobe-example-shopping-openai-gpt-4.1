import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendMileageTransaction } from "../../../../../structures/IShoppingMallAiBackendMileageTransaction";
import { IPageIShoppingMallAiBackendMileageTransaction } from "../../../../../structures/IPageIShoppingMallAiBackendMileageTransaction";

/**
 * Paginate and search the full transaction history for a single mileage ledger.
 *
 * Retrieve all transaction events (accrual, use, expiration, manual/admin
 * adjustment) for a specific mileage ledger by mileageId. This endpoint returns
 * a paginated, filtered listing of changes to the given ledger, with each event
 * including type, value, description, before/after state, and audit
 * timestamps.
 *
 * Access is restricted to ledger owners and duly authorized administrators
 * (customer, admin, seller as business/role permits). Errors expected on
 * authorization failure, not found, or invalid filter criteria. The information
 * supports self-service user review, staff support, and compliance
 * investigations into reward accrual and spending history.
 *
 * @param props.connection
 * @param props.mileageId UUID of the mileage ledger for which to fetch
 *   transactions.
 * @param props.body Transaction log search, filter, and pagination parameters
 *   for the specified mileage ledger.
 * @path /shoppingMallAiBackend/customer/mileages/:mileageId/transactions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the mileage ledger for which to fetch transactions. */
    mileageId: string & tags.Format<"uuid">;

    /**
     * Transaction log search, filter, and pagination parameters for the
     * specified mileage ledger.
     */
    body: IShoppingMallAiBackendMileageTransaction.IRequest;
  };
  export type Body = IShoppingMallAiBackendMileageTransaction.IRequest;
  export type Response = IPageIShoppingMallAiBackendMileageTransaction.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/customer/mileages/:mileageId/transactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/customer/mileages/${encodeURIComponent(props.mileageId ?? "null")}/transactions`;
  export const random =
    (): IPageIShoppingMallAiBackendMileageTransaction.ISummary =>
      typia.random<IPageIShoppingMallAiBackendMileageTransaction.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific mileage ledger transaction by mileageId and
 * transactionId.
 *
 * This endpoint allows authorized users to retrieve a specific transaction
 * entry within a given mileage ledger. The
 * shopping_mall_ai_backend_mileage_transactions table provides an immutable,
 * audit-grade record of all changes (accrual, use, expire, manual adjustment,
 * donation) for customer and seller mileage ledgers.
 *
 * Requesting a transaction by mileageId and transactionId enables compliance
 * auditors, customers, or support staff to view ledger history for dispute
 * resolution, reward validation, or fraud investigation. The operation enforces
 * strict authorization policiesâ€”only the mileage owner (customer or seller) or
 * designated business administrators can access the transaction detail.
 *
 * Returned data includes the change_type, amount, reference, before/after
 * balance, business reason, and narrative context for this transaction, as
 * defined in the schema. This endpoint integrates with evidence requirements
 * for refunds, promo campaigns, and reward point policies. If the record does
 * not exist or is forbidden, an appropriate error is returned.
 *
 * @param props.connection
 * @param props.mileageId Unique identifier of the mileage ledger to which the
 *   transaction belongs.
 * @param props.transactionId Unique identifier for the specific transaction
 *   within the mileage ledger.
 * @path /shoppingMallAiBackend/customer/mileages/:mileageId/transactions/:transactionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the mileage ledger to which the transaction
     * belongs.
     */
    mileageId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the specific transaction within the mileage
     * ledger.
     */
    transactionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendMileageTransaction;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/customer/mileages/:mileageId/transactions/:transactionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/customer/mileages/${encodeURIComponent(props.mileageId ?? "null")}/transactions/${encodeURIComponent(props.transactionId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendMileageTransaction =>
    typia.random<IShoppingMallAiBackendMileageTransaction>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("mileageId")(() => typia.assert(props.mileageId));
      assert.param("transactionId")(() => typia.assert(props.transactionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
