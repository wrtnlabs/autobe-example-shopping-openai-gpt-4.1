import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendFavorite } from "../../../../structures/IShoppingMallAiBackendFavorite";
import { IPageIShoppingMallAiBackendFavorite } from "../../../../structures/IPageIShoppingMallAiBackendFavorite";

/**
 * Create a new favorite for a specific target (product, address, inquiry).
 *
 * Creates a new favorite for the user, specifying the target type (product,
 * address, inquiry, etc.) and the unique ID of the target. Optionally, the
 * favorite can be placed into a user-created folder for grouped management.
 * Unique constraints are enforced to prevent users from favoriting the same
 * item multiple times.
 *
 * On successful creation, the endpoint returns all favorite details, including
 * audit evidence information, type, snapshot identifiers, and timestamps. Any
 * attempt to favorite an already-favorited target returns a duplication error
 * consistent with business policies.
 *
 * @param props.connection
 * @param props.body Favorite creation data: target type (product, address,
 *   inquiry), target ID, and optional folder.
 * @path /shoppingMallAiBackend/admin/favorites
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Favorite creation data: target type (product, address, inquiry),
     * target ID, and optional folder.
     */
    body: IShoppingMallAiBackendFavorite.ICreate;
  };
  export type Body = IShoppingMallAiBackendFavorite.ICreate;
  export type Response = IShoppingMallAiBackendFavorite;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/favorites";
  export const random = (): IShoppingMallAiBackendFavorite =>
    typia.random<IShoppingMallAiBackendFavorite>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list paginated favorites for the authenticated user.
 *
 * Retrieves the authenticated user's favorites in a paginated result,
 * supporting search/filtering by target type, folder, or keywords. Only
 * non-deleted (active) favorites are shown. Advanced search allows users to
 * filter favorites by type (product, address, inquiry), folder, text, or date
 * range. Pagination and sorting options permit scalable browser navigation.
 *
 * Security checks ensure users can only view their own favorites and not those
 * of other users. Provides a summary view of each favorite, with audit
 * timestamps as per evidence policies.
 *
 * @param props.connection
 * @param props.body Filtering and pagination options for favorite retrieval:
 *   type, folder, search text, date range, pagination controls.
 * @path /shoppingMallAiBackend/admin/favorites
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering and pagination options for favorite retrieval: type,
     * folder, search text, date range, pagination controls.
     */
    body: IShoppingMallAiBackendFavorite.IRequest;
  };
  export type Body = IShoppingMallAiBackendFavorite.IRequest;
  export type Response = IPageIShoppingMallAiBackendFavorite.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/favorites",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/favorites";
  export const random = (): IPageIShoppingMallAiBackendFavorite.ISummary =>
    typia.random<IPageIShoppingMallAiBackendFavorite.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details about a single favorite by ID for the owner.
 *
 * Gets full detail about a single favorite belonging to the user, enforcing
 * access to only non-deleted items owned by the requesting party. The favorite
 * includes fields like target type (product, address, inquiry), snapshot
 * metadata for audit, optional folder association, and full evidence
 * timestamps.
 *
 * The operation supports use cases like displaying item details in a user's
 * favorites page or preparing notification logic for favorite changes. If the
 * item doesn't exist or is deleted (or the user doesn't own it), appropriate
 * error or forbidden responses are returned.
 *
 * @param props.connection
 * @param props.favoriteId Unique identifier of the favorite to retrieve.
 * @path /shoppingMallAiBackend/admin/favorites/:favoriteId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the favorite to retrieve. */
    favoriteId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendFavorite;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/favorites/:favoriteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/favorites/${encodeURIComponent(props.favoriteId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavorite =>
    typia.random<IShoppingMallAiBackendFavorite>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing favorite's metadata or folder assignment.
 *
 * Update a favorite belonging to the requesting user. Supports changes to
 * organization folder, snapshot title, or other updatable metadata as allowed
 * in business requirements. Strict ownership and active status checks mean only
 * user-owned, non-deleted favorites can be modified. Change traces are
 * preserved for evidence and audit as required by platform policy.
 *
 * If the favorite does not exist or has been soft-deleted, a not found error is
 * returned. If updates violate uniqueness or business logic, an appropriate
 * error code is issued. The success response returns the updated favorite
 * entity with new timestamps and field values.
 *
 * @param props.connection
 * @param props.favoriteId Unique identifier of the favorite to update.
 * @param props.body Fields to update (e.g., folder ID, snapshot title).
 * @path /shoppingMallAiBackend/admin/favorites/:favoriteId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the favorite to update. */
    favoriteId: string & tags.Format<"uuid">;

    /** Fields to update (e.g., folder ID, snapshot title). */
    body: IShoppingMallAiBackendFavorite.IUpdate;
  };
  export type Body = IShoppingMallAiBackendFavorite.IUpdate;
  export type Response = IShoppingMallAiBackendFavorite;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/favorites/:favoriteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/favorites/${encodeURIComponent(props.favoriteId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendFavorite =>
    typia.random<IShoppingMallAiBackendFavorite>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("favoriteId")(() => typia.assert(props.favoriteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
