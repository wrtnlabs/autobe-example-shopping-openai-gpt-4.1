import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCouponStackingRule } from "../../../../../structures/IShoppingMallAiBackendCouponStackingRule";
import { IPageIShoppingMallAiBackendCouponStackingRule } from "../../../../../structures/IPageIShoppingMallAiBackendCouponStackingRule";

/**
 * Create a stacking rule for the given coupon.
 *
 * Create a new stacking rule for a particular coupon. This API allows business
 * owners, marketing, or admin users to specify whether a given coupon can be
 * stacked with another coupon or coupon type, and the application logic for
 * combinability.
 *
 * Business safeguards enforce that the stacking rule is not duplicated and
 * applies within the scope of the selected coupon. Creation triggers an audit
 * log entry and any business process for required approval/notification.
 *
 * This action is strictly limited to administrative or marketing roles with the
 * necessary privileges, to prevent promotion manipulation or accidental
 * business configuration errors.
 *
 * @param props.connection
 * @param props.couponId Unique identifier for the coupon under which to create
 *   the stacking rule
 * @param props.body Stacking rule configuration to add to the coupon
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/stackingRules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier for the coupon under which to create the stacking
     * rule
     */
    couponId: string & tags.Format<"uuid">;

    /** Stacking rule configuration to add to the coupon */
    body: IShoppingMallAiBackendCouponStackingRule.ICreate;
  };
  export type Body = IShoppingMallAiBackendCouponStackingRule.ICreate;
  export type Response = IShoppingMallAiBackendCouponStackingRule;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/stackingRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/stackingRules`;
  export const random = (): IShoppingMallAiBackendCouponStackingRule =>
    typia.random<IShoppingMallAiBackendCouponStackingRule>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated searchable list of coupon stacking rules for business/campaign ops.
 *
 * Search, filter, and audit all stacking rules for a given coupon, providing
 * business operator or admin with the full policy details for which codes can
 * or cannot be stacked together. Each result includes exclusion policy,
 * rationale, and linkage to policy/campaign assignment. The results are
 * paginated for scalability and support large-scale campaign policy
 * review/audit workflows.
 *
 * @param props.connection
 * @param props.couponId Coupon ID for which stacking rule policies are to be
 *   retrieved.
 * @param props.body Request supports search/filter criteria and paging for
 *   stacking rules.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/stackingRules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexCouponStackingRules(
  connection: IConnection,
  props: indexCouponStackingRules.Props,
): Promise<indexCouponStackingRules.Response> {
  return true === connection.simulate
    ? indexCouponStackingRules.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexCouponStackingRules.METADATA,
          path: indexCouponStackingRules.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexCouponStackingRules {
  export type Props = {
    /** Coupon ID for which stacking rule policies are to be retrieved. */
    couponId: string & tags.Format<"uuid">;

    /**
     * Request supports search/filter criteria and paging for stacking
     * rules.
     */
    body: IShoppingMallAiBackendCouponStackingRule.IRequest;
  };
  export type Body = IShoppingMallAiBackendCouponStackingRule.IRequest;
  export type Response = IPageIShoppingMallAiBackendCouponStackingRule;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/stackingRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/stackingRules`;
  export const random = (): IPageIShoppingMallAiBackendCouponStackingRule =>
    typia.random<IPageIShoppingMallAiBackendCouponStackingRule>();
  export const simulate = (
    connection: IConnection,
    props: indexCouponStackingRules.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexCouponStackingRules.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get the configuration and details of a stacking rule for a given coupon.
 *
 * Retrieve full details of a coupon stacking rule, including its stacking type,
 * target, and business applicability. This API allows administrators and
 * authorized business managers to verify how a coupon interacts with other
 * discount policies.
 *
 * The operation checks the requested stacking rule entry under the provided
 * couponId to ensure correct scoping and security. This call is vital for
 * compliance, debugging promotion issues, and supporting transparent
 * configuration audits. Any configuration retrieved can be compared against
 * audit logs for change tracking.
 *
 * Results are restricted to authorized roles, as stacking rules have direct
 * business and financial implications.
 *
 * @param props.connection
 * @param props.couponId Unique identifier for the coupon whose stacking rule is
 *   being retrieved
 * @param props.stackingRuleId Unique identifier for the stacking rule to
 *   retrieve
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the coupon whose stacking rule is being
     * retrieved
     */
    couponId: string & tags.Format<"uuid">;

    /** Unique identifier for the stacking rule to retrieve */
    stackingRuleId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCouponStackingRule;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/stackingRules/${encodeURIComponent(props.stackingRuleId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCouponStackingRule =>
    typia.random<IShoppingMallAiBackendCouponStackingRule>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("stackingRuleId")(() => typia.assert(props.stackingRuleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a stacking rule for a coupon identified by stackingRuleId.
 *
 * Update a stacking rule for the specified coupon. Only authorized business
 * operators (admins) can make this change. Parameter validation ensures
 * business safety and logs updates for audit and compliance purposes.
 *
 * All changes to stacking rules are substantive for promotion policy and
 * require critical change control, as they can impact customer-facing discount
 * eligibility and stacking logic. The update is atomic and either fully
 * succeeds or fails with rollback.
 *
 * After update, the new rule is instantly reflected in business logic and any
 * active promotion validation flows.
 *
 * @param props.connection
 * @param props.couponId Unique identifier for the coupon whose stacking rule
 *   will be updated
 * @param props.stackingRuleId Unique identifier of the stacking rule to update
 * @param props.body Updated stacking rule configuration
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the coupon whose stacking rule will be updated */
    couponId: string & tags.Format<"uuid">;

    /** Unique identifier of the stacking rule to update */
    stackingRuleId: string & tags.Format<"uuid">;

    /** Updated stacking rule configuration */
    body: IShoppingMallAiBackendCouponStackingRule.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCouponStackingRule.IUpdate;
  export type Response = IShoppingMallAiBackendCouponStackingRule;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/stackingRules/${encodeURIComponent(props.stackingRuleId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCouponStackingRule =>
    typia.random<IShoppingMallAiBackendCouponStackingRule>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("stackingRuleId")(() => typia.assert(props.stackingRuleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a stacking rule from the coupon.
 *
 * Permanently delete a stacking rule belonging to a coupon. This operation
 * completely removes the stacking rule from the database and thereby eliminates
 * its business logic from the active system.
 *
 * This action is only performed by admins with appropriate permissions after
 * careful consideration. Once performed, the stacking rule cannot be recovered.
 * It is recommended to ensure proper business authorization and audit logging
 * is in place before invoking this operation.
 *
 * There is no evidence preserved or logical (soft) delete; the stacking rule
 * will be entirely removed.
 *
 * @param props.connection
 * @param props.couponId Unique identifier for the coupon whose stacking rule is
 *   being deleted
 * @param props.stackingRuleId Unique identifier of the stacking rule to delete
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the coupon whose stacking rule is being deleted */
    couponId: string & tags.Format<"uuid">;

    /** Unique identifier of the stacking rule to delete */
    stackingRuleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/stackingRules/:stackingRuleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/stackingRules/${encodeURIComponent(props.stackingRuleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("stackingRuleId")(() => typia.assert(props.stackingRuleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
