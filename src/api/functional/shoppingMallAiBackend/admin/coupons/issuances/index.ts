import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCouponIssuance } from "../../../../../structures/IShoppingMallAiBackendCouponIssuance";
import { IPageIShoppingMallAiBackendCouponIssuance } from "../../../../../structures/IPageIShoppingMallAiBackendCouponIssuance";

/**
 * Issue a coupon to a user or event for a specific coupon, creating an
 * audit-traceable issuance record.
 *
 * Create a new issuance of a coupon for a specific coupon ID, either for a
 * specific customer or as part of a campaign event. This operation enforces
 * coupon policy business rules for issuance, such as eligibility, maximum
 * number per user, campaign window, and compliance traceability.
 *
 * Upon execution, it creates an immutable record of the coupon issuance,
 * capturing the intended customer or campaign recipient (if applicable),
 * external code (e.g. event code or distributed voucher), optional expiration,
 * and initial status. The operation is designed for automated coupon
 * distribution by admins or system workflows, and is used for both personal and
 * bulk campaign scenarios.
 *
 * Security and compliance are addressed by requiring roles with authority to
 * issue coupons (e.g., admin, seller), preventing unauthorized mass issuance or
 * policy infringement. If issuance attempts exceed limits, target
 * ineligibility, or violate coupon configuration (such as issuing more coupons
 * than allowed or past policy expiry), the operation responds with detailed
 * business error messages defined by the application.
 *
 * @param props.connection
 * @param props.couponId Target coupon's unique identifier for which to issue
 *   the coupon.
 * @param props.body Issuance details including customer ID, optional external
 *   code, and optional expiration for this coupon issuance.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/issuances
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createIssuance(
  connection: IConnection,
  props: createIssuance.Props,
): Promise<createIssuance.Response> {
  return true === connection.simulate
    ? createIssuance.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createIssuance.METADATA,
          path: createIssuance.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createIssuance {
  export type Props = {
    /** Target coupon's unique identifier for which to issue the coupon. */
    couponId: string & tags.Format<"uuid">;

    /**
     * Issuance details including customer ID, optional external code, and
     * optional expiration for this coupon issuance.
     */
    body: IShoppingMallAiBackendCouponIssuance.ICreate;
  };
  export type Body = IShoppingMallAiBackendCouponIssuance.ICreate;
  export type Response = IShoppingMallAiBackendCouponIssuance;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/issuances",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/issuances`;
  export const random = (): IShoppingMallAiBackendCouponIssuance =>
    typia.random<IShoppingMallAiBackendCouponIssuance>();
  export const simulate = (
    connection: IConnection,
    props: createIssuance.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createIssuance.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin search all coupon issuances for a couponId
 * (shopping_mall_ai_backend_coupon_issuances).
 *
 * List all issued coupon instances for a specified couponId, supporting query
 * by customer, status, and various business filters. The result is paginated
 * and returns key issuance summary fields as well as associated customer
 * references. This endpoint aids in campaign performance tracking, user
 * eligibility validation, and compliance/audit review. Only administrators are
 * granted access due to containing sensitive issuance, redemption, and usage
 * data for users.
 *
 * Pagination and filtering parameters allow tight result control. Related
 * endpoints provide issuance details or perform issuance-specific actions not
 * covered here. Errors are returned for invalid couponId or access violations.
 *
 * @param props.connection
 * @param props.couponId Unique UUID for the parent coupon.
 * @param props.body Filtering criteria and pagination options for coupon
 *   issuances (status, customer, date, etc.).
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/issuances
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique UUID for the parent coupon. */
    couponId: string & tags.Format<"uuid">;

    /**
     * Filtering criteria and pagination options for coupon issuances
     * (status, customer, date, etc.).
     */
    body: IShoppingMallAiBackendCouponIssuance.IRequest;
  };
  export type Body = IShoppingMallAiBackendCouponIssuance.IRequest;
  export type Response = IPageIShoppingMallAiBackendCouponIssuance.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/issuances",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/issuances`;
  export const random =
    (): IPageIShoppingMallAiBackendCouponIssuance.ISummary =>
      typia.random<IPageIShoppingMallAiBackendCouponIssuance.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin get full details for a coupon issuance
 * (shopping_mall_ai_backend_coupon_issuances).
 *
 * Get the complete record for a given coupon issuance assigned to a specific
 * user/campaign. All business-related and technical attributes are returned,
 * including status, assigned customer, issued_at, used_at, revoked_at, and
 * creation timestamps. Also returns primary references for the parent coupon
 * and (if present) the customer who received the coupon.
 *
 * Endpoint access is restricted to administrators due to PII and compliance
 * sensitivity. This endpoint is commonly used in support, dispute, fraud
 * investigation, and campaign management flows for per-user coupon details.
 * Error cases include invalid IDs or insufficient privileges.
 *
 * @param props.connection
 * @param props.couponId UUID of the parent coupon for cross-validation.
 * @param props.issuanceId UUID of the target coupon issuance.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the parent coupon for cross-validation. */
    couponId: string & tags.Format<"uuid">;

    /** UUID of the target coupon issuance. */
    issuanceId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCouponIssuance;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/issuances/${encodeURIComponent(props.issuanceId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCouponIssuance =>
    typia.random<IShoppingMallAiBackendCouponIssuance>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("issuanceId")(() => typia.assert(props.issuanceId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin-update a coupon issuance record's status or properties, with audit
 * traceability.
 *
 * Update, revoke, or modify the status or expiration of an existing coupon
 * issuance for a specific coupon and issuance ID. This operation supports
 * business correction, revocation in case of fraud or campaign policy change,
 * and allows status or expiration management under tight administrative
 * authority.
 *
 * The operation ensures all updates are captured in a full audit log, preserves
 * immutable fields for evidence, and supports granular error feedback when a
 * policy breach occurs (e.g. attempting to update a redeemed or revoked
 * coupon), while maintaining regulatory and compliance requirements. Typical
 * use cases include revoking a coupon that is misused, extending expiration for
 * a user, or correcting metadata.
 *
 * Only admins or campaign operators with coupon issuance permissions can use
 * this endpoint. Sensitive actions such as changing expiration or status are
 * strictly validated against current business rules and coupon policy, with
 * comprehensive controls on allowed modifications.
 *
 * @param props.connection
 * @param props.couponId Coupon ID this issuance belongs to.
 * @param props.issuanceId Unique issuance record identifier to update.
 * @param props.body Fields to update for a coupon issuance, such as status,
 *   expiration, or external code. Complies with policy.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateIssuance(
  connection: IConnection,
  props: updateIssuance.Props,
): Promise<updateIssuance.Response> {
  return true === connection.simulate
    ? updateIssuance.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateIssuance.METADATA,
          path: updateIssuance.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateIssuance {
  export type Props = {
    /** Coupon ID this issuance belongs to. */
    couponId: string & tags.Format<"uuid">;

    /** Unique issuance record identifier to update. */
    issuanceId: string & tags.Format<"uuid">;

    /**
     * Fields to update for a coupon issuance, such as status, expiration,
     * or external code. Complies with policy.
     */
    body: IShoppingMallAiBackendCouponIssuance.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCouponIssuance.IUpdate;
  export type Response = IShoppingMallAiBackendCouponIssuance;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/issuances/${encodeURIComponent(props.issuanceId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCouponIssuance =>
    typia.random<IShoppingMallAiBackendCouponIssuance>();
  export const simulate = (
    connection: IConnection,
    props: updateIssuance.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateIssuance.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("issuanceId")(() => typia.assert(props.issuanceId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an issuance record (logical removal for auditing, not physical
 * delete).
 *
 * Logically delete an existing coupon issuance for a given coupon and issuance.
 * This sets the deleted_at timestamp for compliance and business evidence,
 * ensuring the record is retained for future reference but no longer active.
 *
 * The operation safeguards against deletion of redeemed or already revoked
 * issuances, ensuring regulatory compliance and anti-fraud controls. Attempts
 * to delete ineligible issuances result in business errors indicating policy
 * violation or non-existence. This endpoint is strictly for admin/system role
 * use and should not be accessible to regular users, with audit and evidence
 * trails mandatory for all such deletions.
 *
 * Standard REST semantics apply: successful deletion returns HTTP 204 with no
 * body, errors yield relevant business status codes and descriptions. Deleted
 * issuances cannot be restored by end users.
 *
 * @param props.connection
 * @param props.couponId Coupon ID the issuance belongs to.
 * @param props.issuanceId Coupon issuance record identifier to logically
 *   delete.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseIssuance(
  connection: IConnection,
  props: eraseIssuance.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseIssuance.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseIssuance.METADATA,
          path: eraseIssuance.path(props),
          status: null,
        },
      );
}
export namespace eraseIssuance {
  export type Props = {
    /** Coupon ID the issuance belongs to. */
    couponId: string & tags.Format<"uuid">;

    /** Coupon issuance record identifier to logically delete. */
    issuanceId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/issuances/:issuanceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/issuances/${encodeURIComponent(props.issuanceId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseIssuance.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseIssuance.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("issuanceId")(() => typia.assert(props.issuanceId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
