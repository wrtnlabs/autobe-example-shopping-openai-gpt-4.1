import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCouponUsage } from "../../../../../structures/IShoppingMallAiBackendCouponUsage";
import { IPageIShoppingMallAiBackendCouponUsage } from "../../../../../structures/IPageIShoppingMallAiBackendCouponUsage";

/**
 * Paginated search/audit of all redemptions/usages for a given coupon.
 *
 * Search, audit, or analyze coupon usage (redemption) records for a specific
 * coupon. This enables authorized business users and admins to filter by status
 * (success, failed, revoked, etc.), usage date range, customer, or related
 * order identifiers, with paginated results.
 *
 * The response includes detailed redemption records with all business and
 * audit-relevant information, supporting compliance, campaign effectiveness,
 * fraud analysis, and refund reconciliation. The operation is strictly
 * controlled by business role and supports only authorized access with full
 * evidence preservation.
 *
 * @param props.connection
 * @param props.couponId Coupon ID for which redemption/usage records are
 *   searched.
 * @param props.body Filter and pagination query for coupon usage; supports
 *   date/status/customer filters.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/usages
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexCouponUsage(
  connection: IConnection,
  props: indexCouponUsage.Props,
): Promise<indexCouponUsage.Response> {
  return true === connection.simulate
    ? indexCouponUsage.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexCouponUsage.METADATA,
          path: indexCouponUsage.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexCouponUsage {
  export type Props = {
    /** Coupon ID for which redemption/usage records are searched. */
    couponId: string & tags.Format<"uuid">;

    /**
     * Filter and pagination query for coupon usage; supports
     * date/status/customer filters.
     */
    body: IShoppingMallAiBackendCouponUsage.IRequest;
  };
  export type Body = IShoppingMallAiBackendCouponUsage.IRequest;
  export type Response = IPageIShoppingMallAiBackendCouponUsage;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/usages",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/usages`;
  export const random = (): IPageIShoppingMallAiBackendCouponUsage =>
    typia.random<IPageIShoppingMallAiBackendCouponUsage>();
  export const simulate = (
    connection: IConnection,
    props: indexCouponUsage.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexCouponUsage.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full business/audit details of a specific coupon redemption record.
 *
 * Retrieve full details of a specific coupon redemption (usage) record for a
 * given coupon and usage ID. Returns granular business context and audit
 * details for regulatory, campaign, and refund review. Useful for compliance
 * staff or campaign operators verifying individual redemptions, troubleshooting
 * issues, or investigating audit trails.
 *
 * Security restrictions limit this endpoint to admin/business roles and prevent
 * access to confidential customer/redemption data by unauthorized actors. All
 * data returned is evidence-grade, ensuring traceability for disputes, refund
 * validation, or compliance workflow. Errors on non-existent or unauthorized
 * access are managed per standard business error protocols. This does not
 * expose any modification API for redemptions.
 *
 * @param props.connection
 * @param props.couponId Coupon ID for coupon usage lookup.
 * @param props.usageId Target coupon usage record identifier for detailed audit
 *   data.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId/usages/:usageId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atCouponUsage(
  connection: IConnection,
  props: atCouponUsage.Props,
): Promise<atCouponUsage.Response> {
  return true === connection.simulate
    ? atCouponUsage.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atCouponUsage.METADATA,
          path: atCouponUsage.path(props),
          status: null,
        },
      );
}
export namespace atCouponUsage {
  export type Props = {
    /** Coupon ID for coupon usage lookup. */
    couponId: string & tags.Format<"uuid">;

    /** Target coupon usage record identifier for detailed audit data. */
    usageId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCouponUsage;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId/usages/:usageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}/usages/${encodeURIComponent(props.usageId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCouponUsage =>
    typia.random<IShoppingMallAiBackendCouponUsage>();
  export const simulate = (
    connection: IConnection,
    props: atCouponUsage.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atCouponUsage.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.param("usageId")(() => typia.assert(props.usageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
