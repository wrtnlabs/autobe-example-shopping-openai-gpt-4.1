import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCoupon } from "../../../../structures/IShoppingMallAiBackendCoupon";
import { IPageIShoppingMallAiBackendCoupon } from "../../../../structures/IPageIShoppingMallAiBackendCoupon";
export * as issuances from "./issuances";
export * as usages from "./usages";
export * as codes from "./codes";
export * as stackingRules from "./stackingRules";
export * as restrictions from "./restrictions";
export * as notifications from "./notifications";

/**
 * Create a new coupon and promotion policy (shopping_mall_ai_backend_coupons).
 *
 * The API creates a new coupon and registers all necessary business parameters
 * for a promotion campaign, such as discount amount/percentage, target channels
 * or sellers, issuance and stacking limits, personal or event settings,
 * validity periods, and exclusion policies. System and business-logic
 * validation includes ensuring code uniqueness, value and date range checks,
 * compatibility with overall platform promotional restrictions, and data
 * integrity for all referenced relations.
 *
 * Only users with administrative privileges may create new coupons using this
 * endpoint. The operation is subject to compliance checks and audit controls,
 * with full creation traceability recorded.
 *
 * The new coupon is immediately available if its status is set to 'active' and
 * its published_at date is current; otherwise, it may remain scheduled or
 * hidden until manual activation or future publishing time.
 *
 * @param props.connection
 * @param props.body All business and configuration parameters required to
 *   create a coupon (discount value, code, type, duration, eligible channels,
 *   etc.)
 * @path /shoppingMallAiBackend/admin/coupons
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * All business and configuration parameters required to create a coupon
     * (discount value, code, type, duration, eligible channels, etc.)
     */
    body: IShoppingMallAiBackendCoupon.ICreate;
  };
  export type Body = IShoppingMallAiBackendCoupon.ICreate;
  export type Response = IShoppingMallAiBackendCoupon;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/coupons",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/coupons";
  export const random = (): IShoppingMallAiBackendCoupon =>
    typia.random<IShoppingMallAiBackendCoupon>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin search all coupons with advanced filtering and pagination
 * (shopping_mall_ai_backend_coupons).
 *
 * This API searches the full set of coupons available in the shopping mall
 * platform for administration and reporting purposes. It enables searching,
 * filtering, and sorting of coupons by status (active, expired, scheduled),
 * type (fixed, percentage, shipping, welcome, etc.), channel, seller, code
 * value, and time window. Filters support pagination, date ranges, stacking
 * rules, and eligibility constraints as properties of the
 * shopping_mall_ai_backend_coupons schema.
 *
 * Access is reserved for admin users who require full coupon lifecycle
 * visibility for audit, campaign analysis, and regulatory compliance. Business
 * rules enforce that soft-deleted coupons are excluded from normal search
 * results unless explicitly requested by higher privilege roles. Coupon
 * attributes such as issued/used counts allow easy tracking of campaign
 * performance.
 *
 * Admin users can use this endpoint to support overall promotional strategy,
 * compliance checks, and evidence collection for coupon usage disputes. Error
 * scenarios include invalid filter criteria and requests for pages beyond
 * available results.
 *
 * @param props.connection
 * @param props.body Coupon search and filtering criteria, including pagination
 *   and sort configuration.
 * @path /shoppingMallAiBackend/admin/coupons
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Coupon search and filtering criteria, including pagination and sort
     * configuration.
     */
    body: IShoppingMallAiBackendCoupon.IRequest;
  };
  export type Body = IShoppingMallAiBackendCoupon.IRequest;
  export type Response = IPageIShoppingMallAiBackendCoupon.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/coupons",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/coupons";
  export const random = (): IPageIShoppingMallAiBackendCoupon.ISummary =>
    typia.random<IPageIShoppingMallAiBackendCoupon.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get coupon details for a given couponId (shopping_mall_ai_backend_coupons).
 *
 * This API retrieves the complete details for a given coupon in the platform by
 * its unique identifier. All business-relevant fields are returned, including
 * code, type, value, stacking, issuance limits, campaign association, and the
 * current status of the coupon (active, expired, scheduled, hidden). The
 * operation is intended for administrators or privileged panel users managing
 * or auditing coupon campaigns.
 *
 * Security is enforced at the endpoint to restrict access to only users with
 * admin privileges. Information about the coupon's creation, updates, and
 * logical deletion (if applicable) is included for compliance and evidence
 * tracking.
 *
 * The endpoint is used to support coupon validation, dispute resolution,
 * business compliance investigations, and as a foundation for coupon editing or
 * cloning operations.
 *
 * @param props.connection
 * @param props.couponId Unique UUID for the coupon to retrieve.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique UUID for the coupon to retrieve. */
    couponId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCoupon;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoupon =>
    typia.random<IShoppingMallAiBackendCoupon>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update coupon configuration and business policy
 * (shopping_mall_ai_backend_coupons).
 *
 * Update the details of a coupon policy post-creation. This endpoint enables
 * authorized admin users to modify any mutable business attribute of a coupon
 * (such as discount value, type, time constraints, usage/issuance limits,
 * stacking or eligibility settings, target channel/seller, and metadata). It
 * validates updated parameters, ensures all references are valid, enforces code
 * and channel uniqueness, and prevents violations of platform promotional
 * rules.
 *
 * All update actions are recorded as versioned snapshots for audit and
 * compliance, including the before/after changes. Security controls limit
 * access to administrators only. Any changes to published or already-issued
 * coupons may have restricted mutability according to business or legal policy.
 * Errors may be returned for conflicts, constraint violations, or failed
 * business validations.
 *
 * @param props.connection
 * @param props.couponId Unique UUID for the coupon to update.
 * @param props.body Fields and configuration to update (all mutable coupon
 *   properties, e.g., value, type, eligibility).
 * @path /shoppingMallAiBackend/admin/coupons/:couponId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique UUID for the coupon to update. */
    couponId: string & tags.Format<"uuid">;

    /**
     * Fields and configuration to update (all mutable coupon properties,
     * e.g., value, type, eligibility).
     */
    body: IShoppingMallAiBackendCoupon.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCoupon.IUpdate;
  export type Response = IShoppingMallAiBackendCoupon;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoupon =>
    typia.random<IShoppingMallAiBackendCoupon>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a coupon (logical deletion with evidence retention,
 * shopping_mall_ai_backend_coupons).
 *
 * Soft delete a coupon record by setting its deleted_at timestamp for evidence
 * and compliance retention. This operation removes the coupon from
 * active/searchable state but preserves all information for audit, dispute, and
 * future restoration workflows. Business logic prevents accidental deletion of
 * already-deleted records or records involved in open audit/compliance cases.
 * The operation enforces role authorization at the endpoint, and only admins
 * are permitted.
 *
 * Related APIs include coupon recovery and permanent purge (for data retention
 * expiration), not covered here. If attempted on a non-existent or already
 * deleted coupon, an error is returned. Details of the soft deleted entity
 * (such as id and deleted_at) are retained for admin review.
 *
 * @param props.connection
 * @param props.couponId Unique UUID for the coupon to be deleted.
 * @path /shoppingMallAiBackend/admin/coupons/:couponId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique UUID for the coupon to be deleted. */
    couponId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/coupons/:couponId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coupons/${encodeURIComponent(props.couponId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("couponId")(() => typia.assert(props.couponId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
