import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProductInventory } from "../../../../../structures/IShoppingMallAiBackendProductInventory";
import { IPageIShoppingMallAiBackendProductInventory } from "../../../../../structures/IPageIShoppingMallAiBackendProductInventory";

/**
 * Create a new inventory record for a product.
 *
 * This API adds a new inventory record for a specific product, supporting stock
 * initialization and adding SKUs/bundles to the inventory system. Required
 * fields include available_quantity, reserved_quantity, inventory_status, and
 * last_update_at. The linkage to the product is made with productId.
 *
 * Both sellers and admins can perform this operation, typically during catalog
 * setup or expansion of available SKUs. The API checks data integrity
 * constraints and ensures accurate linkage to the parent product. Error
 * conditions such as product non-existence or data violations are communicated
 * clearly in responses.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to add inventory to.
 * @param props.body Inventory record creation payload.
 * @path /shoppingMallAiBackend/admin/products/:productId/inventories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier for the product to add inventory to. */
    productId: string & tags.Format<"uuid">;

    /** Inventory record creation payload. */
    body: IShoppingMallAiBackendProductInventory.ICreate;
  };
  export type Body = IShoppingMallAiBackendProductInventory.ICreate;
  export type Response = IShoppingMallAiBackendProductInventory;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/products/:productId/inventories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/inventories`;
  export const random = (): IShoppingMallAiBackendProductInventory =>
    typia.random<IShoppingMallAiBackendProductInventory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search product inventories by product ID.
 *
 * This API returns a paginated, optionally filtered list of inventory records
 * related to a specific product. Inventory may be filtered by inventory_status,
 * date, or other parameters to facilitate stock and warehouse management. Only
 * inventory records associated with the productId are returned. Pagination and
 * sorting enable efficient management for products with high SKU complexity.
 *
 * Both administrators and privileged sellers can access this endpoint for
 * inventory reporting, adjustment, and business analysis. This API is typically
 * used with product and order management workflows, and may be integrated with
 * fulfillment, analytics, or warehouse management features.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to list inventories
 *   for.
 * @param props.body Inventory filtering, sort, and pagination parameters.
 * @path /shoppingMallAiBackend/admin/products/:productId/inventories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the product to list inventories for. */
    productId: string & tags.Format<"uuid">;

    /** Inventory filtering, sort, and pagination parameters. */
    body: IShoppingMallAiBackendProductInventory.IRequest;
  };
  export type Body = IShoppingMallAiBackendProductInventory.IRequest;
  export type Response = IPageIShoppingMallAiBackendProductInventory;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/products/:productId/inventories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/inventories`;
  export const random = (): IPageIShoppingMallAiBackendProductInventory =>
    typia.random<IPageIShoppingMallAiBackendProductInventory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific inventory record of a product by IDs.
 *
 * This endpoint provides detailed information about a single inventory record
 * for a given product, such as available and reserved quantity, inventory
 * status, and the last time the inventory record was updated. Both the
 * productId and inventoryId must be provided.
 *
 * The operation is used by sellers and admins for real-time stock validation,
 * SKU or bundle fulfillment status reporting, and inventory analytics. Related
 * endpoints should be used for creating, updating, or indexing inventory
 * records. Error cases like missing inventoryId or a record-product
 * relationship violation are handled gracefully.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to which the
 *   inventory belongs.
 * @param props.inventoryId Unique identifier for the inventory record to
 *   retrieve.
 * @path /shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the product to which the inventory belongs. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier for the inventory record to retrieve. */
    inventoryId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendProductInventory;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/inventories/${encodeURIComponent(props.inventoryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductInventory =>
    typia.random<IShoppingMallAiBackendProductInventory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("inventoryId")(() => typia.assert(props.inventoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific inventory record of a product by IDs.
 *
 * This endpoint updates an inventory record for a specific product. Editable
 * fields include quantities, inventory_status, and last_update_at. Both
 * productId and inventoryId are required, and operations are subject to access
 * control (admin/seller only) and data integrity checks.
 *
 * Primarily used for inventory corrections, returns, or batch stock
 * adjustments. Successful updates return the updated inventory record. Failure
 * states (such as ID constraint violation or not found) are reported with
 * descriptive error messages for remediation. This is a key operation in
 * advanced stock and warehouse management flows.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the product to which the
 *   inventory belongs.
 * @param props.inventoryId Unique identifier for the inventory record to
 *   update.
 * @param props.body Fields for updating an inventory record.
 * @path /shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the product to which the inventory belongs. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier for the inventory record to update. */
    inventoryId: string & tags.Format<"uuid">;

    /** Fields for updating an inventory record. */
    body: IShoppingMallAiBackendProductInventory.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProductInventory.IUpdate;
  export type Response = IShoppingMallAiBackendProductInventory;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/inventories/${encodeURIComponent(props.inventoryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductInventory =>
    typia.random<IShoppingMallAiBackendProductInventory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("inventoryId")(() => typia.assert(props.inventoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific product inventory record by inventoryId and productId.
 *
 * Delete a product inventory entry from the ShoppingMallAiBackend system using
 * inventoryId and productId as identifiers.
 *
 * This operation is used by authorized sellers or administrators to directly
 * remove a single inventory record tied to a product. The method permanently
 * deletes the record, so that all inventory tracking for that particular entry
 * will be lost unless otherwise preserved by business logic. The corresponding
 * product remains unaffected except for the loss of this inventory slot.
 * Attempts to delete a non-existent or protected inventory will result in an
 * error response. All deletion operations are subject to business role
 * authorization and audit checks as defined by the application. The endpoint
 * enforces strict checking to prevent removal of inventory used in ongoing
 * orders or compliance processes.
 *
 * @param props.connection
 * @param props.productId Unique identifier for the parent product (UUID).
 * @param props.inventoryId Unique identifier for the target product inventory
 *   to delete (UUID).
 * @path /shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the parent product (UUID). */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier for the target product inventory to delete (UUID). */
    inventoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/products/:productId/inventories/:inventoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/inventories/${encodeURIComponent(props.inventoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("inventoryId")(() => typia.assert(props.inventoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
