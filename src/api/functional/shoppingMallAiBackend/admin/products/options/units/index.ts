import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProductOptionUnit } from "../../../../../../structures/IShoppingMallAiBackendProductOptionUnit";

/**
 * Create a new product option unit (variant value) for a specific option group
 * within a product.
 *
 * Create a new product option unit (such as a color or size variant) within a
 * specific product's option group. This operation allows sellers or
 * administrators to expand the set of selectable variations customers can
 * choose for a product, such as introducing a new color or size to an existing
 * product.
 *
 * Business validation ensures this unit value and code do not conflict with
 * other units in the same option group, preserving data integrity and accurate
 * inventory mapping. When a new unit is created, the system also records the
 * event for compliance and evidence purposes.
 *
 * Access is limited to roles authorized to manage product catalogs,
 * specifically sellers managing their own products and platform administrators
 * overseeing catalog structure. Related read/search/update APIs may be required
 * for complete option management workflows.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the option and unit
 *   are being managed.
 * @param props.optionId ID of the product option group to which the new unit
 *   will be added.
 * @param props.body Details of the new product option unit (such as color,
 *   size, code, and sort order).
 * @path /shoppingMallAiBackend/admin/products/:productId/options/:optionId/units
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * ID of the parent product for which the option and unit are being
     * managed.
     */
    productId: string & tags.Format<"uuid">;

    /** ID of the product option group to which the new unit will be added. */
    optionId: string & tags.Format<"uuid">;

    /**
     * Details of the new product option unit (such as color, size, code,
     * and sort order).
     */
    body: IShoppingMallAiBackendProductOptionUnit.ICreate;
  };
  export type Body = IShoppingMallAiBackendProductOptionUnit.ICreate;
  export type Response = IShoppingMallAiBackendProductOptionUnit;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/products/:productId/options/:optionId/units",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}/units`;
  export const random = (): IShoppingMallAiBackendProductOptionUnit =>
    typia.random<IShoppingMallAiBackendProductOptionUnit>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing product option unit's details (such as value or display
 * order) for a product option group.
 *
 * Update an existing product option unit (such as changing the display value or
 * code) within a specific product's option group. Sellers and admins use this
 * API to correct, rename, or adjust available variant options, such as changing
 * the name of a color or the order in which options appear to customers.
 *
 * All updates are validated to avoid duplicate unit codes within the option
 * group, and event modification is recorded for compliance, audit, and rollback
 * traceability.
 *
 * This API is accessible to authorized sellers for their own products and to
 * administrators overseeing global or channel catalog structures. Business
 * logic may restrict updates if the unit is in use in active orders or
 * inventory references.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the option and unit
 *   are being managed.
 * @param props.optionId ID of the product option group containing the unit.
 * @param props.unitId ID of the product option unit to update.
 * @param props.body Updated details for the product option unit (value, code,
 *   sort order, etc).
 * @path /shoppingMallAiBackend/admin/products/:productId/options/:optionId/units/:unitId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * ID of the parent product for which the option and unit are being
     * managed.
     */
    productId: string & tags.Format<"uuid">;

    /** ID of the product option group containing the unit. */
    optionId: string & tags.Format<"uuid">;

    /** ID of the product option unit to update. */
    unitId: string & tags.Format<"uuid">;

    /**
     * Updated details for the product option unit (value, code, sort order,
     * etc).
     */
    body: IShoppingMallAiBackendProductOptionUnit.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProductOptionUnit.IUpdate;
  export type Response = IShoppingMallAiBackendProductOptionUnit;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/products/:productId/options/:optionId/units/:unitId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}/units/${encodeURIComponent(props.unitId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductOptionUnit =>
    typia.random<IShoppingMallAiBackendProductOptionUnit>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.param("unitId")(() => typia.assert(props.unitId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific product option unit (variant value) from a product option
 * group (soft delete).
 *
 * Delete a specific product option unit (variant value) from a product option
 * group. This operation is used to remove obsolete or incorrect options, such
 * as discontinuing a color or size variant. It performs a logical deletion by
 * setting the deleted_at field, so that the record remains for audit, but is
 * not available in user-facing selections.
 *
 * Deletion checks ensure the unit is not linked to active inventory, orders, or
 * ongoing promotions. Every deletion event is logged for traceability and
 * compliance requirements. Only sellers managing the product or administrators
 * may invoke this endpoint.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the option and unit
 *   are being managed.
 * @param props.optionId ID of the product option group containing the unit.
 * @param props.unitId ID of the product option unit to delete.
 * @path /shoppingMallAiBackend/admin/products/:productId/options/:optionId/units/:unitId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * ID of the parent product for which the option and unit are being
     * managed.
     */
    productId: string & tags.Format<"uuid">;

    /** ID of the product option group containing the unit. */
    optionId: string & tags.Format<"uuid">;

    /** ID of the product option unit to delete. */
    unitId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/products/:productId/options/:optionId/units/:unitId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}/units/${encodeURIComponent(props.unitId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.param("unitId")(() => typia.assert(props.unitId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
