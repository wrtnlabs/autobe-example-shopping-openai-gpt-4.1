import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProductFile } from "../../../../../structures/IShoppingMallAiBackendProductFile";
import { IPageIShoppingMallAiBackendProductFile } from "../../../../../structures/IPageIShoppingMallAiBackendProductFile";

/**
 * Attach a new file or image to a product.
 *
 * Allows a seller or admin to add a new file (such as an image, manual, or
 * related attachment) to the specified product. The new file is registered with
 * its metadata and assigned a display order and is_primary status if needed.
 * Uploads are validated for content type, file size, and business logic (e.g.,
 * only one primary image per product). Ownership and access checks are enforced
 * by linking to the product and uploader’s identity. Errors include file size
 * limits, invalid file types, or permission errors for non-product owners. This
 * endpoint is used alongside file listing, update, and delete APIs for a full
 * asset management cycle.
 *
 * @param props.connection
 * @param props.productId UUID of the product to which the file will be
 *   attached.
 * @param props.body Details of the new product file (file URI, metadata,
 *   display order, etc.) for creation.
 * @path /shoppingMallAiBackend/admin/products/:productId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the product to which the file will be attached. */
    productId: string & tags.Format<"uuid">;

    /**
     * Details of the new product file (file URI, metadata, display order,
     * etc.) for creation.
     */
    body: IShoppingMallAiBackendProductFile.ICreate;
  };
  export type Body = IShoppingMallAiBackendProductFile.ICreate;
  export type Response = IShoppingMallAiBackendProductFile;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/products/:productId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/files`;
  export const random = (): IShoppingMallAiBackendProductFile =>
    typia.random<IShoppingMallAiBackendProductFile>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve files attached to a specific product with filtering and
 * pagination.
 *
 * Get a paginated, filterable list of all files (images, attachments)
 * associated with a single product. Filters may include file type, is_primary
 * status, or display order, and the endpoint supports advanced search to help
 * admins or sellers efficiently manage product assets. All returned files
 * respect product ownership, visibility rules, and exclude logically deleted
 * records (deleted_at is null). Security applies to ensure only sellers or
 * admins with appropriate rights to the product can view or manage its files.
 * Typical errors include invalid product references or attempts to access files
 * on another seller’s product without permission. This operation is often used
 * with product update and media upload APIs to provide a unified asset
 * management experience.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the associated product.
 * @param props.body Request payload to specify search filters, pagination, and
 *   sorting for product files.
 * @path /shoppingMallAiBackend/admin/products/:productId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the associated product. */
    productId: string & tags.Format<"uuid">;

    /**
     * Request payload to specify search filters, pagination, and sorting
     * for product files.
     */
    body: IShoppingMallAiBackendProductFile.IRequest;
  };
  export type Body = IShoppingMallAiBackendProductFile.IRequest;
  export type Response = IPageIShoppingMallAiBackendProductFile;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/products/:productId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/files`;
  export const random = (): IPageIShoppingMallAiBackendProductFile =>
    typia.random<IPageIShoppingMallAiBackendProductFile>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific file’s metadata for a given product.
 *
 * Returns complete information and metadata for a specific file attached to a
 * product. This may be used by sellers or admins to view file properties, for
 * rendering on product detail pages, or to support editing/removal operations.
 * The function checks product-file ownership and logical deletion status
 * (deleted_at is null), returning errors for invalid combinations or permission
 * violations. The endpoint is commonly combined with update or delete
 * operations as part of the asset lifecycle.
 *
 * @param props.connection
 * @param props.productId UUID of the parent product entity.
 * @param props.fileId Unique identifier of the file to retrieve.
 * @path /shoppingMallAiBackend/admin/products/:productId/files/:fileId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the parent product entity. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the file to retrieve. */
    fileId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendProductFile;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/products/:productId/files/:fileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductFile =>
    typia.random<IShoppingMallAiBackendProductFile>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("fileId")(() => typia.assert(props.fileId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata of a file attached to a product (e.g., display order,
 * is_primary).
 *
 * Permits authorized sellers or admins to update the metadata (such as display
 * order, is_primary, or file type) of a file attached to a specific product.
 * All updates are validated for business logic, such as ensuring only one
 * primary image per product, and correct ownership. The operation is commonly
 * used to change file order, correct mistake file types, or feature a
 * particular image. Audit trails capture all changes for compliance. Related
 * endpoints include file listing, detail view, and file deletion.
 *
 * @param props.connection
 * @param props.productId UUID of the product associated with the file.
 * @param props.fileId Unique identifier of the file to update.
 * @param props.body New metadata and information for the file update (display
 *   order, file type, is_primary, etc.)
 * @path /shoppingMallAiBackend/admin/products/:productId/files/:fileId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the product associated with the file. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the file to update. */
    fileId: string & tags.Format<"uuid">;

    /**
     * New metadata and information for the file update (display order, file
     * type, is_primary, etc.)
     */
    body: IShoppingMallAiBackendProductFile.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProductFile.IUpdate;
  export type Response = IShoppingMallAiBackendProductFile;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/products/:productId/files/:fileId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductFile =>
    typia.random<IShoppingMallAiBackendProductFile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("fileId")(() => typia.assert(props.fileId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (soft delete) a product file from a product’s attachments.
 *
 * Performs a logical (soft) deletion of a product file, marking it as deleted
 * by setting the deleted_at timestamp. The file remains available for
 * compliance review but is excluded from normal product displays and listings.
 * Typical use cases include removing outdated images, correcting misfiled
 * assets, or compliance-driven takedowns. Logical deletion ensures full audit
 * trails and supports restoration under administrative workflows. Access is
 * restricted to product owners (sellers) or administrators. Attempts to delete
 * already deleted or non-existent files trigger error responses. Closely
 * related to file creation and update endpoints as part of full asset lifecycle
 * management.
 *
 * @param props.connection
 * @param props.productId UUID for the parent product entity.
 * @param props.fileId Unique identifier for the file attachment to be logically
 *   deleted.
 * @path /shoppingMallAiBackend/admin/products/:productId/files/:fileId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID for the parent product entity. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier for the file attachment to be logically deleted. */
    fileId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/products/:productId/files/:fileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/products/${encodeURIComponent(props.productId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("fileId")(() => typia.assert(props.fileId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
