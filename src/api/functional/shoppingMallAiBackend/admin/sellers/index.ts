import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendSeller } from "../../../../structures/IShoppingMallAiBackendSeller";
import { IPageIShoppingMallAiBackendSeller } from "../../../../structures/IPageIShoppingMallAiBackendSeller";
export * as verifications from "./verifications";

/**
 * Search and retrieve filtered, paginated seller accounts (admin-only, soft
 * delete).
 *
 * Retrieve a paginated, filtered list of seller merchant accounts for
 * administrative or compliance purposes. Supports advanced search by legal
 * name, business registration number, email, account activation, and
 * verification status. Useful for onboarding reviews, regulatory audits, and
 * global vendor management.
 *
 * Admin authentication is required to access the full seller roster. The
 * response includes basic seller details as well as metadata like creation and
 * update dates, verification, and activation status. Sensitive business fields
 * are only retrievable by admin roles. Supports pagination and sorting on
 * primary searchable fields.
 *
 * This operation contributes to compliance and regulatory workflows by allowing
 * bulk review, onboarding, and forensic investigation of sellers in the system.
 * Errors or misuse generate access-denied and context-specific feedback.
 *
 * Related endpoints: individual seller retrieval, update, and lifecycle
 * management.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination parameters for sellers.
 * @path /shoppingMallAiBackend/admin/sellers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination parameters for sellers. */
    body: IShoppingMallAiBackendSeller.IRequest;
  };
  export type Body = IShoppingMallAiBackendSeller.IRequest;
  export type Response = IPageIShoppingMallAiBackendSeller.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/sellers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/sellers";
  export const random = (): IPageIShoppingMallAiBackendSeller.ISummary =>
    typia.random<IPageIShoppingMallAiBackendSeller.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a seller account by ID (admin-only, soft
 * delete aware).
 *
 * Retrieve detailed information about a single seller account identified by the
 * seller's UUID. Returns the full legal profile, including merchant's business
 * registration, contact information (email), verification and activation
 * status, timestamps, and profile extensions.
 *
 * This API is accessible only to administrative users for the sake of platform
 * safety, compliance, and business support. Attempts to access with
 * insufficient permissions result in explicit business error codes.
 *
 * Provides all information necessary for compliance checks, onboarding, support
 * investigations, or legal requests. Includes both core and metadata fields.
 * Returns 404 for unknown or deleted sellers.
 *
 * @param props.connection
 * @param props.sellerId UUID of the seller merchant account to retrieve.
 * @path /shoppingMallAiBackend/admin/sellers/:sellerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the seller merchant account to retrieve. */
    sellerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendSeller;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/sellers/:sellerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendSeller =>
    typia.random<IShoppingMallAiBackendSeller>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update existing seller merchant account info by ID (admin-only).
 *
 * Modify the business attributes of a seller merchant account identified by
 * sellerId. Allows updating name, business registration number, email,
 * is_active, and is_verified per regulatory policy. Triggering this operation
 * logs compliance/audit events for evidence preservation.
 *
 * Only admin users hold authority to alter core seller onboarding data. Failed
 * validations (duplicate business registration or email) return business error
 * codes. Soft-deleted sellers cannot be updated.
 *
 * This operation is critical for regulatory compliance, onboarding, and ongoing
 * seller management. Changes update timestamps for data correctness.
 *
 * @param props.connection
 * @param props.sellerId UUID of the seller merchant account to update.
 * @param props.body New values for seller merchant fields (name, registration,
 *   status, etc.).
 * @path /shoppingMallAiBackend/admin/sellers/:sellerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the seller merchant account to update. */
    sellerId: string & tags.Format<"uuid">;

    /**
     * New values for seller merchant fields (name, registration, status,
     * etc.).
     */
    body: IShoppingMallAiBackendSeller.IUpdate;
  };
  export type Body = IShoppingMallAiBackendSeller.IUpdate;
  export type Response = IShoppingMallAiBackendSeller;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/sellers/:sellerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendSeller =>
    typia.random<IShoppingMallAiBackendSeller>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove (soft delete) a seller merchant by ID (admin-only).
 *
 * Permanently remove a seller merchant account from the platform based on its
 * unique seller ID. This operation sets the deleted_at timestamp for evidence
 * and regulatory trace, ensuring the account is no longer active on the system.
 * Attempts to delete non-existent or already deleted sellers will result in a
 * not found error.
 *
 * Only admin users are permitted to perform this removal, ensuring compliance
 * with business policy and legal obligations. Removal cascades through related
 * business and activity records per referential integrity. All such operations
 * are logged in an audit trail for future review and evidence needs.
 *
 * @param props.connection
 * @param props.sellerId UUID of the seller merchant account to remove.
 * @path /shoppingMallAiBackend/admin/sellers/:sellerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the seller merchant account to remove. */
    sellerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/sellers/:sellerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/sellers/${encodeURIComponent(props.sellerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sellerId")(() => typia.assert(props.sellerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
