import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCustomer } from "../../../../structures/IShoppingMallAiBackendCustomer";
import { IPageIShoppingMallAiBackendCustomer } from "../../../../structures/IPageIShoppingMallAiBackendCustomer";
export * as sessions from "./sessions";
export * as externalIdentities from "./externalIdentities";
export * as withdrawals from "./withdrawals";

/**
 * Search and retrieve a paginated list of customers for admin management.
 *
 * Retrieve a paginated list of customers registered in the
 * ShoppingMallAiBackend. The endpoint supports complex search criteria such as
 * filtering by email address, phone number, real name, nickname, account status
 * (active/inactive), and verification status. Administrators can leverage this
 * API to search for newly registered users, identify unverified or suspended
 * accounts, and view users' recent activity dates for business monitoring.
 *
 * Security is crucial; only users with admin permissions may access this
 * endpoint. Returned customer details include essential profile information,
 * account status, verification flags, and last login time. Information about
 * logically deleted (withdrawn) accounts is filtered or annotated per
 * compliance requirements. This endpoint is often used in conjunction with
 * customer detail retrieval and update APIs when more granular management
 * actions are needed.
 *
 * Underlying schema relationships allow for querying session activity and
 * withdrawal history through additional endpoints. Search results are
 * paginated, enabling efficient browsing or export for audits and compliance
 * reports. Error responses are returned if the query contains invalid filters,
 * or the requesting user lacks sufficient privileges.
 *
 * @param props.connection
 * @param props.body Customer search, filter, and pagination parameters for
 *   advanced admin queries.
 * @path /shoppingMallAiBackend/admin/customers
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Customer search, filter, and pagination parameters for advanced admin
     * queries.
     */
    body: IShoppingMallAiBackendCustomer.IRequest;
  };
  export type Body = IShoppingMallAiBackendCustomer.IRequest;
  export type Response = IPageIShoppingMallAiBackendCustomer.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/customers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/customers";
  export const random = (): IPageIShoppingMallAiBackendCustomer.ISummary =>
    typia.random<IPageIShoppingMallAiBackendCustomer.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full details for a single customer account by admin.
 *
 * Retrieve detailed information for a single customer user in the
 * ShoppingMallAiBackend system. Administrators utilize this endpoint to review
 * or audit customer profile, contact channels, account status, verification
 * state, and log-in activity. This information is critical for compliance
 * review, support, and account management workflows.
 *
 * Sensitive fields such as phone number and email are only viewable by admin
 * roles for security. Profile information may be cross-referenced with session,
 * withdrawal, or external identity endpoints for full user activity history.
 * Related withdrawal or external identity data must be fetched through their
 * respective endpoints.
 *
 * If the customer account is logically deleted (withdrawn), the response will
 * be annotated accordingly. Error scenarios include not found, insufficient
 * privileges, or attempts to access removed accounts.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to retrieve.
 * @path /shoppingMallAiBackend/admin/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the customer to retrieve. */
    customerId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCustomer;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCustomer =>
    typia.random<IShoppingMallAiBackendCustomer>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update customer account profile and status for admin management.
 *
 * Update one or more fields of a customer's account by administrator control.
 * The admin can modify the real name, nickname, account activation or
 * suspension status, and the verification state. Email and phone number updates
 * undergo business checks for uniqueness and potential re-verification
 * requirements.
 *
 * All changes are validated against the model and business logic. Modification
 * events are logged for auditing, with full before/after recording in the
 * compliance trail. Password update is not supported in this endpoint and may
 * require separate processes with additional authentication.
 *
 * Post-update, the response returns the complete, up-to-date customer record.
 * Error scenarios include invalid fields, violation of business rules, or
 * attempts to update a logically deleted (withdrawn) account.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to update.
 * @param props.body Fields to update in the customer account, following admin
 *   validation.
 * @path /shoppingMallAiBackend/admin/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the customer to update. */
    customerId: string & tags.Format<"uuid">;

    /** Fields to update in the customer account, following admin validation. */
    body: IShoppingMallAiBackendCustomer.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCustomer.IUpdate;
  export type Response = IShoppingMallAiBackendCustomer;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/customers/:customerId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCustomer =>
    typia.random<IShoppingMallAiBackendCustomer>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete (withdraw) a customer without permanent data removal.
 *
 * Mark the specified customer account in the ShoppingMallAiBackend as logically
 * deleted (withdrawn) by setting the deleted_at timestamp. This operation does
 * not remove data but restricts further use and blocks login while retaining
 * the account for audit and regulatory compliance. All linked data and audit
 * logs remain accessible for authorized roles.
 *
 * Administrators use this functionality to handle account withdrawal requests,
 * respond to policy violations, or suspend accounts in line with business or
 * legal requirements. The operation is idempotent if already logically deleted.
 * Attempts to delete already-withdrawn or non-existent accounts will return
 * appropriate errors.
 *
 * @param props.connection
 * @param props.customerId Unique identifier of the customer to withdraw.
 * @path /shoppingMallAiBackend/admin/customers/:customerId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the customer to withdraw. */
    customerId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/customers/:customerId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/customers/${encodeURIComponent(props.customerId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("customerId")(() => typia.assert(props.customerId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
