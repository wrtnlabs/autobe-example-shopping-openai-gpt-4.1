import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendArticleCategory } from "../../../../structures/IShoppingMallAiBackendArticleCategory";
import { IPageIShoppingMallAiBackendArticleCategory } from "../../../../structures/IPageIShoppingMallAiBackendArticleCategory";

/**
 * Create a new article category.
 *
 * An endpoint for creating a new article category by supplying required
 * details, including the name, associated channel ID, sort order, and optional
 * description or parent category for hierarchy. Before insertion, the endpoint
 * enforces validation rules on unique category name per channel and proper
 * parent assignment for category trees. Admin or other privileged user roles
 * may be necessary to access this endpoint based on business policy.
 *
 * On success, the newly created category is returned, while error states
 * include uniqueness violations, missing or invalid required attributes, or
 * access denial. Audit fields such as created_at and updated_at are managed
 * automatically by the system.
 *
 * @param props.connection
 * @param props.body Required data to create the article category such as name,
 *   channel, and order.
 * @path /shoppingMallAiBackend/admin/articleCategories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Required data to create the article category such as name, channel,
     * and order.
     */
    body: IShoppingMallAiBackendArticleCategory.ICreate;
  };
  export type Body = IShoppingMallAiBackendArticleCategory.ICreate;
  export type Response = IShoppingMallAiBackendArticleCategory;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/articleCategories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/articleCategories";
  export const random = (): IShoppingMallAiBackendArticleCategory =>
    typia.random<IShoppingMallAiBackendArticleCategory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated article categories list.
 *
 * This endpoint returns a filtered, paginated list of article categories.
 * Filtering options can include parent category, channel, name search, or other
 * available attributes as defined in the schema. Results are paginated for
 * scalable consumption in applications such as admin panels or category
 * selection UIs.
 *
 * The underlying shopping_mall_ai_backend_article_categories model captures all
 * structural and descriptive data for categories, such as hierarchy
 * (parent_id), channel linkage, sort order, and audit fields. The operation is
 * typically used in UIs to allow users or admins to browse and select from
 * available categories for article creation or navigation.
 *
 * Security enforcement may restrict access to authenticated users or admins if
 * category management is privileged. Typical use cases include category lookup
 * for content management systems, or for populating navigation menus in
 * public-facing UIs.
 *
 * @param props.connection
 * @param props.body Advanced filter, search, or pagination options for
 *   categories.
 * @path /shoppingMallAiBackend/admin/articleCategories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Advanced filter, search, or pagination options for categories. */
    body: IShoppingMallAiBackendArticleCategory.IRequest;
  };
  export type Body = IShoppingMallAiBackendArticleCategory.IRequest;
  export type Response = IPageIShoppingMallAiBackendArticleCategory.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/articleCategories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/articleCategories";
  export const random =
    (): IPageIShoppingMallAiBackendArticleCategory.ISummary =>
      typia.random<IPageIShoppingMallAiBackendArticleCategory.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full information for a specific article category by ID.
 *
 * This endpoint returns a single article category based on its globally unique
 * articleCategoryId. The result includes all category attributes such as
 * hierarchy (parent_id), channel assignment, name, description, sorting order,
 * and audit trail timestamps.
 *
 * The operation relies on the shopping_mall_ai_backend_article_categories table
 * for persistent category data. Use cases include viewing the details of a
 * selected category in a category editor UI, or gathering comprehensive
 * information for displaying a category within a navigation tree or article
 * form.
 *
 * Error handling covers not found (invalid ID), deleted categories, or access
 * errors if the user has insufficient privilege.
 *
 * @param props.connection
 * @param props.articleCategoryId Unique identifier of the target article
 *   category.
 * @path /shoppingMallAiBackend/admin/articleCategories/:articleCategoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target article category. */
    articleCategoryId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendArticleCategory;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/articleCategories/:articleCategoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/articleCategories/${encodeURIComponent(props.articleCategoryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendArticleCategory =>
    typia.random<IShoppingMallAiBackendArticleCategory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("articleCategoryId")(() =>
        typia.assert(props.articleCategoryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a single article category by its ID.
 *
 * Allows the updating of a specific article category, selected by
 * articleCategoryId. The payload may include changes to the name (with
 * uniqueness checks within the channel), description, parent_id (if
 * reorganizing category hierarchy), and sort order. All business rules are
 * enforced to prevent hierarchy loops or name collisions.
 *
 * On successful update, the updated category information is returned. Audit
 * information (updated_at timestamp) is automatically refreshed. Only users
 * with sufficient permissions—such as admins or category managers—can perform
 * this operation. Error handling addresses invalid category IDs, permission
 * errors, or uniqueness validation failures.
 *
 * @param props.connection
 * @param props.articleCategoryId Unique identifier of the article category to
 *   update.
 * @param props.body Fields for updating the category, such as name, parent,
 *   order, or description.
 * @path /shoppingMallAiBackend/admin/articleCategories/:articleCategoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the article category to update. */
    articleCategoryId: string & tags.Format<"uuid">;

    /**
     * Fields for updating the category, such as name, parent, order, or
     * description.
     */
    body: IShoppingMallAiBackendArticleCategory.IUpdate;
  };
  export type Body = IShoppingMallAiBackendArticleCategory.IUpdate;
  export type Response = IShoppingMallAiBackendArticleCategory;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/articleCategories/:articleCategoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/articleCategories/${encodeURIComponent(props.articleCategoryId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendArticleCategory =>
    typia.random<IShoppingMallAiBackendArticleCategory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("articleCategoryId")(() =>
        typia.assert(props.articleCategoryId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently erase an article category by ID from the system (hard delete).
 *
 * Permanently remove an article category entity from the system by its unique
 * identifier. This API endpoint performs a hard delete—completely erasing the
 * record from the database instead of marking it as deleted—according to the
 * structure defined in the shopping_mall_ai_backend_article_categories Prisma
 * model.
 *
 * The operation should only be accessible to system administrators. It does not
 * handle recursive child removal or linked article reassignment; clients are
 * responsible for resolving dependent relationships before using this endpoint.
 * Any articles or hierarchical children that reference this category may
 * encounter orphaned links or business logic errors if not processed
 * beforehand.
 *
 * This hard delete operation is irreversible and bypasses any soft delete
 * mechanism. Once the category is erased, its metadata, relations, and all
 * non-cascading links are unrecoverable. Use with caution and ensure a proper
 * back-up and audit process exist at a business level, as this API is intended
 * exclusively for permanent category removal by authorized operators.
 *
 * @param props.connection
 * @param props.articleCategoryId Unique identifier of the article category to
 *   be erased
 * @path /shoppingMallAiBackend/admin/articleCategories/:articleCategoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the article category to be erased */
    articleCategoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/articleCategories/:articleCategoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/articleCategories/${encodeURIComponent(props.articleCategoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("articleCategoryId")(() =>
        typia.assert(props.articleCategoryId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
