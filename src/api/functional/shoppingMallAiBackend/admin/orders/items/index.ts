import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendOrderItem } from "../../../../../structures/IShoppingMallAiBackendOrderItem";

/**
 * Update business-allowed fields of a single order item for a specific order.
 * Table: shopping_mall_ai_backend_order_items.
 *
 * Enables authorized users (admins or system operators in most cases) to update
 * selected business attributes of a single order item, such as quantity,
 * discounts, or status, as allowed by business rules. The operation triggers
 * business validation to ensure the updates are permitted for the current order
 * state. All changes are recorded in the audit trail for compliance. Common
 * scenarios include correcting errors detected post-order, fulfilling
 * compliance requirements, or resolving after-sale customer support cases.
 *
 * @param props.connection
 * @param props.orderId Order identifier (UUID format).
 * @param props.itemId The target item's unique identifier (UUID format).
 * @param props.body Fields and updated values allowed for business-level update
 *   of an order item.
 * @path /shoppingMallAiBackend/admin/orders/:orderId/items/:itemId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Order identifier (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /** The target item's unique identifier (UUID format). */
    itemId: string & tags.Format<"uuid">;

    /**
     * Fields and updated values allowed for business-level update of an
     * order item.
     */
    body: IShoppingMallAiBackendOrderItem.IUpdate;
  };
  export type Body = IShoppingMallAiBackendOrderItem.IUpdate;
  export type Response = IShoppingMallAiBackendOrderItem;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/orders/:orderId/items/:itemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendOrderItem =>
    typia.random<IShoppingMallAiBackendOrderItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a specific order item by marking its deleted_at timestamp. Table:
 * shopping_mall_ai_backend_order_items.
 *
 * Deletes (soft deletes) a single order item by order and item ID, marking the
 * deleted_at field rather than removing the row. This acts as a logical removal
 * and preserves the record for audit/tracing, required for regulatory
 * compliance. The permitted deleter is usually an admin and is only possible
 * for items not yet fulfilled or already cancelled. Attempts to delete items in
 * an immutable state will return a business error. All deletions are logged for
 * traceability.
 *
 * @param props.connection
 * @param props.orderId Target order's unique identifier (UUID format).
 * @param props.itemId Unique identifier for the item to be deleted (UUID
 *   format).
 * @path /shoppingMallAiBackend/admin/orders/:orderId/items/:itemId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target order's unique identifier (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier for the item to be deleted (UUID format). */
    itemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/orders/:orderId/items/:itemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/items/${encodeURIComponent(props.itemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemId")(() => typia.assert(props.itemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
