import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendOrderItemSnapshot } from "../../../../../structures/IShoppingMallAiBackendOrderItemSnapshot";
import { IPageIShoppingMallAiBackendOrderItemSnapshot } from "../../../../../structures/IPageIShoppingMallAiBackendOrderItemSnapshot";

/**
 * List paginated order item snapshots (version histories) for an order.
 * Referenced table: shopping_mall_ai_backend_order_item_snapshots.
 *
 * Retrieves a paginated list of all order item snapshots for the specified
 * order, enabling viewing of historical item states for compliance or audit
 * purposes. Filtering supports reviewing by outcome, event type, or specific
 * business actions. Snapshots provide point-in-time evidence for business
 * workflow verification, dispute investigation, or regulatory reporting. Only
 * authorized admin or compliance roles may use this to avoid privacy or
 * business leakage.
 *
 * All snapshot data matches the schema structure for
 * shopping_mall_ai_backend_order_item_snapshots. Paging, sorting, and security
 * are enforced as per business policy.
 *
 * @param props.connection
 * @param props.orderId Order's unique identifier (UUID format).
 * @param props.body Search and filter criteria for snapshots on the specified
 *   order.
 * @path /shoppingMallAiBackend/admin/orders/:orderId/itemSnapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Order's unique identifier (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /** Search and filter criteria for snapshots on the specified order. */
    body: IShoppingMallAiBackendOrderItemSnapshot.IRequest;
  };
  export type Body = IShoppingMallAiBackendOrderItemSnapshot.IRequest;
  export type Response = IPageIShoppingMallAiBackendOrderItemSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/orders/:orderId/itemSnapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/itemSnapshots`;
  export const random = (): IPageIShoppingMallAiBackendOrderItemSnapshot =>
    typia.random<IPageIShoppingMallAiBackendOrderItemSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single order item snapshot for a given order and snapshot ID.
 * Table: shopping_mall_ai_backend_order_item_snapshots.
 *
 * Fetches the full details of a single order item snapshot for a given order,
 * including all versioned attributes and audit trail information. Requires both
 * order ID and snapshot ID. Intended for use cases such as compliance review,
 * legal investigation, or detailed dispute trace. Security controls ensure only
 * eligible admin/compliance users can access detailed snapshot data. Attempts
 * to access an invalid or unrelated snapshot ID will result in an error. The
 * schema is enforced strictly to comply with legal and regulatory evidence
 * standards.
 *
 * @param props.connection
 * @param props.orderId Order identifier to scope the snapshot (UUID format).
 * @param props.itemSnapshotId Unique identifier for the item snapshot (UUID
 *   format).
 * @path /shoppingMallAiBackend/admin/orders/:orderId/itemSnapshots/:itemSnapshotId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Order identifier to scope the snapshot (UUID format). */
    orderId: string & tags.Format<"uuid">;

    /** Unique identifier for the item snapshot (UUID format). */
    itemSnapshotId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendOrderItemSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/orders/:orderId/itemSnapshots/:itemSnapshotId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/orders/${encodeURIComponent(props.orderId ?? "null")}/itemSnapshots/${encodeURIComponent(props.itemSnapshotId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendOrderItemSnapshot =>
    typia.random<IShoppingMallAiBackendOrderItemSnapshot>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("orderId")(() => typia.assert(props.orderId));
      assert.param("itemSnapshotId")(() => typia.assert(props.itemSnapshotId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
