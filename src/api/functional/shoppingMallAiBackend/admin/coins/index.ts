import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendCoin } from "../../../../structures/IShoppingMallAiBackendCoin";
import { IPageIShoppingMallAiBackendCoin } from "../../../../structures/IPageIShoppingMallAiBackendCoin";
export * as transactions from "./transactions";

/**
 * Create a new digital coin wallet for a user or seller.
 *
 * Create a new coin wallet ledger for a specific user (customer) or seller. The
 * operation validates uniqueness and correctly associates the wallet to the
 * owner. Full tracking is provided with initial balances for total, usable,
 * expired, and on-hold coins. Coins may represent promotional, marketing, or
 * campaign value, and the entity supports future adjustments. Permission checks
 * ensure only admins or eligible actors can create ledgers. Related operations
 * include searching for coins and managing transactions within a ledger.
 *
 * @param props.connection
 * @param props.body Required properties to create a new coin ledger, including
 *   identifying its owner (customerId or sellerId) and initial balances if
 *   applicable.
 * @path /shoppingMallAiBackend/admin/coins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Required properties to create a new coin ledger, including
     * identifying its owner (customerId or sellerId) and initial balances
     * if applicable.
     */
    body: IShoppingMallAiBackendCoin.ICreate;
  };
  export type Body = IShoppingMallAiBackendCoin.ICreate;
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/admin/coins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/coins";
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search coin wallets with pagination and advanced filters.
 *
 * Search and retrieve a filtered, paginated list of coin ledgers in the system,
 * supporting business search by user or seller, balances, or dates. Pagination
 * and sorting options are supported via request parameters. The entity is
 * relevant for reward management, promotional credits, or seller settlement
 * use-cases. Permission to search is limited to authorized administrators due
 * to financial data visibility. Related operations include viewing ledger
 * details or transactions.
 *
 * @param props.connection
 * @param props.body Search filters, pagination, and sorting parameters for coin
 *   ledgers.
 * @path /shoppingMallAiBackend/admin/coins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search filters, pagination, and sorting parameters for coin ledgers. */
    body: IShoppingMallAiBackendCoin.IRequest;
  };
  export type Body = IShoppingMallAiBackendCoin.IRequest;
  export type Response = IPageIShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/admin/coins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/admin/coins";
  export const random = (): IPageIShoppingMallAiBackendCoin =>
    typia.random<IPageIShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details of a specific coin wallet by ID.
 *
 * Obtain complete ledger details for a coin wallet by wallet ID. Includes
 * historical balances, accrued/promotional coin information, and linkages to
 * the owning user or seller. Permission is required, restricting access to
 * administrators or the specific wallet owner for privacy and compliance, given
 * audit sensitivity of digital wallet information. This endpoint helps with
 * wallet reconciliation or transaction review. Errors are triggered if the ID
 * is not found or authorized user is missing permissions.
 *
 * @param props.connection
 * @param props.coinId Unique identifier for the target digital coin wallet
 *   ledger.
 * @path /shoppingMallAiBackend/admin/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target digital coin wallet ledger. */
    coinId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/admin/coins/:coinId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update coin wallet ledger information by ID.
 *
 * Update wallet metadata for an identified digital coin wallet, including owner
 * linkage, current balance totals, or wallet status. The operation requires the
 * coinId path parameter and a body specifying the update fields. Permission
 * controls restrict access to credentialed admins, with all modifications
 * audit-logged for financial compliance. Common update use cases include fixing
 * discrepancies, campaign adjustments, or system reconciliations. Related
 * endpoints support searching ledgers and viewing their histories.
 *
 * @param props.connection
 * @param props.coinId Unique identifier (UUID) for the digital coin wallet to
 *   update.
 * @param props.body Fields to update for the identified coin wallet, may
 *   include balances or owner profile linkage.
 * @path /shoppingMallAiBackend/admin/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) for the digital coin wallet to update. */
    coinId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the identified coin wallet, may include balances
     * or owner profile linkage.
     */
    body: IShoppingMallAiBackendCoin.IUpdate;
  };
  export type Body = IShoppingMallAiBackendCoin.IUpdate;
  export type Response = IShoppingMallAiBackendCoin;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/admin/coins/:coinId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/admin/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendCoin =>
    typia.random<IShoppingMallAiBackendCoin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a coin wallet ledger permanently by ID (hard delete).
 *
 * Hard delete a coin wallet for the specified ID. This action cannot be undone
 * and is only allowed for admin users with the highest permissions in
 * operational, compliance, or test environments. All traces and balances for
 * the coin wallet are permanently removed from the active database, but audit
 * logs retain the removal event. Common reasons include system correction, test
 * record cleanup, or compliance-driven ledger elimination. Errors are returned
 * for unauthorized calls or ledgers with dependent business history.
 *
 * @param props.connection
 * @param props.coinId Unique identifier (UUID) for the coin wallet to delete.
 * @path /shoppingMallAiBackend/admin/coins/:coinId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) for the coin wallet to delete. */
    coinId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/admin/coins/:coinId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/admin/coins/${encodeURIComponent(props.coinId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("coinId")(() => typia.assert(props.coinId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
