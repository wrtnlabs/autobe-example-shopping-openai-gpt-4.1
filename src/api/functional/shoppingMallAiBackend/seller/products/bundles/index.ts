import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProductBundle } from "../../../../../structures/IShoppingMallAiBackendProductBundle";
import { IPageIShoppingMallAiBackendProductBundle } from "../../../../../structures/IPageIShoppingMallAiBackendProductBundle";

/**
 * Create a new product bundle (SKU variant) for a specific product.
 *
 * Create a new bundle (SKU/variant) for a product, associating a unique
 * combination of option unit selections, SKU code, price, and inventory policy.
 * Bundles provide fine-grained control over what combinations are sold, at what
 * price, and with individualized inventory or policy settings.
 *
 * Sellers and admins use this API to add new offerings for a product such as
 * adding [Red, XL] in addition to [Red, L], optionally with distinct pricing or
 * inventory tracking. All validations are performed for unique SKU code, valid
 * product linkage, and business rule conformity. The operation is fully audit
 * logged for compliance and future reference.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the new bundle
 *   (variant) is created.
 * @param props.body Input data for bundle creation: option unit selection, SKU
 *   code, price, policy, activation flag.
 * @path /shoppingMallAiBackend/seller/products/:productId/bundles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * ID of the parent product for which the new bundle (variant) is
     * created.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Input data for bundle creation: option unit selection, SKU code,
     * price, policy, activation flag.
     */
    body: IShoppingMallAiBackendProductBundle.ICreate;
  };
  export type Body = IShoppingMallAiBackendProductBundle.ICreate;
  export type Response = IShoppingMallAiBackendProductBundle;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/seller/products/:productId/bundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles`;
  export const random = (): IShoppingMallAiBackendProductBundle =>
    typia.random<IShoppingMallAiBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search all bundles/SKUs for a specific product.
 *
 * Retrieve a paginated, searchable list of bundles for a specific product. Each
 * bundle represents a unique variant grouping (such as [Red, Large]) with its
 * own SKU code and pricing. Sellers use this API to review available
 * combinations, check activation status, and manage inventory per bundle.
 *
 * Query may support filters such as bundle name, SKU, price, or activation
 * status, and supports paging for large catalogs. The response contains summary
 * information to support further management actions, such as updating or
 * deleting bundles.
 *
 * Accessible by authorized sellers for their own products or platform
 * administrators overseeing catalog structure.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which bundles (variants)
 *   should be listed.
 * @param props.body Search, filter, and pagination parameters for product
 *   bundles of a specific product.
 * @path /shoppingMallAiBackend/seller/products/:productId/bundles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * ID of the parent product for which bundles (variants) should be
     * listed.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination parameters for product bundles of a
     * specific product.
     */
    body: IShoppingMallAiBackendProductBundle.IRequest;
  };
  export type Body = IShoppingMallAiBackendProductBundle.IRequest;
  export type Response = IPageIShoppingMallAiBackendProductBundle.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/seller/products/:productId/bundles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles`;
  export const random = (): IPageIShoppingMallAiBackendProductBundle.ISummary =>
    typia.random<IPageIShoppingMallAiBackendProductBundle.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific product bundle (SKU/variant) of a
 * product.
 *
 * Retrieve detailed information about a specific product bundle (SKU variant)
 * within a product's catalog. Bundles represent a set of option unit selections
 * (such as [Red, Large]) and carry their own business attributes like SKU code,
 * price, activation status, and inventory policies.
 *
 * Sellers and admins use this endpoint to inspect bundle configuration for
 * management purposes such as updating, enabling/disabling, or reviewing
 * inventory. Response delivers all business fields as defined in the Prisma
 * schema for shopping_mall_ai_backend_product_bundles.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the bundle
 *   (variant) is managed.
 * @param props.bundleId ID of the unique bundle (SKU/variant) within the
 *   product.
 * @path /shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** ID of the parent product for which the bundle (variant) is managed. */
    productId: string & tags.Format<"uuid">;

    /** ID of the unique bundle (SKU/variant) within the product. */
    bundleId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendProductBundle;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles/${encodeURIComponent(props.bundleId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductBundle =>
    typia.random<IShoppingMallAiBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("bundleId")(() => typia.assert(props.bundleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of an existing product bundle (SKU/variant) for a product.
 *
 * Update attributes for an existing bundle (SKU/variant) of a product. Sellers
 * and admins may change the bundle name, SKU code, price, inventory policy,
 * activation status, or other business attributes to reflect catalog updates or
 * corrections. All updates are validated for unique SKU code, compatible
 * inventory linking, and pricing logic, and are timestamped for future audit
 * and compliance.
 *
 * Access is limited to product owners (sellers) and platform administrators,
 * maintaining catalog integrity and evidence requirements for business
 * operations. The update is non-destructive and maintains logical association
 * with the parent product.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the bundle
 *   (variant) is being updated.
 * @param props.bundleId ID of the unique bundle (SKU/variant) within the
 *   product to update.
 * @param props.body Bundle attribute modifications (name, SKU, price, inventory
 *   policy, activation flag, etc).
 * @path /shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * ID of the parent product for which the bundle (variant) is being
     * updated.
     */
    productId: string & tags.Format<"uuid">;

    /** ID of the unique bundle (SKU/variant) within the product to update. */
    bundleId: string & tags.Format<"uuid">;

    /**
     * Bundle attribute modifications (name, SKU, price, inventory policy,
     * activation flag, etc).
     */
    body: IShoppingMallAiBackendProductBundle.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProductBundle.IUpdate;
  export type Response = IShoppingMallAiBackendProductBundle;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles/${encodeURIComponent(props.bundleId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductBundle =>
    typia.random<IShoppingMallAiBackendProductBundle>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("bundleId")(() => typia.assert(props.bundleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific product bundle (SKU/variant) for a product (soft delete).
 *
 * Delete a specific bundle (SKU/variant) of a product from the catalog (soft
 * delete). Bundles typically represent unique combinations of option unit
 * selections such as color and size, and removing them prevents the sale of the
 * combination without destroying audit evidence. The deletion is logical (sets
 * deleted_at) and validated to ensure there are no dependent active orders or
 * inventory allocations.
 *
 * All deletion events are audit logged, and only sellers managing the product
 * or platform admins may invoke this operation. Business logic ensures that
 * user-facing elements and analytics ignore logically deleted bundles, but
 * legal and audit evidence are preserved.
 *
 * @param props.connection
 * @param props.productId ID of the parent product for which the bundle
 *   (variant) is being deleted.
 * @param props.bundleId ID of the unique bundle (SKU/variant) within the
 *   product to delete.
 * @path /shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * ID of the parent product for which the bundle (variant) is being
     * deleted.
     */
    productId: string & tags.Format<"uuid">;

    /** ID of the unique bundle (SKU/variant) within the product to delete. */
    bundleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/seller/products/:productId/bundles/:bundleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/bundles/${encodeURIComponent(props.bundleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("bundleId")(() => typia.assert(props.bundleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
