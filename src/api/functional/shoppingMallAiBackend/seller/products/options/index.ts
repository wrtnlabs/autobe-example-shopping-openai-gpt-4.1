import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProductOptions } from "../../../../../structures/IShoppingMallAiBackendProductOptions";
import { IPageIShoppingMallAiBackendProductOptions } from "../../../../../structures/IPageIShoppingMallAiBackendProductOptions";
export * as units from "./units";

/**
 * Create a new option group for a specific product.
 *
 * Create a new option group for the specified product. This operation allows
 * authorized sellers to define new configurable options for products,
 * supporting customization and flexibility for buyers. Each creation is
 * recorded for evidence and can participate in audit/rollback through
 * associated snapshot logic.
 *
 * On success, returns the created option group with all assigned attributes.
 * Duplicate option names may be subject to business constraints (e.g., only one
 * 'color' per product). Error states include invalid input or insufficient
 * permissions. Combined with list, get, update, and delete for product option
 * lifecycle management.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product for the new
 *   option group.
 * @param props.body Specification of the new product option group, including
 *   name, required flag, and sort order.
 * @path /shoppingMallAiBackend/seller/products/:productId/options
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the parent product for the new option group. */
    productId: string & tags.Format<"uuid">;

    /**
     * Specification of the new product option group, including name,
     * required flag, and sort order.
     */
    body: IShoppingMallAiBackendProductOptions.ICreate;
  };
  export type Body = IShoppingMallAiBackendProductOptions.ICreate;
  export type Response = IShoppingMallAiBackendProductOptions;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/seller/products/:productId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/options`;
  export const random = (): IShoppingMallAiBackendProductOptions =>
    typia.random<IShoppingMallAiBackendProductOptions>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated search and filter of option groups for a product.
 *
 * Retrieve a paginated and searchable list of all option groups for the
 * specified product. Sellers and admins can use this API to view, filter, and
 * sort product options based on business criteria, such as option_name,
 * required/optional status, and ordering preferences. Options that have been
 * soft deleted (deleted_at set) will not be included unless special admin
 * filtering is applied for audit or rollback purposes.
 *
 * This API enforces pagination and may support advanced filters for large-scale
 * catalogs and variants. Authorization is required; sellers of the product or
 * admins may access, and all queries are logged for compliance. The operation
 * is designed for use with UI listing, bulk editing, or product detail
 * interfaces.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the parent product whose
 *   options to retrieve.
 * @param props.body Search/filter parameters including pagination and optional
 *   filters for option_name, required flag, and sorting options.
 * @path /shoppingMallAiBackend/seller/products/:productId/options
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * The unique identifier of the parent product whose options to
     * retrieve.
     */
    productId: string & tags.Format<"uuid">;

    /**
     * Search/filter parameters including pagination and optional filters
     * for option_name, required flag, and sorting options.
     */
    body: IShoppingMallAiBackendProductOptions.IRequest;
  };
  export type Body = IShoppingMallAiBackendProductOptions.IRequest;
  export type Response = IPageIShoppingMallAiBackendProductOptions;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/seller/products/:productId/options",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/options`;
  export const random = (): IPageIShoppingMallAiBackendProductOptions =>
    typia.random<IPageIShoppingMallAiBackendProductOptions>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information about a specific product option group.
 *
 * Retrieve the detailed information of a specific product option group for the
 * target product. Appropriate for use by sellers wishing to edit or audit their
 * product's options or by admins for compliance review. Only active (not
 * soft-deleted) options are accessible to sellers; all retrievals are logged
 * for compliance and evidence purposes.
 *
 * If the option is not found or is already soft-deleted, a not found or access
 * denied error is returned. Typically paired with update and delete operations
 * in the product management UI.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product.
 * @param props.optionId Unique identifier of the product option to retrieve.
 * @path /shoppingMallAiBackend/seller/products/:productId/options/:optionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the parent product. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the product option to retrieve. */
    optionId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendProductOptions;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/seller/products/:productId/options/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductOptions =>
    typia.random<IShoppingMallAiBackendProductOptions>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing option group for a product.
 *
 * Update the details of an existing option group for the specified product.
 * Used to rename, reorder, or change required/optional status or details for
 * the option group. All updates are snapshotted and logged, with rollback and
 * evidence support for business and legal requirements. Only sellers with
 * access to the product and admins may update product options. All failed
 * update attempts (due to missing record, deletion, or permission error) result
 * in detailed error reporting.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product the option
 *   belongs to.
 * @param props.optionId Unique identifier of the option group to update.
 * @param props.body Specification of the updated product option group fields.
 * @path /shoppingMallAiBackend/seller/products/:productId/options/:optionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the parent product the option belongs to. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the option group to update. */
    optionId: string & tags.Format<"uuid">;

    /** Specification of the updated product option group fields. */
    body: IShoppingMallAiBackendProductOptions.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProductOptions.IUpdate;
  export type Response = IShoppingMallAiBackendProductOptions;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/seller/products/:productId/options/:optionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProductOptions =>
    typia.random<IShoppingMallAiBackendProductOptions>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a product option group, preserving audit history.
 *
 * Soft delete a product option group for the specified product. This sets the
 * deleted_at timestamp, hiding the option from all business and customer-facing
 * APIs while retaining auditability. Only the option's owner (seller) or admin
 * can perform this action. All deletions are evidence-logged and support
 * business rollback policies. Attempts to delete a non-existent or
 * already-deleted option return an error. Designed for use with listing,
 * detail, create, and update APIs in product administration interfaces. Favored
 * over hard deletion due to evidence and compliance requirements.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the parent product context for
 *   the option group.
 * @param props.optionId Unique identifier of the option group to delete.
 * @path /shoppingMallAiBackend/seller/products/:productId/options/:optionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the parent product context for the option group. */
    productId: string & tags.Format<"uuid">;

    /** Unique identifier of the option group to delete. */
    optionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/seller/products/:productId/options/:optionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}/options/${encodeURIComponent(props.optionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.param("optionId")(() => typia.assert(props.optionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
