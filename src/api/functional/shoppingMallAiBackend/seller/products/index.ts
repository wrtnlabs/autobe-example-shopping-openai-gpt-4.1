import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendProduct } from "../../../../structures/IShoppingMallAiBackendProduct";
import { IPageIShoppingMallAiBackendProduct } from "../../../../structures/IPageIShoppingMallAiBackendProduct";
export * as options from "./options";
export * as bundles from "./bundles";
export * as files from "./files";
export * as inventories from "./inventories";

/**
 * Register a new product with all required business and commerce attributes.
 *
 * This endpoint allows registered sellers or administrators to create a new
 * product in the commerce platform. All required fields, including product
 * title, slug, product type, status, tax code, and order quantity limits, must
 * be provided in the request body. Optional description can supply additional
 * business content.
 *
 * Upon creation, a new product ID is generated, timestamps are set, and the
 * product becomes available for further update or publishing according to
 * business workflow.
 *
 * Strict validation is performed to ensure slug uniqueness, value constraints,
 * and legal compliance (if required). This is the core onboarding step for new
 * catalog items and supports multi-channel retail, analytics, and inventory
 * flows.
 *
 * @param props.connection
 * @param props.body Business and commerce details for product creation.
 * @path /shoppingMallAiBackend/seller/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Business and commerce details for product creation. */
    body: IShoppingMallAiBackendProduct.ICreate;
  };
  export type Body = IShoppingMallAiBackendProduct.ICreate;
  export type Response = IShoppingMallAiBackendProduct;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/seller/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/seller/products";
  export const random = (): IShoppingMallAiBackendProduct =>
    typia.random<IShoppingMallAiBackendProduct>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated list of all products with advanced filtering
 * and search.
 *
 * This API enables authenticated sellers and administrators to retrieve a
 * comprehensive, paginated, and filterable list of products in the marketplace.
 * Advanced search criteria include product title, slug, product_type,
 * business_status (draft, active, paused, etc.), category membership, and
 * full-text search on title and description.
 *
 * Results may be sorted by last updated, creation time, popularity, or business
 * priority, and can be used for both administrative management and
 * seller-centric product portfolios. Response format may include only summary
 * product attributes for efficiency. Sensitive/unpublished records may be
 * scoped for admin users only as per business policy.
 *
 * This endpoint is essential for catalog management, bulk operations,
 * analytics, and UI/UX experiences where list retrieval is needed.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for products.
 * @path /shoppingMallAiBackend/seller/products
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination parameters for products. */
    body: IShoppingMallAiBackendProduct.IRequest;
  };
  export type Body = IShoppingMallAiBackendProduct.IRequest;
  export type Response = IPageIShoppingMallAiBackendProduct.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/shoppingMallAiBackend/seller/products",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/shoppingMallAiBackend/seller/products";
  export const random = (): IPageIShoppingMallAiBackendProduct.ISummary =>
    typia.random<IPageIShoppingMallAiBackendProduct.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed business and commerce information for a single product by
 * ID.
 *
 * Provides complete business, inventory, and commerce field values for a
 * specific product identified by productId. All core attributes (title, slug,
 * description, type, status, tax, quantity limits, timestamps) are included for
 * use in management UI, analytics, or cross-entity reference.
 *
 * Access is available to administrators and sellers (with filtering if not
 * owner or privilege scoped). This endpoint is critical for product detail
 * management, update logic, and displaying individual product cards in B2B/B2C
 * UI flows.
 *
 * Errors are returned if the product does not exist, or if access is not
 * permitted by business role/policy. Field-level visibility may vary by
 * consumer role.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to retrieve.
 * @path /shoppingMallAiBackend/seller/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the product to retrieve. */
    productId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendProduct;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/seller/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProduct =>
    typia.random<IShoppingMallAiBackendProduct>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update all mutable fields for a specific product, triggering a business/audit
 * snapshot.
 *
 * Enables authorized admins or sellers to update the core business, status, or
 * commerce-related attributes of a single product. This action triggers an
 * update timestamp, compliance snapshot, and may require validation of value
 * formats (min/max, uniqueness, status, etc.).
 *
 * Only mutable fields are updatable. System handles timestamping and
 * snapshotting for audit and rollback, per business requirements. Errors are
 * returned if product does not exist, is locked, or request is
 * malformed/unauthorized.
 *
 * Use cases include catalog maintenance, correcting product data, status
 * transitions (e.g., draft → active), or responding to audit/legal requests.
 * Field-level authority or mutability may vary based on user role or business
 * policy.
 *
 * @param props.connection
 * @param props.productId Unique identifier of the product to update.
 * @param props.body Updated commerce and business details for the product.
 * @path /shoppingMallAiBackend/seller/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the product to update. */
    productId: string & tags.Format<"uuid">;

    /** Updated commerce and business details for the product. */
    body: IShoppingMallAiBackendProduct.IUpdate;
  };
  export type Body = IShoppingMallAiBackendProduct.IUpdate;
  export type Response = IShoppingMallAiBackendProduct;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/seller/products/:productId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendProduct =>
    typia.random<IShoppingMallAiBackendProduct>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a product by setting its deleted_at timestamp, preserving for
 * audit, rollback, and compliance.
 *
 * This operation allows authorized users (typically sellers or admins) to
 * logically delete a product from the shopping mall backend by setting the
 * deleted_at field rather than removing the row from the database, in
 * conformance with evidence requirements described in the business rules. The
 * soft-deleted product will be omitted from all commerce-facing APIs, listings,
 * and searches but remains queryable through audit and admin evidence
 * interfaces.
 *
 * Security and auditing are enforced; only permitted roles may perform this
 * action, and all attempts are recorded with timestamp and actor for
 * traceability. All referential entities (options, bundles, files, categories,
 * etc.) are left intact, but are no longer accessible from normal commerce
 * flows. If the product is already deleted or does not exist, a clear error is
 * returned.
 *
 * Business logic ensures that no accidental data loss occurs, supporting
 * rollback in the event of dispute or compliance review. This operation must be
 * coordinated with snapshot/evidence systems for auditability. Related product
 * management APIs should be used together for a complete product lifecycle.
 *
 * @param props.connection
 * @param props.productId The unique identifier of the target product to delete.
 * @path /shoppingMallAiBackend/seller/products/:productId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the target product to delete. */
    productId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/seller/products/:productId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/products/${encodeURIComponent(props.productId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("productId")(() => typia.assert(props.productId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
