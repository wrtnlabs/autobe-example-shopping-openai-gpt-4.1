import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IShoppingMallAiBackendInquiryReply } from "../../../../../structures/IShoppingMallAiBackendInquiryReply";

/**
 * Retrieve a specific inquiry reply by ID, ensuring permission checks.
 *
 * Retrieve a specific reply to a given inquiry. This endpoint returns all
 * details about the reply, including its content, privacy setting (whether the
 * reply is public or private), author association (either a customer or
 * seller), parent reply if nested, and timestamps such as creation and update
 * times.
 *
 * This operation ensures the caller has permission to view the reply: for
 * private replies, only the participant customer, seller, or platform admins
 * can view; for public replies, anyone with access to the parent inquiry may
 * view. The underlying table, shopping_mall_ai_backend_inquiry_replies,
 * provides full evidence and audit through its model structure for business
 * compliance and traceability.
 *
 * This endpoint is typically used for displaying threaded Q&A or after-sales
 * communication in the user's purchase history, product detail, or support
 * interface. If the reply is not found or access is denied, the system will
 * return a 404 or appropriate authorization error consistent with business
 * audit policies.
 *
 * @param props.connection
 * @param props.inquiryId Unique identifier of the parent inquiry.
 * @param props.replyId Unique identifier for the reply to retrieve.
 * @path /shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the parent inquiry. */
    inquiryId: string & tags.Format<"uuid">;

    /** Unique identifier for the reply to retrieve. */
    replyId: string & tags.Format<"uuid">;
  };
  export type Response = IShoppingMallAiBackendInquiryReply;

  export const METADATA = {
    method: "GET",
    path: "/shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendInquiryReply =>
    typia.random<IShoppingMallAiBackendInquiryReply>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific reply to an inquiry by reply ID.
 *
 * Update an existing reply for a given inquiry. Only the author of the reply
 * (customer or seller) or authorized admins are allowed to perform the update.
 * This operation supports modification of reply content (body) and privacy
 * setting only.
 *
 * Any change is logged for business traceability and dispute compliance. The
 * request body must provide updated fields following the
 * shopping_mall_ai_backend_inquiry_replies model rules. If the reply or inquiry
 * is not found or if permissions are insufficient, an error response is
 * returned.
 *
 * This operation is mainly used for after-sales communication correction, Q&A
 * follow-ups, and compliance-driven corrections. All updates are captured in
 * historical snapshots for business recovery and audit.
 *
 * @param props.connection
 * @param props.inquiryId Unique identifier of the inquiry to which the reply
 *   belongs.
 * @param props.replyId Unique identifier for the reply to update.
 * @param props.body Update data for the reply: body text and privacy flag.
 * @path /shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the inquiry to which the reply belongs. */
    inquiryId: string & tags.Format<"uuid">;

    /** Unique identifier for the reply to update. */
    replyId: string & tags.Format<"uuid">;

    /** Update data for the reply: body text and privacy flag. */
    body: IShoppingMallAiBackendInquiryReply.IUpdate;
  };
  export type Body = IShoppingMallAiBackendInquiryReply.IUpdate;
  export type Response = IShoppingMallAiBackendInquiryReply;

  export const METADATA = {
    method: "PUT",
    path: "/shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): IShoppingMallAiBackendInquiryReply =>
    typia.random<IShoppingMallAiBackendInquiryReply>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
      assert.param("replyId")(() => typia.assert(props.replyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a reply to a given inquiry (preserving for audit).
 *
 * Soft-deletes the specified reply belonging to a given inquiry. The deleted_at
 * field is set to the current timestamp to preserve the evidence trail for
 * business, compliance, or legal review. This operation is allowed for reply
 * authors (customer or seller) or admins with proper authorization. The
 * soft-deletion ensures that the reply is hidden from standard retrieval but
 * remains in the database for possible future audit or recovery needs.
 *
 * Attempting to delete a reply not authored by the current user or without
 * sufficient permission will result in an error response. This supports
 * regulatory and compliance scenarios in buyer-seller-admin engagement
 * workflows.
 *
 * @param props.connection
 * @param props.inquiryId Unique identifier of the inquiry to which the reply
 *   belongs.
 * @param props.replyId Unique identifier for the reply to erase (soft-delete).
 * @path /shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the inquiry to which the reply belongs. */
    inquiryId: string & tags.Format<"uuid">;

    /** Unique identifier for the reply to erase (soft-delete). */
    replyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/shoppingMallAiBackend/seller/inquiries/:inquiryId/replies/:replyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/shoppingMallAiBackend/seller/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}/replies/${encodeURIComponent(props.replyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
      assert.param("replyId")(() => typia.assert(props.replyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new reply for a specific inquiry.
 *
 * Creates a new reply for the specified inquiry. This operation allows both
 * customer and seller roles to participate in inquiry threads, as long as their
 * session matches the inquiry context. The request body includes the reply
 * message, privacy setting, and optionally a parent reply ID for threaded
 * discussion support.
 *
 * Full reply details are stored, and an associated audit trail is logged for
 * compliance and dispute evidence. The Prisma schema ensures all required
 * fields, such as body and privacy, are validated, and links to the parent
 * inquiry and optionally a parent reply.
 *
 * If the reply creation fails (e.g., due to invalid inquiryId or insufficient
 * permission), an error will be returned in accordance with business workflow
 * rules. Successful responses will return the complete reply entity with
 * timestamps, author reference, and relationship context.
 *
 * @param props.connection
 * @param props.inquiryId Unique identifier of the parent inquiry for which the
 *   reply is being created.
 * @param props.body Reply creation data: body text, privacy flag, and optional
 *   parent reply ID for threading.
 * @path /shoppingMallAiBackend/seller/inquiries/:inquiryId/replies
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the parent inquiry for which the reply is being
     * created.
     */
    inquiryId: string & tags.Format<"uuid">;

    /**
     * Reply creation data: body text, privacy flag, and optional parent
     * reply ID for threading.
     */
    body: IShoppingMallAiBackendInquiryReply.ICreate;
  };
  export type Body = IShoppingMallAiBackendInquiryReply.ICreate;
  export type Response = IShoppingMallAiBackendInquiryReply;

  export const METADATA = {
    method: "POST",
    path: "/shoppingMallAiBackend/seller/inquiries/:inquiryId/replies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/shoppingMallAiBackend/seller/inquiries/${encodeURIComponent(props.inquiryId ?? "null")}/replies`;
  export const random = (): IShoppingMallAiBackendInquiryReply =>
    typia.random<IShoppingMallAiBackendInquiryReply>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("inquiryId")(() => typia.assert(props.inquiryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
